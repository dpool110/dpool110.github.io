<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>面试题 | 不愿努力的帅洋</title><meta name="author" content="陈子洋"><meta name="copyright" content="陈子洋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="graph TDa(用户发起请求)–&gt;b(zuulControlelr)b–&gt;c(zuulServlet)c–&gt;d(zuulRunner)d–&gt;e(zuulRunner调用FilterProcessor执行各种Filter)e–&gt;f(FilterProcessor通过FilterLoader加载Filter)f–&gt;g(init初始化,pre前置Filter,ro">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题">
<meta property="og:url" content="http://example.com/2022/02/28/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="不愿努力的帅洋">
<meta property="og:description" content="graph TDa(用户发起请求)–&gt;b(zuulControlelr)b–&gt;c(zuulServlet)c–&gt;d(zuulRunner)d–&gt;e(zuulRunner调用FilterProcessor执行各种Filter)e–&gt;f(FilterProcessor通过FilterLoader加载Filter)f–&gt;g(init初始化,pre前置Filter,ro">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg">
<meta property="article:published_time" content="2022-02-28T06:00:37.000Z">
<meta property="article:modified_time" content="2022-10-31T01:49:43.467Z">
<meta property="article:author" content="陈子洋">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2022/02/28/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '面试题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-31 09:49:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/font.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210310921391.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 门面</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 整理整理</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 芝士=💪</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span> 数据结构</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 哔哔叨🤫</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><span> 说说</span></a></li><li><a class="site-page child" href="/plan/"><span> 计划表</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">不愿努力的帅洋</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 门面</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 整理整理</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 芝士=💪</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span> 数据结构</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heart"></i><span> 哔哔叨🤫</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><span> 说说</span></a></li><li><a class="site-page child" href="/plan/"><span> 计划表</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面试题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-28T06:00:37.000Z" title="发表于 2022-02-28 14:00:37">2022-02-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-10-31T01:49:43.467Z" title="更新于 2022-10-31 09:49:43">2022-10-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/">编程开发学习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="面试题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>graph TD<br>a(用户发起请求)–&gt;b(zuulControlelr)<br>b–&gt;c(zuulServlet)<br>c–&gt;d(zuulRunner)<br>d–&gt;e(zuulRunner调用FilterProcessor执行各种Filter)<br>e–&gt;f(FilterProcessor通过FilterLoader加载Filter)<br>f–&gt;g(init初始化,pre前置Filter,router路由Filter,post后置Filter,error异常Filter)<br>g–&gt;h(将执行结果返回)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">a(用户发起请求)--&gt;b(zuulControlelr)</span><br><span class="line">b--&gt;c(zuulServlet)</span><br><span class="line">c--&gt;d(zuulRunner)</span><br><span class="line">d--&gt;e(zuulRunner调用FilterProcessor执行各种Filter)</span><br><span class="line">e--&gt;f(FilterProcessor通过FilterLoader加载Filter)</span><br><span class="line">f--&gt;g(init初始化,pre前置Filter,router路由Filter,post后置Filter,error异常Filter)</span><br><span class="line">g--&gt;h(将执行结果返回)</span><br></pre></td></tr></table></figure>



<h2 id="当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么"><a href="#当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么" class="headerlink" title="当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么?"></a>当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么?</h2><h2 id="网站是如何访问的"><a href="#网站是如何访问的" class="headerlink" title="网站是如何访问的?"></a>网站是如何访问的?</h2><ol>
<li>输入一个域名</li>
<li>检查本机下C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射<ol>
<li>有直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问(127.0.0.1 “域名”)</li>
<li>没有就去DNS服务器找，找到就返回，找不着就返回找不到</li>
</ol>
</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/23/QMAqWFmNs9uUaOe.png"></p>
<h2 id="构造器Constructor是否可被override"><a href="#构造器Constructor是否可被override" class="headerlink" title="构造器Constructor是否可被override?"></a>构造器Constructor是否可被override?</h2><p>Constructor不能被继承，所以Constructor也就不能被override。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造函数。</p>
<p>Java在构造实例时的顺序是这样的：</p>
<p>1、分配对象空间，并将对象中成员初始化为0或者空，java不允许用户操纵一个不定值的对象。</p>
<p>2、执行属性值的显式初始化 　　</p>
<p>3、执行构造器 　　</p>
<p>4 、将变量关联到堆中的对象上</p>
<p>而执行构造器的步骤有可以分为以下几步：</p>
<p>1、Bind构造器的参数</p>
<p>2、如果显式的调用了this，那就递归调用this构造器然后跳到步骤5</p>
<p>3、递归调用显式或者隐式的父类构造器，除了Object以外，因为它没有父类</p>
<p>4、执行显式的实例变量初始化（也就是上边的流程中的第二步，调用返回以后执行，</p>
<p>这个步骤相当于在父构造器执行后隐含执行的，看样子像一个特殊处理）</p>
<p>三、构造器不可被orerride（why）</p>
<p>其实你只需要记住一句话：构造器不是方法，那么用来修饰方法特性的所有修饰符都不能用来修饰构造器（并不等与构造器具备这些特性，虽然不能用static修饰构造器，但它却有静态特性）构造器只能用 public private protected这三个权限修饰符，且不能有返回语句。</p>
<h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p><strong>重载</strong>： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同</p>
<p><strong>重写</strong>： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法</p>
<h2 id="String-为什么是不可变的-StringBuffer、StringBuilder为什么是可变的？"><a href="#String-为什么是不可变的-StringBuffer、StringBuilder为什么是可变的？" class="headerlink" title="String 为什么是不可变的?StringBuffer、StringBuilder为什么是可变的？"></a>String 为什么是不可变的?StringBuffer、StringBuilder为什么是可变的？</h2><p>String类中有一个char数组，并且这个char数组是被final修饰的。因为数组一旦创建长度不可变。并且被final修饰的引用一旦指向某个对象之后，不可在指向其它对象，所以String是不可变的。    StringBuffer、StringBuilder内部实际上是一个char[ ]数组，这个char[ ]数组没有被final修饰，StringBuffer和StringBulider的初始化容量应该为16，当存满之后会进行扩容，底层调用了数组拷贝的方法：System.arraycopy()…扩容的，所以StringBuffer/StringBuilder适用于字符串的频繁拼接操作，并且StringBuffer是线程安全的，StringBuilder是非线程安全的。</p>
<h2 id="String、StringBuffer-和-StringBuilder-的区别是什么"><a href="#String、StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别是什么?"></a>String、StringBuffer 和 StringBuilder 的区别是什么?</h2><p><strong>可变性：</strong>String类中使用字符数组保存字符串，<code>private final char value[]</code>，所以string对象是不可变的。<br>StringBuilder与StringBuffer都继承<strong>AbstractStringBuilder</strong>类，在AbstractStringBuilder中也是使用字符数组保存字符串，<code>char[] value</code>，所以这两种对象都是可变的。</p>
<p><strong>线程安全性：</strong> String中的对象是不可变的，也就可以理解为常量，所以线程安全；<br><strong>AbstractStringBuilder是StringBuilder与StringBuffer的公共父类</strong>，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。<br>StringBuffer对方法加了同步锁或者<strong>对调用的方法加了同步锁</strong>，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong>：每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程的不安全。<br>总结：<strong>如果数据较少的情况下：多线程和单线程都可以使用String对象；但数据较多时，单线程操作字符串缓冲区使用StringBuilder，多线程操作字符串缓冲区使用StringBuffer。</strong></p>
<h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p><strong>自动装箱</strong>就是自动将基本数据类型转化为包装器类型；<br><strong>自动拆箱</strong>就是自动将包装器类型转化为基本数据类型。</p>
<h2 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h2><p><strong>相同点：</strong></p>
<p>1、都可以定义属性和方法</p>
<p>2、都是特殊的类，都需要子类来操作具体的逻辑</p>
<p>3、都没有抽象方法</p>
<p>4、都不能创建对象</p>
<p>5、都可以利用多态操作数据</p>
<p>6、子类必须实现里面的抽象方法</p>
<p>7、java1.8以后，都可以拥有带方法体的方法</p>
<p><strong>不同点：</strong></p>
<p>1、接口<strong>可以被子类实现</strong>，但是抽象类由于java本身的特性<strong>只能单继承</strong>；</p>
<p>2、抽象类的方法，可以用protect<strong>修饰</strong>，接口只能是public </p>
<p>3、抽象类可以拥有自己的<strong>构造</strong>，接口不能拥有</p>
<p>4、接口之间可以被<strong>多继承</strong>，抽象类只能<strong>单继承</strong></p>
<p>5、java1.8以后接口可以拥有<strong>default修饰的方法体</strong>，还有<strong>stastic静态方法体</strong>，<strong>抽象类没有</strong></p>
<p><strong>总结：</strong></p>
<p>抽象类和接口<strong>两者都不能被实例化</strong>，<u>接口就是抽象类的一种特殊情况</u>。</p>
<h2 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h2><p>1.名字与类名<strong>相同</strong>。</p>
<p>2.<strong>没有返回值，但不能用 void 声明构造函数</strong>。</p>
<p>3.<strong>生成类的对象时自动执行</strong>，无需调用。</p>
<h2 id="1在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#1在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="1在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>1在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h2><p>帮助子类做初始化工作</p>
<h2 id="与-equals区别"><a href="#与-equals区别" class="headerlink" title="== 与 equals区别"></a>== 与 equals区别</h2><p>==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值； </p>
<p>equals()方法存在于 Object 类中，默认效果和==号的效果一样，也是比较的地址值，然而，Java 提供的所有类中， 绝大多数类都重写了 equals()方法，比如 string，integer 等，重写后的 equals()方法一般都是比较两个对象的值 。 </p>
<h2 id="你重写过-hashcode-和-equals-么，为什么重写-equals-时必须重写-hashCode-方法？"><a href="#你重写过-hashcode-和-equals-么，为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？"></a>你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？</h2><ol>
<li>使用hashcode方法<strong>提前校验</strong>，可以<strong>避免</strong>每一次比对都<strong>调用equals方法</strong>，提高效率</li>
<li><strong>保证是同一个对象</strong>，如果重写了equals方法，而没有重写hashcode方法，<strong>会出现equals相等的对象，hashcode不相等的情况</strong>，重写hashcode方法就是为了避免这种情况的出现。</li>
</ol>
<h2 id="线程有哪些基本状态-并描述每种状态"><a href="#线程有哪些基本状态-并描述每种状态" class="headerlink" title="线程有哪些基本状态,并描述每种状态?"></a>线程有哪些基本状态,并描述每种状态?</h2><ol>
<li>**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。</li>
<li>**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li>
<li>**阻塞(BLOCKED)**：表示线程阻塞于锁。</li>
<li>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li>
<li>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</li>
<li>**终止(TERMINATED)**：表示该线程已经执行完毕。</li>
</ol>
<h2 id="final-关键字修饰这三个地方：变量、方法、类，会有什么作用"><a href="#final-关键字修饰这三个地方：变量、方法、类，会有什么作用" class="headerlink" title="final 关键字修饰这三个地方：变量、方法、类，会有什么作用"></a>final 关键字修饰这三个地方：变量、方法、类，会有什么作用</h2><ol>
<li><strong>final修饰类</strong></li>
</ol>
<p> <strong>final类不能被继承</strong>，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，<strong>类的实现细节不允许改变</strong>，并且确信这个<strong>类不会载被扩展</strong>，那么就设计为final类。<br>2. <strong>final修饰方法</strong><br>如果一个类不允许其子类覆盖某个方法（即<strong>不允许被子类重写</strong>），则可以把这个方法声明为final方法。使用final方法的原因有二：把方法锁定，防止任何继承类修改它的意义和实现。高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。<br>3. <strong>final修饰变量(常量)</strong><br>用final修饰的成员变量表示常量，<strong>值一旦给定就无法改变</strong>！final修饰的变量有三种：<strong>静态变量、实例变量和局部变量</strong>，分别表示三种类型的常量。一旦给final变量初值后，值就不能再改变了。另外，final变量定义的时候，可以<strong>先声明，而不给初值</strong>，这种变量也称为final空白，无论什么情况，编译器都确保空白final<strong>在使用之前必须被初始化</strong>。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p>
<h2 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用<strong>transient关键字修饰</strong>。<br>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。<strong>transient只能修饰变量，不能修饰类和方法。</strong></p>
<h2 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure>

<h2 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h2><p>因为字节流转换成字符流，过程很耗时。如果你必须要使用字符流，但你只得到了字节流，就要经历这个转换，其中编码也容易出问题。所以就直接把字符流单独作为了一个部分，从而提高使用字符流的效率。</p>
<h2 id="描述深拷贝和浅拷贝"><a href="#描述深拷贝和浅拷贝" class="headerlink" title="描述深拷贝和浅拷贝"></a>描述深拷贝和浅拷贝</h2><p><strong>浅拷贝：</strong>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，<strong>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象</strong>。<br><strong>深拷贝：</strong>被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象。换言之，<strong>深拷贝把要复制的对象所引用的对象都复制了一遍</strong></p>
<h2 id="说说-amp-和-amp-amp-的区别。"><a href="#说说-amp-和-amp-amp-的区别。" class="headerlink" title="说说&amp;和&amp;&amp;的区别。"></a>说说&amp;和&amp;&amp;的区别。</h2><p> &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。<br>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式</p>
<h2 id="final-finally-finalize的区别。"><a href="#final-finally-finalize的区别。" class="headerlink" title="final, finally, finalize的区别。"></a>final, finally, finalize的区别。</h2><ol>
<li>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在new一个对象时初始化（即只能在声明变量或构造器或代码块内初始化），而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能覆盖(重写)。</li>
<li>finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收。</li>
<li>finally为区块标志，用于try语句中，表示必须运行的区块部分</li>
</ol>
<h2 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h2><p><a target="_blank" rel="noopener" href="https://imgtu.com/i/bpTeKI"><img src="https://s4.ax1x.com/2022/02/23/bpTeKI.png" alt="bpTeKI.png"></a></p>
<h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p>ArrayList每次添加元素时都会<strong>检查是否需要扩容</strong>：ArrayList一次添加元素时，赋予ArrayList默认容量10，再往里面添加元素，添加元素前先检查当前元素个数是否已经<strong>达到容量上限</strong>，若是则先以<strong>1.5倍*原容量上限</strong>进行扩容再添加元素。</p>
<h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><p><strong>1、两者父类不同</strong><br><strong>HashMap</strong>是继承自<strong>AbstractMap</strong>类，而<strong>Hashtable</strong>是继承自<strong>Dictionary</strong>类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。<br><strong>2、对外提供的接口不同</strong><br>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。<br>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。<br><strong>3、对null的支持不同</strong><br>Hashtable：<strong>key和value都不能为null</strong>。<br>HashMap：<strong>key可以为null，但是这样的key只能有一个</strong>，因为必须保证key的唯一性；可以有多个key值对应的value为null。<br><strong>4、安全性不同</strong><br><strong>HashMap是线程不安全的</strong>，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。<br><strong>Hashtable是线程安全的</strong>，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。<br>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用<strong>线程安全</strong>的<strong>ConcurrentHashMap</strong>。<br>ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。<br><strong>5、初始容量大小和每次扩充容量大小不同</strong><br><strong>6、计算hash值的方法不同</strong></p>
<h2 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h2><p><strong>List(对付顺序的好帮手)：</strong><br>List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p>
<p><strong>Set(注重独一无二的性质):</strong><br>不允许重复的集合。不会有多个元素引用相同的对象。</p>
<p><strong>Map(用Key来搜索的专家):</strong><br>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相<br>同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p>
<h2 id="什么是线程死锁-如何避免线程死锁"><a href="#什么是线程死锁-如何避免线程死锁" class="headerlink" title="什么是线程死锁?如何避免线程死锁?"></a>什么是线程死锁?如何避免线程死锁?</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p>1、尽量使用 tryLock的方法，设置超时时间，超时可以退出防止死锁。 </p>
<p>2、尽量使用 Java.util.concurrent 并发类代替自己手写锁。 </p>
<p>3、尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。 </p>
<p>4、尽量减少同步的代码块。 </p>
<h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><p><strong>互斥条件：</strong>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br><strong>不可剥夺条件：</strong>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。<br><strong>请求与保持条件：</strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br><strong>循环等待条件：</strong></p>
<h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><p><img src="https://s2.loli.net/2022/02/24/9MYkpWSV3lR5vms.png" alt="image-20220224104905303"></p>
<h2 id="现在有线程-T1、T2-和-T3。你如何确保-T2-线程在-T1-之后执行，并且-T3-线程在-T2-之后执行？"><a href="#现在有线程-T1、T2-和-T3。你如何确保-T2-线程在-T1-之后执行，并且-T3-线程在-T2-之后执行？" class="headerlink" title="现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？"></a>现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？</h2><p>可以利用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Thread%E7%B1%BB&spm=1001.2101.3001.7020">Thread类</a>的join方法。</p>
<h2 id="jdk1-8之后的新特性"><a href="#jdk1-8之后的新特性" class="headerlink" title="jdk1.8之后的新特性?"></a>jdk1.8之后的新特性?</h2><p>1：支持函数式编程 Lambda 表达式</p>
<p>2：方法引用</p>
<p>3：集合的stream处理</p>
<p>最大的变化是:jdk的内存结构发生重大变化永久代弃用，class信息使用本地内存，存储常量池移动到堆当中</p>
<h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>可以通过 class 字节码文件对象，操作类的成员(构造方法，成员变量，成员方法)，动态获取类的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。 </p>
<h2 id="反射的作用和应用场景"><a href="#反射的作用和应用场景" class="headerlink" title="反射的作用和应用场景"></a>反射的作用和应用场景</h2><p>可以通过配置文件来动态配置和加载类，以实现软件工程理论里所提及的类与类，模块与模块之间的解耦</p>
<h2 id="反射获取文件对象的三种方式"><a href="#反射获取文件对象的三种方式" class="headerlink" title="反射获取文件对象的三种方式"></a>反射获取文件对象的三种方式</h2><p>1、Class.forName(类的全限定名) </p>
<p>2、类名.class </p>
<p>3、对象.getClass()</p>
<h2 id="反射中的常用类"><a href="#反射中的常用类" class="headerlink" title="反射中的常用类"></a>反射中的常用类</h2><p>1、Class 类:反射的核心类，可以获取类的属性，方法等内容信息 </p>
<p>2、Constractor ：构造方法</p>
<p>3、Method： 成员方法</p>
<p>4、Field；</p>
<h2 id="谈一下hashMap中put是如何实现的？"><a href="#谈一下hashMap中put是如何实现的？" class="headerlink" title="谈一下hashMap中put是如何实现的？"></a>谈一下hashMap中put是如何实现的？</h2><p>1、先将key和value封装到Node节点中<br>2、底层会调用key的hashcode()方法，通过hash函数将hash值转换为数组下标，下标位置上如果没有任何元素，就把该Node添加到该位置上（该下标处）如果该下标处对应的位置上已经存在元素或链表（多于一个元素变成链表），那么就会拿着新节点的key与链表上的每一个人节点中的key进行equals。1、 如果所有对比（equals)都返回false,那么这个新节点将会被添加到链表的尾部。（大于8个就会转换成红黑树）2、 如果其中有一个对比（equals)返回true，那么这个节点上的value将会被新节点的value覆盖。</p>
<h2 id="谈一下HashMap的底层原理是什么？"><a href="#谈一下HashMap的底层原理是什么？" class="headerlink" title="谈一下HashMap的底层原理是什么？"></a>谈一下HashMap的底层原理是什么？</h2><p>hashmap底层是使用数组+链表+红黑树实现的</p>
<h2 id="谈一下hashMap中什么时候需要进行扩容，扩容resize-又是如何实现的？"><a href="#谈一下hashMap中什么时候需要进行扩容，扩容resize-又是如何实现的？" class="headerlink" title="谈一下hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？"></a>谈一下hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？</h2><p>1.初始化数组table</p>
<p>2.当数组table的size达到阙值时即++size &gt; load factor * capacity 时，也是在putVal函数中</p>
<p><strong>实现过程：(细讲)</strong></p>
<p>1.通过判断旧数组的容量是否大于0来判断数组是否初始化过</p>
<p>否：进行初始化</p>
<p>判断是否调用无参构造器，</p>
<p>是:使用默认的大小和阙值</p>
<p>否:使用构造函数中初始化的容量，当然这个容量是经过tableSizefor计算后的2的次幂数</p>
<p>是，进行扩容，扩容成两倍(小于最大值的情况下)，之后在进行将元素重新进行与运算复制到新的散列表中</p>
<p>概括的讲：扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结构，把所有的元素挨个重新hash分配到新结构中去。</p>
<h2 id="谈一下hashMap中get是如何实现的？"><a href="#谈一下hashMap中get是如何实现的？" class="headerlink" title="谈一下hashMap中get是如何实现的？"></a>谈一下hashMap中get是如何实现的？</h2><p>对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。</p>
<h2 id="为什么不直接将key作为哈希值而是与高16位做异或运算？"><a href="#为什么不直接将key作为哈希值而是与高16位做异或运算？" class="headerlink" title="为什么不直接将key作为哈希值而是与高16位做异或运算？"></a>为什么不直接将key作为哈希值而是与高16位做异或运算？</h2><p>因为数组位置的确定用的是与运算，仅仅最后四位有效，设计者将key的哈希值与高16为做异或运算使得在做&amp;运算确定数组的插入位置时，此时的低位实际是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。</p>
<h2 id="为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？"><a href="#为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？" class="headerlink" title="为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？"></a>为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？</h2><h2 id="谈一下当两个对象的hashCode相等时会怎么样？"><a href="#谈一下当两个对象的hashCode相等时会怎么样？" class="headerlink" title="谈一下当两个对象的hashCode相等时会怎么样？"></a>谈一下当两个对象的hashCode相等时会怎么样？</h2><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。这个时候要理解根据hashcode来划分的数组，如果数组的坐标相同，则进入链表这个数据结构中了，一般的添加都在最前面，也就是和数组下标直接相连的地方，链表长度到达8的时候，jdk1.8上升为红黑树</p>
<h2 id="请解释一下HashMap的参数loadFactor，它的作用是什么？"><a href="#请解释一下HashMap的参数loadFactor，它的作用是什么？" class="headerlink" title="请解释一下HashMap的参数loadFactor，它的作用是什么？"></a>请解释一下HashMap的参数loadFactor，它的作用是什么？</h2><p>负载因子表示HashMap的拥挤程度，影响hash操作到同一个数组位置的概率。默认负载因子等于0.75，可以自定义负载因子。当HashMap里面的元素已经达到数组长度的75%时，表示HashMap太挤了，需要扩容，扩容后的数组大小是原数组的2倍</p>
<h2 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>超过阙值会进行扩容操作，扩容后的数组大小是原数组的2倍，将原来的元素重新哈希放入到新的散列表中去。<br><del>传统hashMap的缺点(为什么引入红黑树？)：</del><br><del>HashMap和ConcurrentHashMap的区别</del><br><del>平时在使用HashMap时一般使用什么类型的元素作为Key？</del><br><del>volatile关键字</del></p>
<h2 id="tomcat调优"><a href="#tomcat调优" class="headerlink" title="tomcat调优"></a>tomcat调优</h2><p>1.tomcat默认的线程创建方式,是一次请求,创建一个新的线程来处理优化方案,可以配置线程池来创建和管理线程,可以设置线程数量</p>
<p>2.tomcat默认的连接处理方式是BIO,阻塞的IO,容易造成客户端堵塞优化方案：使用http11Nio协议来进行连接的处理</p>
<p>3:因为tomcat是基于jvm的,所以应该对jvm的启动参数进行调优(堆栈内存、垃圾收集器)</p>
<h2 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h2><p><strong>1、url可见性：</strong></p>
<p>get，参数url可见；</p>
<p>post，url参数不可见</p>
<p><strong>2、数据传输上：</strong></p>
<p>get，通过拼接url进行传递参数；</p>
<p>post，通过body体传输参数</p>
<p><strong>3、缓存性：</strong></p>
<p>get请求是可以缓存的</p>
<p>post请求不可以缓存</p>
<p><strong>4、后退页面的反应</strong></p>
<p>get请求页面后退时，不产生影响</p>
<p>post请求页面后退时，会重新提交请求</p>
<p><strong>5、传输数据的大小</strong></p>
<p>get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）</p>
<p>post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大。</p>
<p><strong>6、安全性</strong></p>
<p>这个也是最不好分析的，原则上post肯定要比get安全，毕竟传输参数时url不可见，但也挡不住部分人闲的没事在那抓包玩。安全性个人觉得是没多大区别的，防君子不防小人就是这个道理。对传递的参数进行加密，其实都一样。</p>
<h2 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h2><p><strong>地址栏</strong><br>转发：不变，不会显示出转向的地址<br>重定向：会显示转向之后的地址</p>
<p><strong>请求</strong><br>重定向：至少提交了两次请求</p>
<p><strong>数据</strong><br>转发：对request对象的信息不会丢失，因此可以在多个页面交互过程中实现请求数据的共享<br>重定向：request信息将丢失</p>
<p><strong>原理</strong><br>转发：是在服务器内部控制权的转移，是由服务器区请求，客户端并不知道是怎样转移的，因此客户端浏览器的地址不会显示出转向的地址。<br>重定向：是服务器告诉了客户端要转向哪个地址，客户端再自己去请求转向的地址，因此会显示转向后的地址，也可以理解浏览器至少进行了两次的访问请求。</p>
<h2 id="JSP-九大内置对象"><a href="#JSP-九大内置对象" class="headerlink" title="JSP 九大内置对象"></a>JSP 九大内置对象</h2><p>request：负责得到客户端请求的信息，对应类型：javax.servlet.http.HttpServletRequest</p>
<p>response:负责向客户端发出响应，对应类型：javax.servlet.http.HttpServletResponse</p>
<p>session:负责保存同一客户端一次会话过程中的一些信息，对应类型：javax.servlet.http.httpsession </p>
<p>out：负责管理对客户端的输出，对应类型：javax.serlvet.jsp.jspwriter</p>
<p>application:表示整个应用环境的信息，对应类型：javax.servlet.servletcontext</p>
<p>config:表示 ServletConfig，对应类型：javax.servlet.servletconfig </p>
<p>exception:表示页面中发生的异常，可以通过它获得页面异常信息，对应类型：java.lang.exception </p>
<p>pagecontext:表示这个 JSP 页面上下文，对应类型：javax.servlet.jsp.pagecontext </p>
<p>page:表示当前 JSP 页面本身。</p>
<h2 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系"></a>JSP和Servlet是什么关系</h2><p>Cookie和Session的的区别<br>JDBC访问数据库的基本步骤是什么？<br>说说preparedStatement和Statement的区别<br>数据库连接池的原理。为什么要使用连接池。</p>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p>
<h2 id="数据库事务的四个特性"><a href="#数据库事务的四个特性" class="headerlink" title="数据库事务的四个特性"></a>数据库事务的四个特性</h2><p><strong>原子性：</strong>一个事物是应用中不可再分的最小执行体，它们应该是一个整体，要么全部成功，要么全部失败。<br><strong>一致性：</strong>一个事务的执行是从一个一致性状态，变为另一个一致性状态。<br><strong>隔离性：</strong>一个执行的事务，不能被其他事务所干扰<br><strong>持久性：</strong>事务一旦提交，对数据的任何改变应该是永久性的，即使其他操作或故障都不能进行干扰。</p>
<h2 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h2><p><strong>drop：</strong>drop table 表名</p>
<p>   删除内容和定义，并释放空间。执行drop语句，将使此表的结构一起删除。</p>
<p><strong>truncate (清空表中的数据)：</strong>truncate table 表名</p>
<p>​    删除内容、释放空间但不删除定义(也就是保留表的数据结构)。与drop不同的是,只是清空表数据而已。</p>
<p>​    truncate不能删除行数据，虽然只删除数据，但是比delete彻底，它只删除表数据。</p>
<p><strong>delete：</strong>delete from 表名 （where 列名 = 值）</p>
<p>​    与truncate类似，delete也只删除内容、释放空间但不删除定义；但是delete即可以对行数据进行删除，也可以对整表数据进行删除。</p>
<h2 id="sql-怎么调优-索引命中怎么知晓？（重点）"><a href="#sql-怎么调优-索引命中怎么知晓？（重点）" class="headerlink" title="sql 怎么调优,索引命中怎么知晓？（重点）"></a>sql 怎么调优,索引命中怎么知晓？（重点）</h2><p>使用 explain 关键字查看 sql 的执行计划,可以看到该 sql 的索引命中情况、索引命中类型、命中率等相关的信息,通过这种方式可以对 sql 语句进行调优,对关键查询的条件创建索引以及注意一下 sql 语句的用法尽量不使用 like,尽量避免在某一列上进行运算不使用 in not in 使用<br>exist not exist 等等代替</p>
<h2 id="什么是-Mybatis"><a href="#什么是-Mybatis" class="headerlink" title="什么是 Mybatis"></a>什么是 Mybatis</h2><p>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高</p>
<h2 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h2><p>Mybaits 的优点： </p>
<p><strong>基于 SQL 语句编程，相当灵活</strong>，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，<strong>解除 sql 与程序代码的耦合</strong>，便于统一管理；提供 XML 标签，<strong>支持编写动态 SQL 语句</strong>，并可重用。 </p>
<p>MyBatis 框架的缺点： </p>
<p>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。</p>
<h2 id="在MyBatis中-和-的区别是什么？"><a href="#在MyBatis中-和-的区别是什么？" class="headerlink" title="在MyBatis中,#{}和${}的区别是什么？"></a>在MyBatis中,#{}和${}的区别是什么？</h2><ol>
<li>#{}是<strong>占位符</strong>预编译处理，${}是<strong>连接符</strong>字符串替换。</li>
<li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li>
<li>Mybatis在处理$ {}时，就是把${}替换成变量的值。</li>
<li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li>
</ol>
<h2 id="mybatis分页如何处理"><a href="#mybatis分页如何处理" class="headerlink" title="mybatis分页如何处理"></a>mybatis分页如何处理</h2><p>mybatis 分页查询有两种方案： </p>
<p>1、可以通过 <strong>limit 关键字拼接 sql 语句</strong>，需要两个参数，第一个参数开始条数，第二个参数查询个数； </p>
<p>2、可以通过 <strong>pageHelper 插件</strong>实现</p>
<h2 id="框架是什么东西"><a href="#框架是什么东西" class="headerlink" title="框架是什么东西"></a>框架是什么东西</h2><p>框架是一组抽象封装的设计,是一种软件半成品,程序员必须得遵守框架的api,配置配置文件和遵循代码规范,极高的提高了开发效率</p>
<h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis仅支持<strong>association关联对象</strong>和<strong>collection关联集合对象</strong>的延迟加载，association指的就是<strong>一对一</strong>，collection指的就是<strong>一对多</strong>查询。</p>
<p>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true/false</code>。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，</p>
<p>比如调用a.getB().getName()，<br>拦截器invoke()方法发现a.getB()是null值，<br>那么就会单独发送事先保存好的查询<br>关联B对象的sql，把B查询上来，然后调用a.setB(b)，<br>于是a的对象b属性就有值了，<br>接着完成a.getB().getName()方法的调用。<br>这就是延迟加载的基本原理。</p>
<h2 id="简单的说一下MyBatis-的一级缓存和二级缓存"><a href="#简单的说一下MyBatis-的一级缓存和二级缓存" class="headerlink" title="简单的说一下MyBatis 的一级缓存和二级缓存"></a>简单的说一下MyBatis 的一级缓存和二级缓存</h2><p>Mybatis 首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。</p>
<p>Mybatis 的二级缓存即查询缓存，它的<strong>作用域</strong>是一个 <strong>mapper 的 namespace</strong>，即在同一个 namespace 中查询 sql 可以从缓存中获取数据。二级缓存是可以跨 SqlSession 的。</p>
<h2 id="Mybatis中如何执行批处理？"><a href="#Mybatis中如何执行批处理？" class="headerlink" title="Mybatis中如何执行批处理？"></a>Mybatis中如何执行批处理？</h2><p>需要在全局配置文件或获取sqlSession时设置执行类型为<code>BATCH</code></p>
<h2 id="mybatis-的-mapper-代理底层怎么实现"><a href="#mybatis-的-mapper-代理底层怎么实现" class="headerlink" title="mybatis 的 mapper 代理底层怎么实现?"></a>mybatis 的 mapper 代理底层怎么实现?</h2><p> mybatis 是先通过 xml 解析,反射,最后通过动态代理机制来生成 mapper 接口的实现类对象<br>namespace 的值等于 mapper 接口的类路径、sql 标签的 id 值等于 mapper 接口的方法名,生成的<br>Mapper 代理对象的命名为接口的首字母小写。</p>
<h2 id="查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</h2><p>from、join、where、group by、having、select distinct、order by、limit…</p>
<h2 id="数据库调优（重点）"><a href="#数据库调优（重点）" class="headerlink" title="数据库调优（重点）"></a>数据库调优（重点）</h2><p>数据库结构优化设计数据库的时候,要预估单表的峰值,因为以Mysql为例,当单表的数据超过千万条,查询速度就特别缓慢了,这里就需要对数据库进行分库分表（数据分片）,为了提高查询和写入性能,mysql可以采取主从结构主数据库采用innodb引擎,从数据库采用myIsam引擎,主从之间通过监听主数据库的binlog日志来完成数据一致。</p>
<p>从服务器有两个线程，一个是IO线程，一个是sql线程，IO线程负责读取主mysql服务器的binlog日志，把读取到的日志放入到中继日志中，sql线程负责读取中继日志，并转成具体的操作，实现数据的一致性。</p>
<p>SQL优化,本质是通过创建索引,使用explain关键字,查询索引命中情况,对sql进行调优</p>
<p>使用缓存层,预先对经常常用的数据库数据进行缓存,减少数据库的压力提高数据库性能</p>
<h2 id="spring-的优点"><a href="#spring-的优点" class="headerlink" title="spring 的优点"></a>spring 的优点</h2><p>spring 属于低侵入式设计，代码的污染极低； </p>
<p>spring 的 DI 机制将对象之间的依赖关系交由框架处理，减低组件的耦合性； </p>
<p>Spring 提供了 AOP 技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。 </p>
<p>spring 对于主流的应用框架提供了集成支持。</p>
<h2 id="Spring的核心"><a href="#Spring的核心" class="headerlink" title="Spring的核心"></a>Spring的核心</h2><p>IOC、AOP</p>
<h2 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h2><p>spring支持<strong>编程式事务管理</strong>和<strong>声明式事务管理</strong>两种方式。</p>
<h2 id="Spring-AOP是什么？"><a href="#Spring-AOP是什么？" class="headerlink" title="Spring AOP是什么？"></a>Spring AOP是什么？</h2><p>即<strong>面向切面编程</strong>，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。</p>
<h2 id="Spring-AOP中有哪些不同的通知类型"><a href="#Spring-AOP中有哪些不同的通知类型" class="headerlink" title="Spring AOP中有哪些不同的通知类型?"></a>Spring AOP中有哪些不同的通知类型?</h2><p>前置通知、环绕通知、后置通知、异常通知、最终通知</p>
<h2 id="Spring-AOP的底层是怎样实现的？"><a href="#Spring-AOP的底层是怎样实现的？" class="headerlink" title="Spring AOP的底层是怎样实现的？"></a>Spring AOP的底层是怎样实现的？</h2><p>1、JDK动态代理</p>
<p>2、CGLIB代理</p>
<h2 id="Spring-AOP-默认使用jdk动态代理还是cglib？"><a href="#Spring-AOP-默认使用jdk动态代理还是cglib？" class="headerlink" title="Spring AOP 默认使用jdk动态代理还是cglib？"></a>Spring AOP 默认使用jdk动态代理还是cglib？</h2><p>jdk动态代理</p>
<h2 id="SpringAOP的应用场景"><a href="#SpringAOP的应用场景" class="headerlink" title="SpringAOP的应用场景"></a>SpringAOP的应用场景</h2><p>1、日志记录</p>
<p>2、权限验证</p>
<p>3、效率检查（个人在代码上，喜欢用注解+切面，实现校验，redis分布式锁等功能）</p>
<p>4、事务管理（spring 的事务就是用AOP实现的）</p>
<h2 id="Spring中的常用注解-最少写10个"><a href="#Spring中的常用注解-最少写10个" class="headerlink" title="Spring中的常用注解(最少写10个)"></a>Spring中的常用注解(最少写10个)</h2><h2 id="SpringMVC常用注解-最少写5个以上"><a href="#SpringMVC常用注解-最少写5个以上" class="headerlink" title="SpringMVC常用注解(最少写5个以上)"></a>SpringMVC常用注解(最少写5个以上)</h2><p>@Controller、@RequestMapping、@Params、@Autowired、@Resource</p>
<p>事务的隔离级别 </p>
<p>读未提及（READ_UNCOMMITTED）</p>
<p>读未提及，该隔离级别允许脏读取，其隔离级别是最低的。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务；而以此同时，允许另一个事务也能够访问该数据。</p>
<p>读已提交（READ_COMMITTED）</p>
<p>读已提交是不同的时候执行的时候只能获取到已经提交的数据。 </p>
<p>这样就不会出现上面的脏读的情况了。 </p>
<p>可重复读（REPEATABLE_READ）</p>
<p>可重复读就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别禁止了不可重复读取和脏读，但是有可能出现幻读的数据。</p>
<p>串行化（SERIALIZABLE）</p>
<p>顺序读是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发。 </p>
<h2 id="spring-中-bean-的作用域"><a href="#spring-中-bean-的作用域" class="headerlink" title="spring 中 bean 的作用域"></a>spring 中 bean 的作用域</h2><p>scope 配置项有 5 个属性，用于描述不同的作用域。 </p>
<ol>
<li>singleton(单例) 使用该属性定义 Bean 时，IOC 容器仅创建一个 Bean 实例，IOC 容器每次返回的是同一个 Bean 实例。 </li>
<li>prototype（多例） 使用该属性定义 Bean 时，IOC 容器可以创建多个 Bean 实例，每次返回的都是一个新的实例。</li>
<li>request 该属性仅对 HTTP 请求产生作用，使用该属性定义 Bean 时，每次 HTTP 请求都会创建一个新的 Bean，适用于WebApplicationContext 环境。 </li>
<li>session 该属性仅用于 HTTP Session，同一个 Session 共享一个 Bean 实例。不同 Session 使用不同的实例。 </li>
<li>global-session 该属性仅用于 HTTP Session，同 session 作用域不同的是，所有的 Session 共享一个 Bean 实例。</li>
</ol>
<h2 id="Spring-的-IOC-原理"><a href="#Spring-的-IOC-原理" class="headerlink" title="Spring 的 IOC 原理"></a>Spring 的 IOC 原理</h2><p>IOC 就是控制反转，原来我们需要创建对象的，必须自己 new，但是现在有了 spring 容器，我们不需要再自己 new了，有两个好处，1)解耦2)统一管理对象。 </p>
<p>SpringIOC，用户只需要进行配置，容器会在容器中自动实例化依赖对象，并且是单例模式，直接通过@autowired 直接注入即可。</p>
<h2 id="spring-事务传播特性"><a href="#spring-事务传播特性" class="headerlink" title="spring 事务传播特性"></a>spring 事务传播特性</h2><p> （1）propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中， </p>
<p>这是 Spring 默认的选择。 </p>
<p>（2）propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 </p>
<p>（3）propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</p>
<p>（4）propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 </p>
<h2 id="SpringMVC的流程？"><a href="#SpringMVC的流程？" class="headerlink" title="SpringMVC的流程？"></a>SpringMVC的流程？</h2><ol>
<li>用户发送请求到前端控制器DispatcherServlet</li>
<li>DispatcherServlet收到请求调用处理器映射器 HandlerMapping</li>
<li>HandlerMapping找到具体的处理器（通过xml 或者注解配置）最终能生成处理器对象以及处理器拦截器（如果有的情况下），一起返回给DispatcherServlet</li>
<li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li>
<li>HandlerAdapter经过适配调用具体的处理器的某个方法（Handler/Controller）</li>
<li>Controller执行完成返回ModelAndView对象</li>
<li>HandlerAdapter将Controller返回的ModelAndView再返回给DispatcherServlet</li>
<li>DispatcherServlet将ModelAndView传给ViewReslover （视图解析器）</li>
<li>ViewReslover解析后返回具体的View（视图）</li>
<li>DispatcherServlet根据View进行渲染视图(也就是将模型数据填充到视图中)</li>
<li>DispatcherServlet响应用户</li>
</ol>
<h2 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h2><p>一般情况下,控制器方法返回字符串类型的值会被当成逻辑视图名处理。如果返回的字符串中带 forward: 或 redirect: 前缀时,SpringMVC会对他们进行特殊处理:将 forward: 和redirect: 当成指示符,其后的字符串作为 URL 来处理。</p>
<h2 id="SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？</h2><p><strong>POST：</strong>在web.xml文件中配置字符编码过滤器。</p>
<p><strong>GET：</strong>修改tomcat配置文件、对request获取的参数重新进行编码</p>
<h2 id="SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解"><a href="#SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解" class="headerlink" title="SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解"></a>SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解</h2><p>@RequestBody</p>
<h2 id="Spring框架中用到了哪些设计模式"><a href="#Spring框架中用到了哪些设计模式" class="headerlink" title="Spring框架中用到了哪些设计模式"></a>Spring框架中用到了哪些设计模式</h2><ul>
<li>工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例； </li>
<li>单例模式：Bean 默认为单例模式。 </li>
<li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术；</li>
<li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 </li>
</ul>
<h2 id="什么是-Spring-Boot？-Spring-Boot特性"><a href="#什么是-Spring-Boot？-Spring-Boot特性" class="headerlink" title="什么是 Spring Boot？ Spring Boot特性"></a>什么是 Spring Boot？ Spring Boot特性</h2><p>SpringBoot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p>
<p><strong>特性</strong></p>
<ul>
<li>能够快速的创建基于Spring的应用程序</li>
<li>能够直接运行（使用main方法的方式）启动内置的tomcat运行SpringBoot 程序，不需要进行部署</li>
<li>提供约定的 starter pom 来简化maven 的配置,让maven配置更加简单</li>
<li>SpringBoot添加一个依赖 自动配置其相关联的配置</li>
<li>SpringBoot 提供健康检查机制</li>
<li>基本可以完全不使用xml配置文件，采用注解进行配置</li>
</ul>
<h2 id="Spring-Boot的四大核心"><a href="#Spring-Boot的四大核心" class="headerlink" title="Spring Boot的四大核心"></a>Spring Boot的四大核心</h2><p><strong>自动配置</strong><br>     针对于spring应用和常见的功能，SpringBoot提供了自动相关配置</p>
<p><strong>起步依赖</strong><br>    你告诉SpringBoot 你需要什么功能,它就能够引入需要的依赖库</p>
<p><strong>Actuator</strong><br>    帮助我们了解SpringBoot内部信息</p>
<p><strong>命令行界面</strong><br>     Spring Boot 可选择的特性  了解即可</p>
<h2 id="Spring-Boot的优点？"><a href="#Spring-Boot的优点？" class="headerlink" title="Spring Boot的优点？"></a>Spring Boot的优点？</h2><p><strong>独立运行</strong></p>
<p>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p>
<p><strong>简化配置</strong></p>
<p>spring-boot-starter-web启动器自动依赖其他组件，减少了maven的配置。</p>
<p><strong>自动配置</strong></p>
<p>Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。</p>
<p><strong>无代码生成和XML配置</strong></p>
<p>Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。</p>
<p><strong>应用监控</strong></p>
<p>Spring Boot提供一系列端点可以监控服务及应用，做健康检测。</p>
<h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><ol>
<li><p><code>SpringApplication.run(Application.class, args);</code> 执行流程中有 <code>refreshContext(context)</code> 这句话</p>
</li>
<li><p><code>refreshContext(context)</code>内部会对我们配置类上面的标签进行解析( <code>@SpringBootApplication</code>)<br>  实现自动装配的注解 <code>@EnableAutoConfiguration</code></p>
</li>
<li><p><code>@EnableAutoConfiguration</code> 注解里面  @Import 引入配置类 <code>AutoConfigurationImportSelector</code> </p>
</li>
<li><p><code>AutoConfigurationImportSelector</code> 中的方法  <code>getCandidateConfigurations</code> 中<br> <code>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</code></p>
</li>
<li><p><code>loadFactoryNames</code> 的作用是 读取我们jar包中的  <code>META-INF/spring.factories</code></p>
</li>
<li><p>该文件中配置了自动装配类</p>
<p><code>DruidDataSourceAutoConfigure</code></p>
</li>
</ol>
<h2 id="自定义一个starter的步骤："><a href="#自定义一个starter的步骤：" class="headerlink" title="自定义一个starter的步骤："></a>自定义一个starter的步骤：</h2><ol>
<li>创建一个模块<br>命名规则：<br>spring-boot-starter 官方的命名<br>redis-spring-boot-starter 第三方命名</li>
<li>在resources中创建 META-INF 文件夹 ，在文件夹中创建  spring.factories文件</li>
<li>spring.factories中进行如下配置<br><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.liushao.redis.boot.MyRedisAutoConfigure</code></li>
<li>添加配置类,需要按照规则创建对象</li>
<li>在内部根据条件创建redis对象 （操作redis）</li>
<li>有一个类 RedisProperties 【主机地址、端口、密码】</li>
</ol>
<h2 id="常见的HTTP相应状态码（最少写5个）"><a href="#常见的HTTP相应状态码（最少写5个）" class="headerlink" title="常见的HTTP相应状态码（最少写5个）"></a>常见的HTTP相应状态码（最少写5个）</h2><p>200 – 请求成功</p>
<p>301 – 资源(网页等)被永久转移到其它</p>
<p>URL404 – 请求的资源(网页等)不存在</p>
<p>405方法不被允许</p>
<p>500 – 内部服务器错误</p>
<h2 id="JVM运行时数据区域有哪些"><a href="#JVM运行时数据区域有哪些" class="headerlink" title="JVM运行时数据区域有哪些?"></a>JVM运行时数据区域有哪些?</h2><p>程序计数器（线程私有）</p>
<p>Java虚拟机栈（线程私有）</p>
<p>本地方法栈（线程私有）</p>
<p>Java 堆（线程共享）</p>
<p>方法区（线程共享）</p>
<p>运行时常量池</p>
<h2 id="JVM运行是数据区域哪些是私有的，哪些是共享的"><a href="#JVM运行是数据区域哪些是私有的，哪些是共享的" class="headerlink" title="JVM运行是数据区域哪些是私有的，哪些是共享的?"></a>JVM运行是数据区域哪些是私有的，哪些是共享的?</h2><p>程序计数器（线程私有）</p>
<p>Java虚拟机栈（线程私有）</p>
<p>本地方法栈（线程私有）</p>
<p>Java 堆（线程共享）</p>
<p>方法区（线程共享）</p>
<p>运行时常量池</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">陈子洋</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/02/28/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/">http://example.com/2022/02/28/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">不愿努力的帅洋</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/03/06/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"><img class="prev-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">秒杀项目</div></div></a></div><div class="next-post pull-right"><a href="/2022/02/25/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/SprinCloud%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/"><img class="next-cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringCloud——服务熔断</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/22/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/" title="Java面向对象（上）"><img class="cover" src="https://i.loli.net/2020/07/27/d6gvZ4rhtlNHcjU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-22</div><div class="title">Java面向对象（上）</div></div></a></div><div><a href="/2020/10/14/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/java/" title="Java运算符"><img class="cover" src="https://i.loli.net/2020/07/27/d6gvZ4rhtlNHcjU.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-14</div><div class="title">Java运算符</div></div></a></div><div><a href="/2022/03/10/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/Dubbo/" title="Dubbo"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-10</div><div class="title">Dubbo</div></div></a></div><div><a href="/2022/03/07/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/EurekaServerApp%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/" title="EurekaServerApp注解详解"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-07</div><div class="title">EurekaServerApp注解详解</div></div></a></div><div><a href="/2022/02/25/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/SprinCloud%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/" title="SpringCloud——服务熔断"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-25</div><div class="title">SpringCloud——服务熔断</div></div></a></div><div><a href="/2022/03/06/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/" title="秒杀项目"><img class="cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-06</div><div class="title">秒杀项目</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210310921391.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">陈子洋</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">43</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">23</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dpool110"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/dpool110" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://mail.qq.com/cgi-bin/qm_share?t=qm_mailme&amp;email=1042743887@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Share And Love! 简单的小破站，希望逛的开心😆</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93%E4%BD%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%9C%B0%E5%9D%80%E6%A0%8F%E8%BE%93%E5%85%A5%E5%B9%B6%E5%9B%9E%E8%BD%A6%E7%9A%84%E4%B8%80%E7%9E%AC%E9%97%B4%E5%88%B0%E9%A1%B5%E9%9D%A2%E8%83%BD%E5%A4%9F%E5%B1%95%E7%A4%BA%E5%9B%9E%E6%9D%A5%EF%BC%8C%E7%BB%8F%E5%8E%86%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%AB%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E7%9A%84"><span class="toc-number">2.</span> <span class="toc-text">网站是如何访问的?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8Constructor%E6%98%AF%E5%90%A6%E5%8F%AF%E8%A2%ABoverride"><span class="toc-number">3.</span> <span class="toc-text">构造器Constructor是否可被override?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.</span> <span class="toc-text">重载和重写的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84-StringBuffer%E3%80%81StringBuilder%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E5%8F%98%E7%9A%84%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">String 为什么是不可变的?StringBuffer、StringBuilder为什么是可变的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E3%80%81StringBuffer-%E5%92%8C-StringBuilder-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.</span> <span class="toc-text">String、StringBuffer 和 StringBuilder 的区别是什么?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1"><span class="toc-number">7.</span> <span class="toc-text">自动装箱与拆箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.</span> <span class="toc-text">接口和抽象类的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">构造方法有哪些特性？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%9C%A8%E8%B0%83%E7%94%A8%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E4%B9%8B%E5%89%8D%E4%BC%9A%E5%85%88%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95-%E5%85%B6%E7%9B%AE%E7%9A%84%E6%98%AF"><span class="toc-number">10.</span> <span class="toc-text">1在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E-equals%E5%8C%BA%E5%88%AB"><span class="toc-number">11.</span> <span class="toc-text">&#x3D;&#x3D; 与 equals区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%A0%E9%87%8D%E5%86%99%E8%BF%87-hashcode-%E5%92%8C-equals-%E4%B9%88%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E5%86%99-equals-%E6%97%B6%E5%BF%85%E9%A1%BB%E9%87%8D%E5%86%99-hashCode-%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81-%E5%B9%B6%E6%8F%8F%E8%BF%B0%E6%AF%8F%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">13.</span> <span class="toc-text">线程有哪些基本状态,并描述每种状态?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BF%AE%E9%A5%B0%E8%BF%99%E4%B8%89%E4%B8%AA%E5%9C%B0%E6%96%B9%EF%BC%9A%E5%8F%98%E9%87%8F%E3%80%81%E6%96%B9%E6%B3%95%E3%80%81%E7%B1%BB%EF%BC%8C%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">14.</span> <span class="toc-text">final 关键字修饰这三个地方：变量、方法、类，会有什么作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">Java 序列化中如果有些字段不想进行序列化，怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%94%A8%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">16.</span> <span class="toc-text">获取用键盘输入常用的两种方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A2%E7%84%B6%E6%9C%89%E4%BA%86%E5%AD%97%E8%8A%82%E6%B5%81-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">17.</span> <span class="toc-text">既然有了字节流,为什么还要有字符流?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%8F%E8%BF%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">18.</span> <span class="toc-text">描述深拷贝和浅拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-amp-%E5%92%8C-amp-amp-%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">19.</span> <span class="toc-text">说说&amp;和&amp;&amp;的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final-finally-finalize%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%82"><span class="toc-number">20.</span> <span class="toc-text">final, finally, finalize的区别。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text">ArrayList和Vector的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayList%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">22.</span> <span class="toc-text">ArrayList的扩容机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E5%92%8CHashtable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.</span> <span class="toc-text">HashMap和Hashtable的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4List-Set-Map%E4%B8%89%E8%80%85%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">说说List,Set,Map三者的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81"><span class="toc-number">25.</span> <span class="toc-text">什么是线程死锁?如何避免线程死锁?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">26.</span> <span class="toc-text">产生死锁的四个必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4-sleep-%E6%96%B9%E6%B3%95%E5%92%8C-wait-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%E5%92%8C%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">27.</span> <span class="toc-text">说说 sleep() 方法和 wait() 方法区别和共同点?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E5%9C%A8%E6%9C%89%E7%BA%BF%E7%A8%8B-T1%E3%80%81T2-%E5%92%8C-T3%E3%80%82%E4%BD%A0%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D-T2-%E7%BA%BF%E7%A8%8B%E5%9C%A8-T1-%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%8C%E5%B9%B6%E4%B8%94-T3-%E7%BA%BF%E7%A8%8B%E5%9C%A8-T2-%E4%B9%8B%E5%90%8E%E6%89%A7%E8%A1%8C%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jdk1-8%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">29.</span> <span class="toc-text">jdk1.8之后的新特性?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">30.</span> <span class="toc-text">反射的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">31.</span> <span class="toc-text">反射的作用和应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">32.</span> <span class="toc-text">反射获取文件对象的三种方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">33.</span> <span class="toc-text">反射中的常用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8BhashMap%E4%B8%ADput%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">34.</span> <span class="toc-text">谈一下hashMap中put是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8BHashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">谈一下HashMap的底层原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8BhashMap%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%AE%B9%EF%BC%8C%E6%89%A9%E5%AE%B9resize-%E5%8F%88%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">谈一下hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8BhashMap%E4%B8%ADget%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">37.</span> <span class="toc-text">谈一下hashMap中get是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E5%B0%86key%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E5%80%BC%E8%80%8C%E6%98%AF%E4%B8%8E%E9%AB%9816%E4%BD%8D%E5%81%9A%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%9F"><span class="toc-number">38.</span> <span class="toc-text">为什么不直接将key作为哈希值而是与高16位做异或运算？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF16%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E6%98%AF2%E7%9A%84%E5%B9%82%EF%BC%9F%E5%A6%82%E6%9E%9C%E8%BE%93%E5%85%A5%E5%80%BC%E4%B8%8D%E6%98%AF2%E7%9A%84%E5%B9%82%E6%AF%94%E5%A6%8210%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">39.</span> <span class="toc-text">为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%88%E4%B8%80%E4%B8%8B%E5%BD%93%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84hashCode%E7%9B%B8%E7%AD%89%E6%97%B6%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">40.</span> <span class="toc-text">谈一下当两个对象的hashCode相等时会怎么样？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8BHashMap%E7%9A%84%E5%8F%82%E6%95%B0loadFactor%EF%BC%8C%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">41.</span> <span class="toc-text">请解释一下HashMap的参数loadFactor，它的作用是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9CHashMap%E7%9A%84%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%87%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9B%A0%E5%AD%90-load-factor-%E5%AE%9A%E4%B9%89%E7%9A%84%E5%AE%B9%E9%87%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat%E8%B0%83%E4%BC%98"><span class="toc-number">43.</span> <span class="toc-text">tomcat调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">44.</span> <span class="toc-text">get和post请求的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91-Forward-%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91-Redirect-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">45.</span> <span class="toc-text">转发(Forward)和重定向(Redirect)的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSP-%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1"><span class="toc-number">46.</span> <span class="toc-text">JSP 九大内置对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSP%E5%92%8CServlet%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB"><span class="toc-number">47.</span> <span class="toc-text">JSP和Servlet是什么关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">48.</span> <span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7"><span class="toc-number">49.</span> <span class="toc-text">数据库事务的四个特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#drop-delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">50.</span> <span class="toc-text">drop,delete与truncate的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sql-%E6%80%8E%E4%B9%88%E8%B0%83%E4%BC%98-%E7%B4%A2%E5%BC%95%E5%91%BD%E4%B8%AD%E6%80%8E%E4%B9%88%E7%9F%A5%E6%99%93%EF%BC%9F%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">51.</span> <span class="toc-text">sql 怎么调优,索引命中怎么知晓？（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Mybatis"><span class="toc-number">52.</span> <span class="toc-text">什么是 Mybatis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">53.</span> <span class="toc-text">mybatis的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8MyBatis%E4%B8%AD-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">54.</span> <span class="toc-text">在MyBatis中,#{}和${}的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis%E5%88%86%E9%A1%B5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="toc-number">55.</span> <span class="toc-text">mybatis分页如何处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF"><span class="toc-number">56.</span> <span class="toc-text">框架是什么东西</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%94%AF%E6%8C%81%EF%BC%8C%E5%AE%83%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">57.</span> <span class="toc-text">Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E8%AF%B4%E4%B8%80%E4%B8%8BMyBatis-%E7%9A%84%E4%B8%80%E7%BA%A7%E7%BC%93%E5%AD%98%E5%92%8C%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">58.</span> <span class="toc-text">简单的说一下MyBatis 的一级缓存和二级缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mybatis%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E6%89%B9%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">59.</span> <span class="toc-text">Mybatis中如何执行批处理？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis-%E7%9A%84-mapper-%E4%BB%A3%E7%90%86%E5%BA%95%E5%B1%82%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">60.</span> <span class="toc-text">mybatis 的 mapper 代理底层怎么实现?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0%EF%BC%88where%E3%80%81jion%E3%80%81limit%E3%80%81group-by%E3%80%81having%E7%AD%89%E7%AD%89%EF%BC%89%E6%89%A7%E8%A1%8C%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F"><span class="toc-number">61.</span> <span class="toc-text">查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">62.</span> <span class="toc-text">数据库调优（重点）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">63.</span> <span class="toc-text">spring 的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">64.</span> <span class="toc-text">Spring的核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">65.</span> <span class="toc-text">Spring 管理事务的方式有几种？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">66.</span> <span class="toc-text">Spring AOP是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E4%B8%8D%E5%90%8C%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">67.</span> <span class="toc-text">Spring AOP中有哪些不同的通知类型?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%9A%84%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F"><span class="toc-number">68.</span> <span class="toc-text">Spring AOP的底层是怎样实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP-%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E8%BF%98%E6%98%AFcglib%EF%BC%9F"><span class="toc-number">69.</span> <span class="toc-text">Spring AOP 默认使用jdk动态代理还是cglib？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringAOP%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">70.</span> <span class="toc-text">SpringAOP的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-%E6%9C%80%E5%B0%91%E5%86%9910%E4%B8%AA"><span class="toc-number">71.</span> <span class="toc-text">Spring中的常用注解(最少写10个)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3-%E6%9C%80%E5%B0%91%E5%86%995%E4%B8%AA%E4%BB%A5%E4%B8%8A"><span class="toc-number">72.</span> <span class="toc-text">SpringMVC常用注解(最少写5个以上)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E4%B8%AD-bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">73.</span> <span class="toc-text">spring 中 bean 的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-%E7%9A%84-IOC-%E5%8E%9F%E7%90%86"><span class="toc-number">74.</span> <span class="toc-text">Spring 的 IOC 原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E7%89%B9%E6%80%A7"><span class="toc-number">75.</span> <span class="toc-text">spring 事务传播特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">76.</span> <span class="toc-text">SpringMVC的流程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E6%80%8E%E4%B9%88%E6%A0%B7%E8%AE%BE%E5%AE%9A%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91%E7%9A%84%EF%BC%9F"><span class="toc-number">77.</span> <span class="toc-text">SpringMVC怎么样设定重定向和转发的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3POST%E8%AF%B7%E6%B1%82%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%EF%BC%8CGET%E7%9A%84%E5%8F%88%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%91%A2%EF%BC%9F"><span class="toc-number">78.</span> <span class="toc-text">SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpingMVC%E9%9C%80%E8%A6%81%E6%8E%A5%E5%8F%97%E5%89%8D%E5%8F%B0JSON%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B6%E6%B3%A8%E5%85%A5%E5%88%B0%E5%AF%B9%E8%B1%A1%E4%B8%AD%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E6%B3%A8%E8%A7%A3"><span class="toc-number">79.</span> <span class="toc-text">SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">80.</span> <span class="toc-text">Spring框架中用到了哪些设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Spring-Boot%EF%BC%9F-Spring-Boot%E7%89%B9%E6%80%A7"><span class="toc-number">81.</span> <span class="toc-text">什么是 Spring Boot？ Spring Boot特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot%E7%9A%84%E5%9B%9B%E5%A4%A7%E6%A0%B8%E5%BF%83"><span class="toc-number">82.</span> <span class="toc-text">Spring Boot的四大核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-Boot%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">83.</span> <span class="toc-text">Spring Boot的优点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">84.</span> <span class="toc-text">SpringBoot自动装配原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAstarter%E7%9A%84%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">85.</span> <span class="toc-text">自定义一个starter的步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84HTTP%E7%9B%B8%E5%BA%94%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%88%E6%9C%80%E5%B0%91%E5%86%995%E4%B8%AA%EF%BC%89"><span class="toc-number">86.</span> <span class="toc-text">常见的HTTP相应状态码（最少写5个）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">87.</span> <span class="toc-text">JVM运行时数据区域有哪些?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%98%AF%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%9F%9F%E5%93%AA%E4%BA%9B%E6%98%AF%E7%A7%81%E6%9C%89%E7%9A%84%EF%BC%8C%E5%93%AA%E4%BA%9B%E6%98%AF%E5%85%B1%E4%BA%AB%E7%9A%84"><span class="toc-number">88.</span> <span class="toc-text">JVM运行是数据区域哪些是私有的，哪些是共享的?</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/11/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/%E6%96%87%E4%BB%B6IO/" title="文件IO"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="文件IO"/></a><div class="content"><a class="title" href="/2022/11/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/%E6%96%87%E4%BB%B6IO/" title="文件IO">文件IO</a><time datetime="2022-11-05T05:54:19.000Z" title="发表于 2022-11-05 13:54:19">2022-11-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="栈和队列"><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202211011447751.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="栈和队列"/></a><div class="content"><a class="title" href="/2022/11/02/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" title="栈和队列">栈和队列</a><time datetime="2022-11-02T03:14:11.000Z" title="发表于 2022-11-02 11:14:11">2022-11-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%9A%E7%94%A8%E9%93%BE%E8%A1%A8/" title="通用链表"><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202211011447751.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="通用链表"/></a><div class="content"><a class="title" href="/2022/11/01/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%80%9A%E7%94%A8%E9%93%BE%E8%A1%A8/" title="通用链表">通用链表</a><time datetime="2022-11-01T10:31:24.000Z" title="发表于 2022-11-01 18:31:24">2022-11-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/" title="链表"><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202211011447751.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="链表"/></a><div class="content"><a class="title" href="/2022/10/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/" title="链表">链表</a><time datetime="2022-10-28T01:41:40.000Z" title="发表于 2022-10-28 09:41:40">2022-10-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A5%87%E6%80%AA%E7%9A%84%E5%A3%B0%E6%98%8E/" title="C语言奇怪的声明"><img src="https://lifewth.com/wp-content/uploads/2018/09/58677f12f108e00800c25f52.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C语言奇怪的声明"/></a><div class="content"><a class="title" href="/2022/10/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A5%87%E6%80%AA%E7%9A%84%E5%A3%B0%E6%98%8E/" title="C语言奇怪的声明">C语言奇怪的声明</a><time datetime="2022-10-25T10:06:08.000Z" title="发表于 2022-10-25 18:06:08">2022-10-25</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> 陈子洋</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'c7c46ab7aa9095cd2c31',
      clientSecret: '0493b6a0b9982ba58186f7fa0f4b18d0d33c884f',
      repo: 'blog-comments',
      owner: 'dpool110',
      admin: ['dpool110'],
      id: '31d9d90f44357aa750cfbe0ca4fe86ea',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="false" data-text="帅洋,真帅" data-fontsize="15px" data-random="false" async="async"></script><script>window.$crisp = [];
window.CRISP_WEBSITE_ID = "9ad0e980-8d18-4a90-bb82-2377bae9b3b2";
(function () {
  d = document;
  s = d.createElement("script");
  s.src = "https://client.crisp.chat/l.js";
  s.async = 1;
  d.getElementsByTagName("head")[0].appendChild(s);
})();
$crisp.push(["safe", true])

if (true) {
  $crisp.push(["do", "chat:hide"])
  $crisp.push(["on", "chat:closed", function() {
    $crisp.push(["do", "chat:hide"])
  }])
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      $crisp.push(["do", "chat:show"])
      $crisp.push(["do", "chat:open"])

    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      $crisp.push(["do", "chat:hide"])
    }
    function chatBtnShow () {
      $crisp.push(["do", "chat:show"])
    }
  }
}</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://fastly.jsdelivr.net/gh/tzy13755126023/BLOG_SOURCE/theme_f/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><!-- hexo injector body_end end --></body></html>