<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.14.4"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.14.4/dist/index.umd.min.js"></script><script>(()=>{setTimeout(()=>{const{markmap:Fe,mm:ur}=window,Fr=new Fe.Toolbar;Fr.attach(ur);const Dr=Fr.render();Dr.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(Dr)})})()</script><script>((B,S,M,_)=>{const I=B();window.mm=I.Markmap.create("svg#mindmap",(S||I.deriveOptions)(_),M)})(()=>window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"heading","depth":1,"payload":{"lines":[0,1]},"content":"从c过渡到c++","children":[{"type":"heading","depth":2,"payload":{"lines":[1,2]},"content":"命名空间"},{"type":"heading","depth":2,"payload":{"lines":[11,12]},"content":"动态开辟","children":[{"type":"list_item","depth":3,"payload":{"lines":[12,15],"index":1},"content":"1. 开辟 new<br>\nnew int;===&gt;malloc(sizeof(int))<br>\nnew int[n] ===&gt; calloc(n, sizeof(int))"},{"type":"list_item","depth":3,"payload":{"lines":[15,18],"index":2},"content":"2. 释放 delete<br>\ndelete var;<br>\ndelete[] var;"}]},{"type":"heading","depth":2,"payload":{"lines":[19,20]},"content":"函数","children":[{"type":"list_item","depth":3,"payload":{"lines":[20,23],"index":1},"content":"1. 默认参数<br>\n函数的参数可以有默认值，要求默认参数必须在最后<br>\n声明和定义的时候不能同时出现默认参数，在声明指定"},{"type":"list_item","depth":3,"payload":{"lines":[23,27],"index":2},"content":"2. 重载<br>\n函数名字相同，参数列表不同（类型，顺序，个数等）<br>\n返回值可以相同，也可以不同<br>\n仅仅是返回值类型不同不构成重载条件"}]},{"type":"heading","depth":2,"payload":{"lines":[28,29]},"content":"引用"}]},{"type":"heading","depth":1,"payload":{"lines":[36,37]},"content":"类和对象","children":[{"type":"heading","depth":2,"payload":{"lines":[37,38]},"content":"类"},{"type":"heading","depth":2,"payload":{"lines":[43,44]},"content":"类的成员修饰关键字","children":[{"type":"list_item","depth":3,"payload":{"lines":[44,45]},"content":"public 共有的，类的外部也可以访问修改"},{"type":"list_item","depth":3,"payload":{"lines":[45,46]},"content":"private 私有的，只能在类的内部，成员函数中访问和修改"},{"type":"list_item","depth":3,"payload":{"lines":[46,47]},"content":"protected 受保护的，如果没有继承关系，同private"}]},{"type":"heading","depth":2,"payload":{"lines":[48,49]},"content":"对象的创建"},{"type":"heading","depth":2,"payload":{"lines":[52,53]},"content":"构造方法和析构方法","children":[{"type":"list_item","depth":3,"payload":{"lines":[53,54],"index":1},"content":"1. 构造方法是不需要对象主动调用的，实例化对象的时候自动调用的方法"},{"type":"list_item","depth":3,"payload":{"lines":[54,55],"index":2},"content":"2. 构造方法名字与类名一致，可以有参数，没有返回值，支持重载"},{"type":"list_item","depth":3,"payload":{"lines":[55,56],"index":3},"content":"3. 类是一定有构造方法的，如果没有显示定义，编译器会生成默认的"},{"type":"list_item","depth":3,"payload":{"lines":[56,57],"index":4},"content":"4. 析构方法名字~类名，没有参数也没有返回值，不支持重载，一个类只有一个"}]}]},{"type":"heading","depth":1,"payload":{"lines":[58,59]},"content":"继承","children":[{"type":"heading","depth":2,"payload":{"lines":[61,62]},"content":"语法"},{"type":"heading","depth":2,"payload":{"lines":[65,66]},"content":"继承方式"},{"type":"heading","depth":2,"payload":{"lines":[70,71]},"content":"构造方法"},{"type":"heading","depth":2,"payload":{"lines":[72,73]},"content":"析构方法"},{"type":"heading","depth":2,"payload":{"lines":[74,75]},"content":"成员函数的遮蔽"},{"type":"heading","depth":2,"payload":{"lines":[76,77]},"content":"static修饰的静态成员变量和成员函数"},{"type":"heading","depth":2,"payload":{"lines":[81,82]},"content":"const"},{"type":"heading","depth":2,"payload":{"lines":[84,85]},"content":"virtual","children":[{"type":"heading","depth":3,"payload":{"lines":[85,86]},"content":"虚继承"},{"type":"heading","depth":3,"payload":{"lines":[88,89]},"content":"虚函数"}]},{"type":"heading","depth":2,"payload":{"lines":[91,92]},"content":"friend","children":[{"type":"heading","depth":3,"payload":{"lines":[92,93]},"content":"友元函数"},{"type":"heading","depth":3,"payload":{"lines":[94,95]},"content":"友元类"}]}]},{"type":"heading","depth":1,"payload":{"lines":[97,98]},"content":"多态","children":[{"type":"heading","depth":2,"payload":{"lines":[98,99]},"content":"概念"},{"type":"heading","depth":2,"payload":{"lines":[101,102]},"content":"多态的必要条件","children":[{"type":"list_item","depth":3,"payload":{"lines":[102,103]},"content":"必须有继承关系"},{"type":"list_item","depth":3,"payload":{"lines":[103,104]},"content":"基类的成员函数要声明为虚函数（virtual）"},{"type":"list_item","depth":3,"payload":{"lines":[104,105]},"content":"派生类的成员函数要遮蔽基类的同名函数，函数原型要一致"}]},{"type":"heading","depth":2,"payload":{"lines":[106,107]},"content":"纯虚类和纯虚函数","children":[{"type":"list_item","depth":3,"payload":{"lines":[107,108],"index":1},"content":"1. 纯虚函数：virtual void fun() = 0; 没有实现"},{"type":"list_item","depth":3,"payload":{"lines":[108,109],"index":2},"content":"2. 纯虚类：包含纯虚函数的类称为纯虚类，纯虚类不能实例化对象，用于规范接口"}]}]},{"type":"heading","depth":1,"payload":{"lines":[110,111]},"content":"运算符的重载","children":[{"type":"heading","depth":2,"payload":{"lines":[111,112]},"content":"为什么需要重载运算符"},{"type":"heading","depth":2,"payload":{"lines":[113,114]},"content":"语法"},{"type":"heading","depth":2,"payload":{"lines":[118,119]},"content":"重载的两种形式","children":[{"type":"list_item","depth":3,"payload":{"lines":[119,120],"index":1},"content":"1. 类的成员函数：改变了对象的值 ++ -- []... 等大多数的单目运算符"},{"type":"list_item","depth":3,"payload":{"lines":[120,121],"index":2},"content":"2. 全局函数:对称的运算符，a + b ---&gt;b + a +/-/*///%/&lt;&lt; / &gt;&gt; / &gt; ....等大多数双目运算符"},{"type":"list_item","depth":3,"payload":{"lines":[121,122],"index":3},"content":"3. 全局函数如何做到访问类的私有成员，friend"}]},{"type":"heading","depth":2,"payload":{"lines":[123,124]},"content":"规则","children":[{"type":"list_item","depth":3,"payload":{"lines":[124,125],"index":1},"content":"1. 内置运算符才支持重载，自定义的不支持重载"},{"type":"list_item","depth":3,"payload":{"lines":[125,126],"index":2},"content":"2. 重载运算符，运算符的优先级，运算规则不能更改"},{"type":"list_item","depth":3,"payload":{"lines":[126,127],"index":3},"content":"3. 并不是所有的运算符都支持重载，比如::, *, sizeof, ?:, ."},{"type":"list_item","depth":3,"payload":{"lines":[127,128],"index":4},"content":"4. 个别运算符只能全局形式重载, &gt;&gt; &lt;&lt;"},{"type":"list_item","depth":3,"payload":{"lines":[128,129],"index":5},"content":"5. 个别运算符只能局部形式重载，++ -- []"},{"type":"list_item","depth":3,"payload":{"lines":[129,130],"index":6},"content":"6. 运算符的重载函数参数不能有默认值"}]},{"type":"heading","depth":2,"payload":{"lines":[131,132]},"content":"常用运算符重载规则","children":[{"type":"list_item","depth":3,"payload":{"lines":[149,150],"index":4},"content":"4. ++ -- 自增自减运算符"}]}]},{"type":"heading","depth":1,"payload":{"lines":[160,161]},"content":"作业","children":[{"type":"list_item","depth":2,"payload":{"lines":[161,163],"index":1},"content":"1. 定义一个变长整型数组类，属性：起始地址和成员个数<br>\n方法：获取对应下标的元素 构造方法，析构方法 为下标为i的元素赋值 遍历"}]}],"payload":{}},null)</script>
</body>
</html>
