<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>链表</title>
      <link href="/2022/10/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
      <url>/2022/10/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>哪個英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button" style="background-color: #FF7242;color: #fff">查看答案  </button><span class="hide-content">因為西裝褲(C裝酷)</span></span></p><p>門裏站着一個人? <span class="hide-inline"><button type="button" class="hide-button" style="">Click  </button><span class="hide-content">閃</span></span></p><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-02</p></div></div><div class='timeline-item-content'><p>这是测试页面</p></div></div></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言奇怪的声明</title>
      <link href="/2022/10/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A5%87%E6%80%AA%E7%9A%84%E5%A3%B0%E6%98%8E/"/>
      <url>/2022/10/25/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%A5%87%E6%80%AA%E7%9A%84%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>指针常量-常量指针、指针数组-数组指针、指针函数-函数指针、函数指针函数到底是些啥？</p><span id="more"></span><h1 id="C语言奇怪的声明"><a href="#C语言奇怪的声明" class="headerlink" title="C语言奇怪的声明"></a>C语言奇怪的声明</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天的C语言的知识就有意思了，我们先来看一下今天咱们学了啥：</p><p><strong>指针常量-常量指针、指针数组-数组指针、指针函数-函数指针、函数指针函数</strong></p><p>听完老师讲后知道了辨别的方法——后两个字就是它的本质，听了这句话，我的嘴角露出了轻蔑的笑容，就这？</p><img src="http://tva3.sinaimg.cn/bmiddle/ceeb653ely1g10fyg0z7wj206o06o74j.jpg" style="zoom: 67%;" ><p>直到我看见了这些题目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a) 一个整型数（An integer）</span><br><span class="line"></span><br><span class="line">b) 一个指向整型数的指针（A pointer to an integer）</span><br><span class="line"></span><br><span class="line">c) 一个指向指针的的指针，它指向的指针是指向一个整型数（A pointer to a pointer to an integer）</span><br><span class="line"></span><br><span class="line">d) 一个有10个整型数的数组（An array of 10 integers）</span><br><span class="line"></span><br><span class="line">e) 一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers to integers）</span><br><span class="line"></span><br><span class="line">f) 一个指向有10个整型数数组的指针（A pointer to an array of 10 integers）</span><br><span class="line"></span><br><span class="line">g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to a function that takes an integer as an argument and returns an integer）</span><br><span class="line"></span><br><span class="line">h) 一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回一个整型数（ An array of ten pointers to functions that take an integer argument and return an integer ）</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210251817858.png" style="zoom:50%;" /><p>我不是会了吗？？？这是个啥？？？看了几题我就知道今天的课算是白听了，不得不记录一下。</p><h2 id="指针常量-常量指针"><a href="#指针常量-常量指针" class="headerlink" title="指针常量-常量指针"></a>指针常量-常量指针</h2><p>首先回答下面的问题，如果下面的问题完全没问题可以直接跳到下一个知识点，如果回答的有些问题，不如再看看。</p><img src="http://tva3.sinaimg.cn/bmiddle/006wuNILly1h4w0q5os2aj30k00k0jti.jpg" style="zoom: 50%;" ><details>    <summary><b>常量指针与指针常量的区别？</b></summary>        1. 指针常量指针是常量，常量指针指针指向常量<br>        2. 指针常量不可以通过指针名去修改指针的指向，可以通过指针常量修改指向空间的数据；<br>        &nbsp&nbsp&nbsp&nbsp常量指针可以修改指针的指向，但是不能通过指针修改指向空间的数据；</details><details>    <summary><b>判断下面程序对错，并说明理由</b></summary>    str是一个指针常量，"apple"是在常量区中</details><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> * <span class="type">const</span> str = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line">    str = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>首先，<code>const</code>的功能是用来修饰只读的，它是C语言关键字的一员，当变量使用<code>const</code>关键字修饰时,变量名变为只读的了。我们只能访问常量，而无法对常量进行其他的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//下面都是const的用法</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">100</span>;<span class="comment">//int const a = 100;</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">200</span>;<span class="comment">//报错！ 不能通过变量名a进行修改,因为变量名a是只读的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">编译报错：</span></span><br><span class="line"><span class="comment">error: assignment of read-only variable ‘a’</span></span><br><span class="line"><span class="comment">  a = 200;//不能通过变量名a进行修改,因为变量名a是只读的</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上面的程序会报<code>error</code>，就是因为<code>a</code>变量此时是只读的状态，我们无法直接对<code>a</code>变量进行赋值的操作。</p><p>但是，我们有指针啊，很多事情都是太过直接，我们需要委婉一点，使用指针侧面入手。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//const int a = 100;</span></span><br><span class="line"><span class="type">int</span> <span class="type">const</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//a = 200;不能通过变量名a进行修改,因为变量名a是只读的</span></span><br><span class="line">*p = <span class="number">9527</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出</span></span><br><span class="line"><span class="comment">a = 100</span></span><br><span class="line"><span class="comment">a = 9527</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在编译阶段会报警告，我们可以忽略，输出结果后我们发现，使用我们使用指针确实修改了<code>a</code>变量的值。</p><p>既然可以用指针进行修改，<font style="color:red">说明<code>const</code>关键字是修饰的变量名，并不是存储空间</font>，此时<code>a</code>变量的存储空间依旧是在栈中，再用变量名<code>a</code>操作就只有只读的权限了。</p><h3 id="指针常量和常量指针"><a href="#指针常量和常量指针" class="headerlink" title="指针常量和常量指针"></a>指针常量和常量指针</h3><p>指针常量和常量指针，只看后两个字能够清楚，指针常量是常量，而常量指针是指针。这样紫说可能还不是很清楚，要看它们俩的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指针常量</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量指针</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br><span class="line"><span class="type">char</span> <span class="type">const</span> *p;</span><br></pre></td></tr></table></figure><p>观察关键字<code>const</code>所在的位置，指针常量<code>const</code>是在变量前，而常量指针<code>const</code>是在<code>*</code>前面的。</p><h4 id="指针常量的特性"><a href="#指针常量的特性" class="headerlink" title="指针常量的特性"></a>指针常量的特性</h4><p>指针常量不能通过指针名去修改指向，但是可以通过指针常量修改指向空间的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d &amp;a = %p\n&quot;</span>, a, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d &amp;b = %p\n&quot;</span>, b, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d p = %p\n&quot;</span>, *p, p);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;=========变化中=========\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改指向空间的数据</span></span><br><span class="line">    *p = <span class="number">9527</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a = %d &amp;a = %p\n&quot;</span>, a, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;b = %d &amp;b = %p\n&quot;</span>, b, &amp;b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*p = %d p = %p\n&quot;</span>, *p, p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">a = 100 &amp;a = 0x7ffd6c26cea8</span></span><br><span class="line"><span class="comment">b = 200 &amp;b = 0x7ffd6c26ceac</span></span><br><span class="line"><span class="comment">*p = 100 p = 0x7ffd6c26cea8</span></span><br><span class="line"><span class="comment">=========变化中=========</span></span><br><span class="line"><span class="comment">a = 9527 &amp;a = 0x7ffd6c26cea8</span></span><br><span class="line"><span class="comment">b = 200 &amp;b = 0x7ffd6c26ceac</span></span><br><span class="line"><span class="comment">*p = 9527 p = 0x7ffd6c26cea8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是我们把第12行代码修改为<code>p = &amp;b;</code>后，在编译阶段会报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error: assignment of read-only variable ‘p’</span><br><span class="line">  p = &amp;b;</span><br><span class="line">    ^</span><br></pre></td></tr></table></figure><p>这里我们使用<code>指针p</code>去指向<code>变量b</code>的地址，这样的操作对于指针常量是不允许的。</p><blockquote><p><strong>注意:</strong><br>   <strong>如果使用指针常量,一定要给指针常量做初始化</strong></p></blockquote><h4 id="常量指针的特性"><a href="#常量指针的特性" class="headerlink" title="常量指针的特性"></a>常量指针的特性</h4><p>常量指针可以修改指针的指向，但是不能通过指针修改指向空间的数据</p><p>常量指针和指针常量的特性就是翻过来了，代码我这里就不贴了（毕竟我懒），只需要修改上面第四行代码。</p><h2 id="指针数组-数组指针"><a href="#指针数组-数组指针" class="headerlink" title="指针数组-数组指针"></a>指针数组-数组指针</h2><p>还是老方法，我们先分辨这两个的真面目：指针数组是一个数组，而数组指针是指针。</p><p>品一下感觉少了点东西，要知道两个的真正含义我们需要把修饰它们的前两个字的含义也加上，所以：</p><p><strong>指针数组：</strong>是数组，数组中存储的是指针    <code>int *p1[5];</code></p><p><strong>数组指针：</strong>是指针，指针指向的是一个数组    <code>int *p2[5];</code></p><p>这样我们知道了指针数组和数组指针各自代表的是什么，我们来具体看看他们是什么成分</p><h3 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h3><p>指针数组就是数组，数组中的成员都是相同类型的指针</p><p>定义：<code>int *p1[5];</code></p><p>首先，对于语句<code>int*p1[5]</code>，因为<code>[]</code>的优先级要比<code>“*”</code>要高，所以 <code>p1</code> 先与<code>[]</code>结合，构成一个数组的定义，数组名为 <code>p1</code>，而<code>int*</code>修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，因此，它是一个指针数组。<a href="https://blog.csdn.net/mick_hu/article/details/100931034">^2</a></p><img src="https://img-blog.csdnimg.cn/20190917164233526.jpg"><p>我们每次写的<code>main</code>函数其中的第二个参数<code>char *argv[]</code>就是指针数组，我们也叫它命令行参数，前面的<code>int argc</code>代表指针数组中元素的个数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span><span class="comment">//命令行参数</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;<span class="comment">//循环变量</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argc = %d\n&quot;</span>, argc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;argv[%d] = %s\n&quot;</span>, i, argv[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行：./a.out</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">./a.out</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">执行：./a.out abc 123</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">./a.out</span></span><br><span class="line"><span class="comment">abc</span></span><br><span class="line"><span class="comment">123</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们可以看到每次我们使用<code>./a.out</code>允许我们的程序时，<code>./a.out</code>就存储再<code>*argv[]</code>数组中，如果在<code>./a.out</code>后面用空格隔开添加其他参数也是可以的。</p><h3 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h3><p>数组指针是一个指针，该指针指向数组，而数组指针就是用来和多维数组产生关联的。</p><p>定义：<code>int (*p2)[5];</code></p><p>对于语句<code>int(*p2)[5]</code>，<code>()</code>的优先级比<code>[]</code>高，<code>*</code>号和<code>p2</code>构成一个指针的定义，指针变量名为<code>p2</code>，而<code>int</code>修饰的是数组的内容，即数组的每个元素。也就是说，<code>p2</code>是一个指针，它指向一个包含 5 个 <code>int</code> 类型数据的数组。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。<a href="https://blog.csdn.net/mick_hu/article/details/100931034">^2</a></p><img src="https://img-blog.csdnimg.cn/20190917164330539.jpg"><p>由此可见，对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针，在64位系统下永远占8字节，至于它指向的数组占多少字节，这个不能够确定，要看具体情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">3</span>] = &#123;<span class="number">99</span>,<span class="number">88</span>,<span class="number">77</span>,<span class="number">66</span>,<span class="number">55</span>,<span class="number">44</span>,<span class="number">33</span>,<span class="number">22</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>];<span class="comment">//声明数组指针</span></span><br><span class="line"></span><br><span class="line">p = a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//printf(&quot;a[%d][%d] = %d\n&quot;, i, j, a[i][j]);</span></span><br><span class="line"><span class="comment">//printf(&quot;*(*(a+%d)+%d) = %d\n&quot;, i, j, *(*(a+i)+j));</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;*(*(p+%d)+%d) = %d\n&quot;</span>, i, j, *(*(p+i)+j));</span><br><span class="line"><span class="comment">//printf(&quot;p[%d][%d] = %d\n&quot;, i, j, p[i][j]);</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p = b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;p[%d][%d] = %d\n&quot;</span>, i, j, p[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针函数-函数指针"><a href="#指针函数-函数指针" class="headerlink" title="指针函数-函数指针"></a>指针函数-函数指针</h2><p>从后两个字判断，指针函数是函数，而函数指针是指针，我们再说清楚一点</p><p><strong>指针函数：</strong>是一个函数，这个函数的返回值是一个指针    <code>int *fun(int x,int y);</code></p><p><strong>函数指针：</strong>是一个指针，这个指针指向的是一个函数    <code>int (*fun)(int x,int y);</code></p><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>本质上是一个指针，但指向的是一个函数首地址（指针不能偏移），可以用函数指针来传递函数，常用于回调函数中</p><p><strong>定义：</strong> <code>int *fun(int x,int y);</code></p><p>其中，<code>func</code>是一个函数，<code>int *</code>作为一个整体，是 <code>func</code>函数的返回值，是一个指针的形式。</p><h4 id="指针函数返回字符串-3"><a href="#指针函数返回字符串-3" class="headerlink" title="指针函数返回字符串^3"></a>指针函数返回字符串<a href="https://blog.csdn.net/qq_45396672/article/details/119396143">^3</a></h4><p>以典型的字符串复制函数<code>strcpy</code>为例子，传入两个字符串<code>a b</code>指针做参数，拷贝<code>b</code>的内容到<code>a</code>之后返回a的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">strcpy</span><span class="params">(<span class="type">char</span>* a,<span class="type">char</span>* b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* c=a;<span class="comment">//拷贝a的地址</span></span><br><span class="line">    assert((a != <span class="literal">NULL</span>) &amp;&amp; (b != <span class="literal">NULL</span>)); <span class="comment">//判断输入正常</span></span><br><span class="line">    <span class="keyword">while</span>((*c++ = *b++)!=<span class="string">&#x27;\0&#x27;</span>); <span class="comment">//使用拷贝的地址进行自加，将b的程序赋值到a中</span></span><br><span class="line">    <span class="keyword">return</span> a;<span class="comment">//返回a的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>assert（条件语句）：断言函数，相当于一个if判断句，判断内容为真时程序正常运行，为假则报错，终止程序执行</strong></p></blockquote><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>本质上是一个函数，函数的返回值是一个指针，常用于返回数组、字符串等数据结构指针</p><p><strong>定义：</strong> <code>int (*fun)(int x,int y);</code></p><p>函数指针是需要把一个函数的地址赋值给它，有两种写法：<a href="https://blog.csdn.net/luoyayun361/article/details/80428882">^4</a></p><p><code>fun = &amp;Function；</code><br><code>fun = Function;</code></p><p>取地址运算符&amp;不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。</p><p>调用函数指针的方式也有两种：</p><p><code>x = (*fun)();</code><br><code>x = fun();</code></p><p>两种方式均可，其中第二种看上去和普通的函数调用没啥区别，如果可以的话，建议使用第一种，因为可以清楚的指明这是通过指针的方式来调用函数。当然，也要看个人习惯，如果理解其定义，随便怎么用都行啦。</p><h4 id="函数指针做回调函数"><a href="#函数指针做回调函数" class="headerlink" title="函数指针做回调函数"></a>函数指针做回调函数</h4><p><strong>回调函数就是一个通过函数指针调用的函数</strong>，我们把函数的<strong>指针（地址）</strong>作为参数传递给另一个函数，然后在该函数中使用地址来回调被传递过来的函数，这就是我们说的回调函数</p><p>下面为一个演示函数，主函数中将函数指针传入中间函数，然后中间函数调用指向的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">callback_1</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//回调函数1主体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call_1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">callback_2</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">//回调函数2主体</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;call_2\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个处理函数，传入的是函数指针</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Handle</span><span class="params">(<span class="type">int</span> (*callback)(<span class="type">void</span>))</span>  </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//回调函数</span></span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定义两个函数指针来指向函数地址</span></span><br><span class="line">    <span class="comment">//不定义也可以，因为函数名称本身就是函数入口地址</span></span><br><span class="line">    <span class="type">int</span> (*call1)(<span class="type">void</span>)=&amp;callback_1;</span><br><span class="line">    <span class="type">int</span> (*call2)(<span class="type">void</span>)=&amp;callback_2;</span><br><span class="line"></span><br><span class="line">    Handle(call1);</span><br><span class="line">    Handle(call2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改变函数指针指向</span></span><br><span class="line">    call1=&amp;callback_2;</span><br><span class="line">    Handle(call1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">call_1</span></span><br><span class="line"><span class="comment">call_2</span></span><br><span class="line"><span class="comment">call_2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h2><p>函数指针数组是一个数组，数组中的每个成员都是函数指针，可以和函数指针和指针数组一起理解</p><p>定义：<code>int (*arr[5])(int, int);</code></p><p>这里我们直接用命令行参数版本的计算器来理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dev</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">13</span>, b = <span class="number">7</span>;</span><br><span class="line"><span class="comment">//int (*p)(int , int);//函数指针</span></span><br><span class="line"><span class="type">int</span> (*arr[<span class="number">4</span>])(<span class="type">int</span>, <span class="type">int</span>);<span class="comment">//函数指针数组</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">arr[<span class="number">0</span>] = add;</span><br><span class="line">arr[<span class="number">1</span>] = sub;</span><br><span class="line">arr[<span class="number">2</span>] = mul;</span><br><span class="line">arr[<span class="number">3</span>] = dev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;arr[%d](%d, %d) = %d\n&quot;</span>, i, a, b, arr[i](a, b));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这里也就照着网上的文章稍微总结一下，留着以后复习时候可以翻一翻，不过我心里还是想着我的博客，新找到一个好看的主题，希望可以成功整好，就写到这里吧，然后，开摆！</p><img src="http://tva3.sinaimg.cn/bmiddle/006APoFYly8h58qyznx20g3046061jrq.gif"><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言内存分区</title>
      <link href="/2022/10/21/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
      <url>/2022/10/21/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>C语言会把内存空间分为5大区：栈区、堆区、全局区、常量区、代码区</p><span id="more"></span><h1 id="C语言内存分区"><a href="#C语言内存分区" class="headerlink" title="C语言内存分区"></a>C语言内存分区</h1><h2 id="C语言内存空间5大区"><a href="#C语言内存空间5大区" class="headerlink" title="C语言内存空间5大区"></a>C语言内存空间5大区</h2><p>C语言会把内存空间分为5大区：栈区、堆区、全局区、常量区、代码区</p><img src="https://img-blog.csdnimg.cn/9111cc29969141d3a3bceebe4d832f12.png"><h3 id="栈区-stack"><a href="#栈区-stack" class="headerlink" title="栈区(stack)"></a>栈区(stack)</h3><p>栈区由编译器自动分配释放，由操作系统自动管理，无须手动管理。<br>栈区上的内容只在函数范围内存在，当函数运行结束，这些内容也会自动被销毁。</p><ul><li>栈区按内存地址<font style="color:red"><strong>由高到低</strong></font>方向生长，其最大大小由编译时确定，速度快，但自由性差，最大空间不大。</li><li>栈区是<font style="color:red"><strong>先进后出</strong></font>原则，即先进去的被堵在屋里的最里面，后进去的在门口，释放的时候门口的先出去。</li></ul><p><strong>栈区存放内容</strong></p><ul><li>临时创建的<font style="color:red"><strong>局部变量</strong></font>和<font style="color:red"><strong>const定义的局部变量</strong></font>存放在栈区。</li><li><strong>函数调用和返回时</strong>，其<font style="color:red"><strong>入口参数</strong></font>和<font style="color:red"><strong>返回值</strong></font>存放在栈区。</li></ul><h3 id="堆区-heap"><a href="#堆区-heap" class="headerlink" title="堆区(heap)"></a>堆区(heap)</h3><p><strong>堆区</strong>由程序员分配内存和释放。</p><ul><li>堆区按内存地址<font style="color:red"><strong>由低到高</strong></font>方向生长，其大小由系统内存/虚拟内存上限决定，速度较慢，但自由性大，可用空间大。</li></ul><p><strong>堆区动态申请与释放内存</strong><br>用<code>malloc()</code>,<code>free()</code>等函数实现动态分布内存。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>参数<code>size_t</code>是分配的字节大小；</li><li>返回值是一个<code>void*</code>型的指针，该指针指向分配空间的首地址；<br>（<code>void *</code>型指针可以任意转换为其他类型的指针）</li></ul><p>用<code>free()</code>函数进行内存释放，否则会造成内存泄漏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> * <span class="comment">/*ptr*/</span>)</span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>参数<code>ptr</code>是开辟的内存的首地址。</li><li>无返回值；</li></ul><h3 id="全局-静态-区"><a href="#全局-静态-区" class="headerlink" title="全局(静态)区"></a>全局(静态)区</h3><p>通常是用于那些在编译期间就能确定存储大小的变量的存储区，但它用于的是在整个程序运行期间都可见的<font style="color:red"><strong>全局变量</strong></font>和<font style="color:red"><strong>静态变量</strong></font>。<br>全局区有 <code>.bss段</code> 和 <code>.data段</code>组成，<font style="color:red"><strong>可读可写</strong></font>。</p><ul><li><code>.bss段</code><br>未初始化的全局变量和未初始化的静态变量存放在.bss段。<br>初始化为0的全局变量和初始化为0的静态变量存放在.bss段。<br>.bss段不占用可执行文件空间，其内容由操作系统初始化。</li><li><code>.data段</code><br>已初始化的全局变量存放在.data段。<br>已初始化的静态变量存放在.data段。<br>.data段占用可执行文件空间，其内容有程序初始化。</li></ul><h3 id="常量区"><a href="#常量区" class="headerlink" title="常量区"></a>常量区</h3><p><font style="color:red"><strong>字符串、数字</strong></font>等常量存放在常量区。<br><code>const</code>修饰的全局变量存放在常量区。<br>程序运行期间，常量区的内容不可以被修改。</p><h3 id="代码区"><a href="#代码区" class="headerlink" title="代码区"></a>代码区</h3><p><font style="color:red"><strong>程序执行代码</strong></font>存放在代码区，其值不能修改（若修改则会出现错误）。<br><font style="color:red"><strong>字符串常量</strong>和<code>define</code><strong>定义的常量</strong></font>也有可能存放在代码区。</p><h2 id="内存分配中的堆和栈"><a href="#内存分配中的堆和栈" class="headerlink" title="内存分配中的堆和栈"></a>内存分配中的堆和栈</h2><p>在 C 语言中，内存分配方式有如下三种形式：</p><ol><li><p><strong>从静态存储区域分配：它是由编译器自动分配和释放的</strong></p><p>即内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，直到整个程序运行结束时才被释放，如全局变量与 <code>static</code> 变量。</p></li><li><p><strong>在栈上分配：它同样也是由编译器自动分配和释放的</strong></p><p>即在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元将被自动释放。需要注意的是，栈内存分配运算内置于处理器的指令集中，它的运行效率一般很高，但是分配的内存容量有限。</p></li><li><p><strong>从堆上分配：也被称为动态内存分配</strong></p><p>它是由程序员手动完成申请和释放的。即程序在运行的时候由程序员使用内存分配函数（如 malloc 函数）来申请任意多少的内存，使用完之后再由程序员自己负责使用内存释放函数（如 <code>free</code> 函数）来释放内存。也就是说，动态内存的整个生存期是由程序员自己决定的，使用非常灵活。需要注意的是，如果在堆上分配了内存空间，就必须及时释放它，否则将会导致运行的程序出现内存泄漏等错误。</p></li></ol><h3 id="内存分配中的栈与堆主要存在如下区别："><a href="#内存分配中的栈与堆主要存在如下区别：" class="headerlink" title="内存分配中的栈与堆主要存在如下区别："></a>内存分配中的栈与堆主要存在如下区别：</h3><p>分配与释放方式：栈内存是由编译器自动分配与释放的，它有两种分配方式：静态分配和动态分配。</p><ul><li><strong>静态分配</strong>是由编译器自动完成的，如局部变量的分配（即在一个函数中声明一个 int 类型的变量i时，编译器就会自动开辟一块内存以存放变量 i）。与此同时，其生存周期也只在函数的运行过程中，在运行后就释放，并不可以再次访问。</li><li><strong>动态分配</strong>由 <code>alloca</code> 函数进行分配，但是栈的动态分配与堆是不同的，它的动态分配是由编译器进行释放，无需任何手工实现。值得注意的是，虽然用 <code>alloca</code> 函数可以实现栈内存的动态分配，但 <code>alloca</code> 函数的可移植性很差，而且在没有传统堆栈的机器上很难实现。因此，不宜使用于广泛移植的程序中。当然，完全可以使用 C99 中的变长数组来替代 <code>alloca</code> 函数。</li></ul><h3 id="C-语言中各类型变量的存储位置和作用域。"><a href="#C-语言中各类型变量的存储位置和作用域。" class="headerlink" title="C 语言中各类型变量的存储位置和作用域。"></a>C 语言中各类型变量的存储位置和作用域。</h3><ol><li><strong>全局变量：</strong>从静态存储区域分配，其作用域是全局作用域，也就是整个程序的生命周期内都可以使用。与此同时，如果程序是由多个源文件构成的，那么全局变量只要在一个文件中定义，就可以在其他所有的文件中使用，但必须在其他文件中通过使用extern关键字来声明该全局变量。</li><li><strong>全局静态变量：</strong>从静态存储区域分配，其生命周期也是与整个程序同在的，从程序开始到结束一直起作用。但是与全局变量不同的是，全局静态变量作用域只在定义它的一个源文件内，其他源文件不能使用。</li><li><strong>局部变量：</strong>从栈上分配，其作用域只是在局部函数内，在定义该变量的函数内，只要出了该函数，该局部变量就不再起作用，该变量的生命周期也只是和该函数同在。</li><li><strong>局部静态变量：</strong>从静态存储区域分配，其在第一次初始化后就一直存在直到程序结束，该变量的特点是其作用域只在定义它的函数内可见，出了该函数就不可见了。</li></ol><h2 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h2><p>当查看变量时会通过三个属性进行查看 : 存储空间、作用域、生命周期</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在某个函数内部或者程序块内部定义的变量叫做局部变量。局部变量只能在该函数内部或者程序块的内部进行使用，功能函数的形式参数也属于该函数的局部变量。局部变量在函数外部是不可知的</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量是定义在函数外部的,通常会写到程序的顶部，全局变量在整个程序中生命周期都是有效的，在任意函数的内部都可以访问全局变量。</p><blockquote><p><strong>注意：</strong><br>   全局变量和局部变量可以同名，如果出现了同名的情况，那么在执行该函数时优先使用局部变量<br>   在该函数中全局变量被局部变量屏蔽掉了</p></blockquote><h3 id="全局变量和局部变量的区别"><a href="#全局变量和局部变量的区别" class="headerlink" title="全局变量和局部变量的区别"></a>全局变量和局部变量的区别</h3><ol><li>定义的区别</li></ol><p>当定义局部变量时，系统不会帮助初始化，局部变量内部存储的是垃圾值</p><p>当定义全局变量时，系统会帮助初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> -&gt; <span class="number">0</span></span><br><span class="line"><span class="type">char</span> -&gt; <span class="string">&#x27;\0&#x27;</span></span><br><span class="line">pointer -&gt; <span class="literal">NULL</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>存储空间的区别</p><ul><li><p>局部变量：保存在<strong>栈区</strong>中，只有在局部变量所在的函数被调用时</p><p>系统才会帮助分配存储单元，当局部变量所在的函数结束时,被释放</p></li><li><p>全局变量：保存在<strong>全局区</strong>中，占用的是全局区的存储空间</p><p>当程序在运行时已经被创建了，当程序结束时，被释放</p></li></ul></li></ol><details>    <summary>折叠标签</summary>    青青子衿，悠悠我心</details><hr><p><strong>原文连接：</strong></p><p><a href="https://blog.csdn.net/zw_whusgg/article/details/126288914">C语言之堆栈</a></p><p><a href="https://blog.csdn.net/m0_67761835/article/details/124416227">C语言内存分区</a></p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/10/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/19/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>目前更新3种排序算法</p><span id="more"></span><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>没想到嵌入式C语言课程进行的这么快，开始讲到排序的算法了，老朋友又来了😂。在学习Java的时候排序算法也只是讲了一下，这次嵌入式学习这点却很重要（毕竟不是包装哈哈🤓）。不过感觉进度上来，提前预习那点东西也快没用了，快没什么装逼的资本了。之后的数据结构也看的断断续续，一周多链表还没看完，为了以后能依旧展现装逼风采，立个flag🚩月底结束线性表、栈与队列！这次排序算法的总结就做为一个良好的开始吧😆</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序！话不多说直接上图</p><img src="https://img-blog.csdnimg.cn/d63f13cf05d849779527e5e8fa70eaa6.gif#pic_center"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用位运算进行数值交换</span></span><br><span class="line">    arr[i] ^= arr[j];</span><br><span class="line">    arr[j] ^= arr[i];</span><br><span class="line">   arr[i] ^= arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size - i; j++)</span><br><span class="line">            swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    bubble_sort(arr, size);</span><br><span class="line">    <span class="comment">//select_sort(arr, size);</span></span><br><span class="line"> </span><br><span class="line">    output(arr,size);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么说呢，感觉最主要的是第21、23行代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bubble_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; size - i; j++)</span><br><span class="line">            swap(arr, j, j+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在循环中拿第一个元素和后一个元素进行比较，如果后一个数大就交换（从小到大排序），依次类推，第一次外层循环结束后，我们就把最大的数放到了数组的最后一位。第一次外层循环结束后，数组的第一个位置就排好了，每次内层循环都是从数组第一位开始的，而结束是在数组<code>size-i</code>位置，所以这个和上一个的区别就是每次外层循环把最大的值放在数组末尾。</p><p>一开始会疑惑为什么<code>i</code>要从1开始，其实想想就能理解，后面的都排好第一位的数据就不用管了。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>还是一样直接上图</p><img src="https://img-blog.csdnimg.cn/2020042721570331.jpg"><p>大体思路就是第一次循环我们把数组第一个数据假设为最小的值，接着我们在内层循环中将后面的数据一一和它相比，如果发现有比它更小的数据，就把数组下标和第一个数据的下标交换，然后再对比其余的数据，直到找到最小的下标，我们再将下标和我们假设的最小下标进行比较，如果不相等就使用<code>swap</code>函数进行交换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">select_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(j = i + <span class="number">1</span>; j &lt; size; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[min] &gt; arr[j])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i != min)</span><br><span class="line">            swap(arr, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><img src="https://img-blog.csdnimg.cn/5add98a0c9624d26bab3d9a4976b5de6.gif#pic_center"><p>一开始对插入排序还是一知半解，不过看了动图一下子就清楚了。插入排序就像是扑克牌抓牌，抓到的牌插入到我们的手牌中的过程。我们可以抽象成两个数组，插入排序的过程就是选择无序数组的首位，插入到有序数组的对应位置，知道全部数据插入完成为止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j - <span class="number">1</span>] &gt; temp)</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中外层循环是已经排好的数据，每次选取未排序的第一个数据，而内层每一次循环可以看作将拿到的第一个数据插入到对应位置，而在对应位置和后面位置的数据就要往后挪一位。</p><p>不过这样写还是不太严谨，如果数组长度为空或者只有一个元素的时候，对造成数组下标越界，这在C语言中时不会检查的，我们要加入相应的判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert_sort</span><span class="params">(<span class="type">int</span> arrp[], <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span> || size == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span>(; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j - <span class="number">1</span>] &gt; temp)</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> C语言 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础(3)-指针</title>
      <link href="/2022/10/17/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(3)-%E6%8C%87%E9%92%88/"/>
      <url>/2022/10/17/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(3)-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<p>未更新完</p><span id="more"></span><h1 id="C语言基础-3-指针"><a href="#C语言基础-3-指针" class="headerlink" title="C语言基础(3)-指针"></a>C语言基础(3)-指针</h1><h2 id="指针的含义"><a href="#指针的含义" class="headerlink" title="指针的含义"></a>指针的含义</h2><blockquote><p>指针是用来干什么的？</p><p>指针就是用来存储地址的</p><ol><li>变量就是用来存储<strong>数据</strong>的</li><li>指针就是用来存储<strong>地址</strong>的</li></ol><p>数据和地址会以<strong>二进制补码</strong>形式存储在内存中，数据在内存中会有负数形式，<font style="color:red">地址没有负的，地址一般是以十六进制的形式展现</font></p></blockquote><h2 id="指针的定义"><a href="#指针的定义" class="headerlink" title="指针的定义"></a>指针的定义</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*数据类型 变量名;*/</span></span><br><span class="line"><span class="type">char</span>c;</span><br><span class="line"><span class="type">int</span>i;</span><br><span class="line"><span class="type">float</span>f;</span><br><span class="line"><span class="type">char</span>*pc;</span><br><span class="line"><span class="type">int</span>*pi;</span><br><span class="line"><span class="type">float</span>*pf;</span><br></pre></td></tr></table></figure><h3 id="通过sizeof测试指针的数据类型大小"><a href="#通过sizeof测试指针的数据类型大小" class="headerlink" title="通过sizeof测试指针的数据类型大小"></a>通过sizeof测试指针的数据类型大小</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(void *) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">void</span> *));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(char *) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">char</span> *));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(short *) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">short</span> *));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(int *) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(long *) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">long</span> *));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(float *) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">float</span> *));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sizeof(double *) = %ld\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span> *));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出:</span></span><br><span class="line"><span class="comment">sizeof(int *) = 8</span></span><br><span class="line"><span class="comment">sizeof(long *) = 8</span></span><br><span class="line"><span class="comment">sizeof(float *) = 8</span></span><br><span class="line"><span class="comment">sizeof(double *) = 8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>无论什么类型的指针，在当前机器上测试的结果都是8byte，因为当前是64bit的操作系统，所以一个地址长度占用64bit，所以想要把64bit的地址存储起来，指针也需要64bit的存储空间，所以无论何种类型的指针，测试二点结果都是8byte（32bit的系统上指针的大小是4byte）</p><h3 id="指针的命名和变量的命名一致"><a href="#指针的命名和变量的命名一致" class="headerlink" title="指针的命名和变量的命名一致"></a>指针的命名和变量的命名一致</h3>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础(2)</title>
      <link href="/2022/10/14/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(2)/"/>
      <url>/2022/10/14/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(2)/</url>
      
        <content type="html"><![CDATA[<p>I/O操作、控制语句</p><span id="more"></span><h1 id="C语言基础-2"><a href="#C语言基础-2" class="headerlink" title="C语言基础(2)"></a>C语言基础(2)</h1><h2 id="输入输出（I-O操作）"><a href="#输入输出（I-O操作）" class="headerlink" title="输入输出（I/O操作）"></a>输入输出（I/O操作）</h2><h3 id="格式化输入输出scanf-printf"><a href="#格式化输入输出scanf-printf" class="headerlink" title="格式化输入输出scanf printf"></a>格式化输入输出<code>scanf printf</code></h3><p><code>printf(&quot;%[修饰符]格式字符&quot;，输出表项)；</code>基本输出格式字符如下：</p><p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202209192135055.png" alt="标准输出格式"></p><h3 id="字符输入输出getchar-putchar"><a href="#字符输入输出getchar-putchar" class="headerlink" title="字符输入输出getchar putchar"></a>字符输入输出<code>getchar putchar</code></h3><h3 id="字符串输入输出gets-puts"><a href="#字符串输入输出gets-puts" class="headerlink" title="字符串输入输出gets puts"></a>字符串输入输出<code>gets puts</code></h3><h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><h3 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h3><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><p>for是C语言的关键字<br>for循环的执行流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span>(循环变量的赋值; 循环变量的控制; 循环变量的变化)</span><br><span class="line">&#123;</span><br><span class="line">循环的语句</span><br><span class="line">&#125;</span><br><span class="line">语句<span class="number">2</span></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202209271833579.png" alt="循环变量" style="zoom:67%;" /><p><strong>for循环的变形</strong></p><ol><li><p>死循环</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ;)；</span><br><span class="line"><span class="keyword">for</span>(表达式<span class="number">1</span>; ;表达式<span class="number">2</span>)/等价于/<span class="keyword">for</span>(表达式<span class="number">1</span>; <span class="number">1</span>; 表达式<span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li><p>在一个循环中存在多个循环变量<br>多条件需要使用逻辑运算符进行连接</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>, j &lt; <span class="number">10</span>; i &lt; <span class="number">10</span> &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--)</span><br></pre></td></tr></table></figure></li><li><p>嵌套循环<br>嵌套循环可以解决类似穷举和平面图像打印的问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><p>while是C语言的关键字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="number">1</span></span><br><span class="line"><span class="keyword">while</span>(循环条件)</span><br><span class="line"> &#123;</span><br><span class="line"> 循环的语句</span><br><span class="line"> &#125;</span><br><span class="line">语句<span class="number">2</span></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210141851771.png" style="zoom:67%;" /><h4 id="do-while"><a href="#do-while" class="headerlink" title="do_while"></a>do_while</h4><p>do是C语言的关键字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="number">1</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">循环的语句</span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件);</span><br><span class="line">语句<span class="number">2</span></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210141853459.png" style="zoom:67%;" />]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础(1)</title>
      <link href="/2022/10/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(1)/"/>
      <url>/2022/10/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/C%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80(1)/</url>
      
        <content type="html"><![CDATA[<p>C语言数据类型、常量与变量、运算符</p><span id="more"></span><h1 id="C语言基础-1"><a href="#C语言基础-1" class="headerlink" title="C语言基础(1)"></a>C语言基础(1)</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="C语言特点"><a href="#C语言特点" class="headerlink" title="C语言特点"></a>C语言特点</h3><ol><li>基础性的语言</li><li>语法简洁、紧凑、方便、灵活</li><li>运算符丰富，数据结构丰富</li><li>结构化、模块化编程</li><li>移植性号，执行效率高</li><li><strong>允许直接对硬件操作</strong> </li></ol><blockquote><p><strong>C语言学习要点：</strong></p><ul><li>概念的正确性</li><li>动手能力</li><li>阅读优秀的程序段</li><li>大量练习，面试题    </li></ul></blockquote><h3 id="C语言讲解流程"><a href="#C语言讲解流程" class="headerlink" title="C语言讲解流程"></a>C语言讲解流程</h3><ol><li>基本概念</li><li>数据类型，运算符和表达式</li><li>输入输出专题</li><li>流程控制</li><li>数组</li><li>指针</li><li>函数</li><li>构造类型</li><li>动态内存管理</li><li>调试工具和调试技巧（gdb，make）</li><li>常用库函数（提前封装好的工具函数）</li></ol><h3 id="使用平台"><a href="#使用平台" class="headerlink" title="使用平台"></a>使用平台</h3><p>64位Redhat6、编辑器vim、编译器gcc(make)</p><h2 id="gcc、vim"><a href="#gcc、vim" class="headerlink" title="gcc、vim"></a>gcc、vim</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件的包含</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span><span class="comment">//printf在stdio库当中</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span><span class="comment">//exit在stdlib库当中</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void main(void)//不传参</span></span><br><span class="line"><span class="comment">void main(int argc,char **argv)//char *argv[]</span></span><br><span class="line"><span class="comment">int main(int argc,char **argv)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*\n表示换行，也表示刷新缓冲区*/</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>C源文件处理过程</p><p>C源文件→预处理→编译→汇编→链接→可执行文件</p></blockquote><p>编译工具：gcc</p><blockquote><p><strong>编写程序思路要求</strong></p><ol><li>头文件正确的重要性</li><li>以函数位单位来进行程序编写</li></ol></blockquote><h2 id="第一个c程序"><a href="#第一个c程序" class="headerlink" title="第一个c程序"></a>第一个c程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：</p><p>​    hello world！</p></blockquote><h3 id="Linux下C程序执行过程"><a href="#Linux下C程序执行过程" class="headerlink" title="Linux下C程序执行过程"></a>Linux下C程序执行过程</h3><p>在Linux下使用<code>gcc</code>命令来对<code>.c</code>文件进行编译，如果不对编译生成的文件重命名，默认会编译生成<code>a.out</code>文件，这个时候使用<code>./</code>就可以运行编译后的文件。</p><h2 id="C语言数据类型"><a href="#C语言数据类型" class="headerlink" title="C语言数据类型"></a>C语言数据类型</h2><p>C语言包含的数据类型如下图：</p><p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202209141430471.png" alt="C语言数据类型"></p><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p><img src="https://appwk.baidu.com/naapi/doc/view?ih=485&o=png_6_0_0_135_758_637_349_892.979_1262.879&iw=883&ix=0&iy=0&aimw=883&rn=1&doc_id=c2ac4adcd15abe23482f4d35&pn=1&sign=da4d0b93d0b449ff1ea04df126bd348c&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&sys_ver=2.3.7" alt="基本数据类型"></p><p><a href="https://blog.csdn.net/gogokongyin/article/details/39758289">有符号和无符号看这里&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</a></p><h3 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h3><p>对于整型数据类型有三种形式：<strong>十进制</strong>、<strong>八进制</strong>和<strong>十六进制</strong>，从名称上我们可以看出各个进制的区别，十进制和八进制比较明显，十六进制是从0<del>9后再从A</del>F。我们需要了解<a href="https://blog.csdn.net/DJL0718/article/details/107797847?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166169233816782246489792%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166169233816782246489792&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-107797847-null-null.142%5Ev42%5Enew_blog_pos_by_title,185%5Ev2%5Econtrol&utm_term=%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2&spm=1018.2226.3001.4187">进制间的相互转换</a>。</p><p><a href="https://www.imooc.com/article/16813?block_id=tuijian_wz">反码和补码知识补充</a></p><h3 id="字符类型——ASCII表"><a href="#字符类型——ASCII表" class="headerlink" title="字符类型——ASCII表"></a>字符类型——ASCII表</h3><img src="https://img-blog.csdnimg.cn/349ecb1a3c1847f79c8c2df1d438a50f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAeTF4MjMz,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"  /><p>简单归纳：</p><p>ASCII码使用指定的7位或8位二进制数组合来表示128或256种字符。标准的或说基础的ASCII表是由7位二进制数组合而成的(剩下一位为0)，表示符号0~127。</p><p>后128位为扩展ASCII码，不同编码方式中，0<del>127表示的符号是一样的，128</del>255表示的符号不一样。比如：130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)。</p><p>0～31及127(共33个)是控制字符或通信专用字符，为控制码。</p><blockquote><p><strong>需要对于典型的ASCII码敏感</strong></p><ul><li>32为空格码。</li><li>33～126(共94个)为形象码。</li><li>48～57为0到9十个阿拉伯数字。</li><li>65～90为26个大写英文字母。</li><li>97～122为26个小写英文字母。 </li></ul></blockquote><p>原文链接：<a href="https://blog.csdn.net/ARTisboom/article/details/122694847">https://blog.csdn.net/ARTisboom/article/details/122694847</a></p><p>其中0代表NULL，我们后面会用到空洞文件，文件中一部分充斥着ASCII码为0的空字符。字符串最后有尾0做为特殊标记，其中尾0就是ASCII为0的特殊字符。</p><h3 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h3><p>bool类型在上面类型图上没有显示，false为0，true为1。</p><h4 id="float类型的特殊性"><a href="#float类型的特殊性" class="headerlink" title="float类型的特殊性"></a>float类型的特殊性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">float</span> f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(f &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(f == <span class="number">0</span>) #错误</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于由于计算机二进制表示浮点数有精度的问题，0形式的浮点数实际上不是0，而是非常接近零的小数，所以<code>float f == 0</code>是永远不会成立的。</p><p><font style="background-color:red">如果我们需要在程序中使用，可以通过float类型精确到小数点后六位的特性，通过<code>if(fabs(f - 0) &lt;= 1e-6)</code>来判断是否为0</font></p><h3 id="不同形式的0值"><a href="#不同形式的0值" class="headerlink" title="不同形式的0值"></a>不同形式的0值</h3><blockquote><p><code>0</code>    代表   数字0， 若把 数字0 赋值给 某个字符，对应ASCII码值为  0x00(也就是十进制0) </p><p><code>&#39;0&#39;</code>     代表  字符0 ，对应ASCII码值为  0x30 (也就是十进制 48)</p><p><code>&quot;0&quot;</code>    代表  一个字符串， 字符串中含有 2个字符，分别是 ‘0’ 和 ‘\0’ </p><p><code>&#39;\0&#39;</code>     代表   空字符(转义字符)【输出为空】， 对应ASCII码值为  0x00(也就是十进制 0)， 用作字符串结束符</p></blockquote><p><strong>注意：数据类型和后续代码中所使用的输入输出相匹配<font style="background-color:red">防止自相矛盾</font></strong></p><h2 id="常量与变量"><a href="#常量与变量" class="headerlink" title="常量与变量"></a>常量与变量</h2><p> 常量：在程序执行过程中值不会发生变化的量，分为整型常量、实型常量、字符常量、字符串常量、标识常量</p><ul><li>整型常量：就是整数。</li><li>实型常量：又称实数或浮点数。</li><li>字符常量：由单引号引起的单个字符或转义字符。</li></ul><img src="https://img-blog.csdnimg.cn/20200224144541933.png?x-oss-process=im%E4%BB%A5%E4%B8%8A%E5%B8%B8%E7%94%A8%E7%9A%84age/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc2NzU3,size_16,color_FFFFFF,t_70"><ul><li>字符串常量：由双引号引起的一个或多个字符组成的序列。<font style="background-color:red"><code>&quot;&quot;</code>特殊情况代表没有有效字符只有一个尾0，占一个字符</font></li><li>标识常量：#define</li></ul><h3 id="define"><a href="#define" class="headerlink" title="#define"></a><code>#define</code></h3><p><a href="https://blog.csdn.net/ZhaDeNianQu/article/details/120095018">看这里&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</a></p><p>在C语言程序中，如果有一个值我们需要反复用到，还需要根据我们的需求产生变化，还希望它能够一改全改，我们就可以使用标识常量<code>#define</code>实现。</p><p>除了可以用 #define 定义一个标识符来表示一个常量，还可以用 #define 定义函数，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE 100       <span class="comment">//定义整型变量MAX_VALUE值为100</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USER_NAME <span class="string">&quot;huge&quot;</span>    <span class="comment">//定义字符串变量USER_NAME值为&quot;huge&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.1415926        <span class="comment">//定义浮点数变量PI值为3.1415926</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义函数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) (a&gt;b)?a:b  <span class="comment">//取两个数最大值</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (a&lt;b)?a:b  <span class="comment">//取两个数最小值</span></span></span><br></pre></td></tr></table></figure><h4 id="define定义函数"><a href="#define定义函数" class="headerlink" title="define定义函数"></a>define定义函数</h4><p><strong>define定义不带参数的函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESULT (x*x-1)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Plase input num x = &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,RESULT);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>Plase input num x = 10 11<br>10<br>99</p></blockquote><p><strong>define定义带参数的函数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a,b) (a&gt;b)?a:b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b) (a&lt;b)?a:b</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> a,b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Plase input two num:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value:%lf\n&quot;</span>,(a,b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Min value:%lf\n&quot;</span>,(a,b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>Plase input two num:18 22<br>Max value:22.000000<br>Min value:22.000000</p></blockquote><h4 id="define定义函数陷阱"><a href="#define定义函数陷阱" class="headerlink" title="define定义函数陷阱"></a>define定义函数陷阱</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESULT(x)  x*x  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RESULT是：%d\n&quot;</span>,RESULT(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;RESULT是：%d\n&quot;</span>,RESULT(<span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>RESULT是：4<br>RESULT是：5</p><blockquote><p>这里在标识常量定义函数为<code>x*x</code>的情况下，我们认为正常的输出应该为：4和9。这就要在编写标识常量函数时候注意，<code>x*x</code>在程序中会转换为<code>2*1+2*1</code>，遵循算数的正常顺序。我们想要程序正常输出的话，需要标识常量<code>#define</code>在程序中的确使用，应该改为<code>(x)*(x)</code>或者使用<code>sqrt</code>函数</p></blockquote></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//#define RESULT(x) x*x</span></span><br><span class="line"><span class="comment">//#define RESULT(x) (x)*(x)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RESULT(x) pow((x),2)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = RESULT(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> b = RESULT(<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,b);</span><br><span class="line"><span class="comment">//    printf(&quot;%d\n&quot;,RESULT(2));</span></span><br><span class="line"><span class="comment">//    printf(&quot;%d\n&quot;,RESULT(2+1));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font style="background-color:red"><strong>对于宏定义，保险的做法是不仅应在参数两侧加括号，也应在整个字符串外加括号。</strong></font></p><h3 id="if注释"><a href="#if注释" class="headerlink" title="#if注释"></a>#if注释</h3><p>当想注释屏蔽掉大块代码段时，用<code>/*…*/&quot;</code>做大段注释，需要防止被注释掉的代码段中有嵌套的<code>/*…*/</code>，一旦出现<code>&quot;/**/&quot;嵌套&quot;/**/&quot;</code>的情况，有可能会导致你注释掉的代码区域并不是想要的区域范围。因此用 <code>#if 0</code> 要比使用 <code>/* */</code>要方便不少。</p><p>情况一：如有一段不想要的代码，可以直接用 “ #if 0 … #endif “ 形式来注释，效果等同于”/* */“</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"> </span><br><span class="line">    ...code...</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>情况二：选择结构的条件编译。如果常量为真（非0），就执行程序段1，否则执行程序段2。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 常量</span></span><br><span class="line"> </span><br><span class="line">    ...code <span class="number">1.</span>..</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> </span><br><span class="line">    ...code <span class="number">2.</span>..</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>情况三：嵌套情况。如果常量a为真（非0），就执行程序段1。当常量a为0且常量b为真时，执行程序段2；当常量a为0且常量b为0时，执行程序段3。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 常量a</span></span><br><span class="line"> </span><br><span class="line">　　  ...code <span class="number">1.</span>..</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> 常量b</span></span><br><span class="line"> </span><br><span class="line">　　        ...code <span class="number">2.</span>..</span><br><span class="line"> </span><br><span class="line">        <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"> </span><br><span class="line">　　        ...code <span class="number">3.</span>..</span><br><span class="line"> </span><br><span class="line">　　    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>定义：**<code>[存储类型] 数据类型 标识符 = 值</code> **</p><p>在C语言中，所有变量必须先声明后使用。<font style="background-color:red">注意数据类型要和给的值类型匹配</font></p><h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h4><p>定义中的其他和Java没什么区别，对于存储类型有很大区别。分为四种 存储类型：<strong>auto、static、register、extern</strong></p><ul><li><p><strong>auto：</strong>默认类型，自动分配空间，自动回收空间</p></li><li><p><strong>register：</strong>寄存器类型，只能定义局部变量，不能定义全局变量</p><blockquote><p>只能定义局部变量，不能定义全局变量，只能定义32位大小的数据类型，如都变了就不可以，寄存器没有地址，所以寄存器变量无法打印出地址查看或使用。</p><p>register的思想是，将register变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。编译器可以忽略此选项。</p></blockquote></li><li><p><strong>static：</strong>静态型，自动初始化为0值或空值，static的值有继承性</p></li><li><p><strong>extern：</strong>说明型，不能改变说明的值或类型</p></li></ul><h3 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h3><p><strong>局部变量</strong>定义在函数内部的变量，局部变量的作用域仅限于函数内部。局部变量是在函数调用时产生，在函数执行完毕时消失。</p><p><strong>全局变量</strong>必须定义在函数外部，且只能定义一次。在每个需要访问外部变量的函数中，必须声明相应的外部变量。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a><a href="https://blog.csdn.net/weixin_44982036/article/details/108797895">运算符</a></h2><img src="https://img-blog.csdnimg.cn/20200925153232107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4MjAzNg==,size_16,color_FFFFFF,t_70#pic_center"><p><strong>2、赋值运算符</strong><br><img src="https://img-blog.csdnimg.cn/20200925153429327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4MjAzNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>3、比较运算符</strong><br><img src="https://img-blog.csdnimg.cn/20200925153442514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4MjAzNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>4、逻辑运算符</strong><br><img src="https://img-blog.csdnimg.cn/20200925153520563.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDk4MjAzNg==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><strong>5、位运算符</strong></p><img src="https://img-blog.csdnimg.cn/20190314132200533.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhcmtfY3k=,size_16,color_FFFFFF,t_70"><p>注：左移运算符左移一位相当于乘二，其效率比乘以2的效率高。左移其右边自动补零，右移其左边补符号位</p><p><strong>5、其他运算符</strong></p><img src="https://img-blog.csdnimg.cn/20190314132459242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhcmtfY3k=,size_16,color_FFFFFF,t_70"><p>6、补充</p><ul><li>求字节数运算符：sizeof</li><li>强制类型转换运算符：（类型）</li><li>下标运算符：[ ]</li><li>函数调用运算符：( )</li></ul>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础(4)</title>
      <link href="/2022/10/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(4)/"/>
      <url>/2022/10/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(4)/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础-4"><a href="#Linux基础-4" class="headerlink" title="Linux基础(4)"></a>Linux基础(4)</h1><h2 id="文件权限管理"><a href="#文件权限管理" class="headerlink" title="文件权限管理"></a>文件权限管理</h2><h3 id="文件权限的介绍"><a href="#文件权限的介绍" class="headerlink" title="文件权限的介绍"></a>文件权限的介绍</h3><p>在Linux环境中任何的文件都是有权限的，文件的权限可以分为基本权限和特殊权限</p><h4 id="基本权限"><a href="#基本权限" class="headerlink" title="基本权限"></a>基本权限</h4><p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202209211957382.png" alt="文件信息"></p><p><code>rwx</code>—文件所属者               <code>r-x</code>—文件所属组               <code>r-x</code>—其他用户</p><table><thead><tr><th align="center">符号</th><th align="center">数字</th><th align="center">含义</th><th align="center">对于普通文件的影响</th><th align="center">对于目录文件的影响</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td align="center">4</td><td align="center">可读</td><td align="center">是否可以读取文件内容</td><td align="center">是否可以列出目录的子文件</td></tr><tr><td align="center"><code>w</code></td><td align="center">2</td><td align="center">可写</td><td align="center">是否可以修改文件内容</td><td align="center">是否可以创建或删除子文件</td></tr><tr><td align="center"><code>x</code></td><td align="center">1</td><td align="center">可执行</td><td align="center">是否可以执行文件内容</td><td align="center">是否可以访问该目录</td></tr><tr><td align="center"><code>-</code></td><td align="center">0</td><td align="center">该处无权限</td><td align="center">/</td><td align="center">/</td></tr></tbody></table><h5 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h5><p><code>sudo chmod 权限 文件名</code>        用来修改文件权限的</p><p><code>sudo chmod 664 文件名</code><br><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210102104654.png" style="zoom:67%;" /></p><p><code>sudo chown 用户名.组名 文件名</code>          用来修改属者属组<br><code>sudo chown 用户名 文件名</code>                用来修改属者<br><code>sudo chown .组名 文件名</code>                  用来修改属组</p><h4 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h4><p>文件的特殊权限分为三种<code>suid</code> <code>sgid</code> <code>sticky</code></p><p>无论是哪种特殊权限，影响的都是可执行的权限，所以会作用在x的位置</p><h5 id="suid"><a href="#suid" class="headerlink" title="suid"></a>suid</h5><p><code>sudo chmod u+s 文件名</code></p><p>如果文件本身的user 权限中有x权限，那么<code>u+s</code>之后s是小写的</p><p>如果文件本身的user 权限中没有x权限，那么<code>u+s</code>之后s是大写的</p><p>一般来说是在可执行的命令中加入<code>u+s</code></p><blockquote><p>特性：</p><p>拥有<code>suid</code>权限的命令，任何用户在执行改命令时，都会拥有这个命令的所有者的权限来执行</p><p>（简单来说就是在执行命令时，以命令所有者的权限来运行）</p></blockquote><h5 id="sgid"><a href="#sgid" class="headerlink" title="sgid"></a>sgid</h5><p><code>sudo chmod g+s 目录名</code></p><p>如果目录本身的group权限中有<code>x</code>权限，那么<code>g+s</code>之后<code>s</code>是小写的</p><p>如果目录本身的group权限中没有<code>x</code>权限，那么<code>g+s</code>之后<code>s</code>是大写的</p><p>一般来说是在目录文件中加入<code>g+s</code></p><blockquote><p>特性：</p><p>拥有<code>sgid</code>权限的目录，任何用户在该目录下创建的文件，都会继承该目录的属组（即使时超级用户也会跟着修改）</p></blockquote><h5 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h5><p><code>sudo chmod o+t 目录名</code></p><p>如果目录本身的other权限中有<code>x</code>权限，那么<code>o+t</code>之后<code>t</code>是小写的</p><p>如果目录本身的other权限中没有<code>x</code>权限，那么<code>o+t</code>之后<code>t</code>是大写的</p><p>一般来说是在目录文件中加入<code>o+t</code></p><blockquote><p>特性：</p><p>拥有sticky权限的目录，当其他用户想要删除文件时，只能删除自己创建的文件（当超级用户进入到o+t权限的目录时，可以删除所有文件）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础(3)</title>
      <link href="/2022/10/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(3)/"/>
      <url>/2022/10/10/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(3)/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础-3"><a href="#Linux基础-3" class="headerlink" title="Linux基础(3)"></a>Linux基础(3)</h1><h2 id="写程序的阶段"><a href="#写程序的阶段" class="headerlink" title="写程序的阶段"></a>写程序的阶段</h2><p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210101909532.png"></p><ol><li>只写一个.c文件,在.c文件中写一个函数(main函数),把所有功能都推到main函数中</li><li>只写一个.c文件,在.c文件中除了main函数以外还有其他的功能函数</li><li>多文件的形式写项目<br>main.c        存放的是主函数和功能函数的调用<br>func.c        存放的是功能函数的实现<br>func.h        存放的是功能函数的声明以及各种定义<br>makefile    脚本文件,存放的是一些编译规则</li><li>可以把.c文件做成库文件（静态库和动态库）</li></ol><h2 id="Linux的编辑器和编译器"><a href="#Linux的编辑器和编译器" class="headerlink" title="Linux的编辑器和编译器"></a>Linux的编辑器和编译器</h2><h3 id="编辑器-编写程序"><a href="#编辑器-编写程序" class="headerlink" title="编辑器(编写程序)"></a>编辑器(编写程序)</h3><p>在Linux环境中有很多vi vim gedit emacs，我们主要使用vim</p><p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202209212050775.png"></p><h4 id="在命令模式下的操作"><a href="#在命令模式下的操作" class="headerlink" title="在命令模式下的操作"></a>在命令模式下的操作</h4><h5 id="光标的定位"><a href="#光标的定位" class="headerlink" title="光标的定位"></a>光标的定位</h5><p><strong><code>h</code>(向左) <code>j</code>(向下) <code>k</code>(向上) <code>l</code>(向右)</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>gg</code></td><td>光标回到首行</td></tr><tr><td><code>G</code></td><td>光标回到末行</td></tr><tr><td><code>23G</code></td><td>快速定位到第23行</td></tr><tr><td><code>/关键字</code></td><td>光标定位到出现关键字的位置<br/>(n从上往下查找,N从下往上查找)</td></tr></tbody></table><h5 id="文本的编辑"><a href="#文本的编辑" class="headerlink" title="文本的编辑"></a>文本的编辑</h5><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>yy</code></td><td>复制(把光标所在行的内容进行复制)</td></tr><tr><td><code>p</code></td><td>粘贴(粘贴到光标所在行的下边)</td></tr><tr><td><code>P</code></td><td>粘贴(粘贴到光标所在行的上边)</td></tr><tr><td><code>dd</code></td><td>剪切/删除(把光标所在行的内容进行剪切)</td></tr><tr><td><code>3yy</code></td><td>复制光标所在行往下三行的内容</td></tr><tr><td><code>3dd</code></td><td>剪切光标所在行往下三行的内容</td></tr><tr><td><code>3p</code></td><td>粘贴到光标所在行的下边三次</td></tr><tr><td><code>3P</code></td><td>粘贴到光标所在行的上边三次</td></tr><tr><td><code>ygg</code></td><td>从首行到当前行进行复制</td></tr><tr><td><code>yG</code></td><td>从首行到当前行进行复制</td></tr><tr><td><code>x</code></td><td>删除光标所在位置的内容</td></tr><tr><td><code>D</code></td><td>删除光标所在位置之后的内容</td></tr><tr><td><code>u</code></td><td>undo撤销</td></tr><tr><td><code>ctrl+r</code></td><td>redo重做</td></tr><tr><td><code>r</code></td><td>替换(只替换一个字符)</td></tr></tbody></table><h5 id="切换模式"><a href="#切换模式" class="headerlink" title="切换模式"></a>切换模式</h5><p><code>iIaAoO</code>        切换到编辑模式(插入模式)<br><code>:</code>                 切换到命令行模式(底行模式)<br><code>v</code>                切换到可视模式</p><p>当我们切换到可视模式，可以在此模式下调整代码格式</p><ol><li>进入可视模式</li><li>选中要调整格式的代码</li><li>按 <code>=</code> 进行调整</li></ol><p>可视模式下我们可以输入<code>V</code>进入切换到可视行模式，<code>ctrl + v</code>切换到可视块模式</p><p>可视块模式下可以进行增删改的操作</p><p><strong>块插入</strong></p><ol><li>进入可视块模式    ctrl + v</li><li>选中要插入的位置</li><li>按 I 进入到插入模式</li><li>输入要插入的内容</li><li>按两下esc</li></ol><p><strong>块删除</strong></p><ol><li>进入可视块模式    ctrl + v</li><li>选中要删除的位置</li><li>按 d 进行删除</li></ol><p><strong>块替换</strong></p><ol><li>进入可视块模式    ctrl + v</li><li>选中要替换的位置</li><li>按 r 进行替换</li><li>录入要替换的内容</li></ol><h4 id="在编辑模式下的操作"><a href="#在编辑模式下的操作" class="headerlink" title="在编辑模式下的操作"></a>在编辑模式下的操作</h4><p>函数名的补齐   <code>ctrl + p</code></p><h4 id="在命令行模式下的操作"><a href="#在命令行模式下的操作" class="headerlink" title="在命令行模式下的操作"></a>在命令行模式下的操作</h4><h5 id="保存与退出"><a href="#保存与退出" class="headerlink" title="保存与退出"></a>保存与退出</h5><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>w</code></td><td>保存</td></tr><tr><td><code>q</code></td><td>退出</td></tr><tr><td><code>wq</code></td><td>保存并且退出</td></tr><tr><td><code>wqall</code></td><td>保存所有文件退出所有文件</td></tr><tr><td><code>wqa</code></td><td>保存所有文件退出所有文件</td></tr><tr><td><code>q!</code></td><td>强制退出</td></tr></tbody></table><h5 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h5><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>3,7 s/zack/root/</code></td><td>把第3-7行首次出现的zack替换成root</td></tr><tr><td><code>3,7 s/zack/root/g</code></td><td>把第3-7行所有出现的zack替换成root</td></tr><tr><td><code>% s/zack/root/g</code></td><td>把文件中出现的所有zack替换成root</td></tr></tbody></table><h4 id="使用vim打开多文件"><a href="#使用vim打开多文件" class="headerlink" title="使用vim打开多文件"></a>使用vim打开多文件</h4><ul><li><code>vim -p 多个文件</code><br>可以使用ctrl + alt + pgdn/pgup切换要操作的文件</li><li><code>vim -o 多个文件</code></li><li><code>vim -O 多个文件</code><br>可以使用ctrl + ww    切换要操作的文件</li></ul><h4 id="可以修改vim的配置文件"><a href="#可以修改vim的配置文件" class="headerlink" title="可以修改vim的配置文件"></a>可以修改vim的配置文件</h4><ul><li>修改 <code>/etc/vim/vimrc</code>        会影响所有用户</li><li>修改    <code>~/.vimrc</code>              会影响当前用户</li></ul><h3 id="编译器"><a href="#编译器" class="headerlink" title="编译器"></a>编译器</h3><p>gcc编译器依赖于cc编译器,都是X86环境下的编译工具<br>arm-linux-gcc(交叉编译工具链),是ARM平台的编译工具</p><blockquote><p>大端格式和小端格式的问题</p><ol><li>什么是大端格式,什么是小端格式</li><li>设计一套程序,判断当前的环境是大端格式还是小端格式</li></ol></blockquote><p>使用gcc编译程序时</p><ol><li>编译之后什么都没有提示,程序没有语法问题,会生成可执行文件</li><li>编译之后报警告,程序有点问题,但是不是致命问题,也会生成可执行文件</li><li>编译之后报错误,程序有致命问题,不会生成可执行文件</li></ol><p>默认生成可执行文件的名字叫做<code>a.out</code>，执行可执行文件<code>./a.out</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello  #指定了生成的可执行文件的名字hello</span><br><span class="line">gcc -o hello hello.c</span><br><span class="line">gcc -Wall hello.c#-Wall列出所有警告</span><br></pre></td></tr></table></figure><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="用户的分类"><a href="#用户的分类" class="headerlink" title="用户的分类"></a>用户的分类</h3><p>功能上的分类：<strong>普通用户</strong>和<strong>超级用户</strong></p><p>超级用户是在安装Linux系统时，操作系统默认创建的用户</p><p>普通用户是之后再创建的用户就是普通用户</p><p>范围上的分类：<strong>本地用户</strong>和<strong>网络用户</strong></p><p>创建在本地计算机中的用户是本地用户</p><p>创建在远端服务器上的用户是网络用户</p><h3 id="用户的创建"><a href="#用户的创建" class="headerlink" title="用户的创建"></a>用户的创建</h3><p><strong>注意 : 虽然都是Linux操作系统,但是不同的操作系统会有不同的处理</strong></p><p>当创建用户时,伴随着会出现一下操作</p><ol><li><p>当创建用户时,系统会为新创建出的用户分配一个ID号,叫做UID</p></li><li><p>系统会为新创建出的用户创建一个同名的组,会为组分配一个ID号 GID</p></li><li><p>系统默认会把新创建的用户添加到新创建的组中，该组也叫做该用户的主组</p></li><li><p>系统默认会在<code>/home/目录</code>中创建一个同名的目录,作为该用户的家目录</p></li><li><p>系统会把/etc/skel/目录中的文件当作默认的配置文件拷贝家目录中</p></li><li><p>系统会把用户的信息记录到<code>/etc/passwd</code>文件中</p></li></ol><p>  <code>root:x:0:0:root:/root:/bin/bash</code>    </p><table><thead><tr><th></th><th>意义</th></tr></thead><tbody><tr><td><code>root</code></td><td>用户名</td></tr><tr><td><code>x</code></td><td>代表的是密码(密码存放在<code>/etc/shadow</code>)</td></tr><tr><td><code>0</code></td><td>UID<br />UID : 0            超级用户<br/>UID : 1 - 499    系统用户<br/>UID : 500以上    普通用户</td></tr><tr><td><code>0</code></td><td>GID</td></tr><tr><td><code>root</code></td><td>用户的标志</td></tr><tr><td><code>/root</code></td><td>家目录的路径</td></tr><tr><td><code>/bin/bash</code></td><td>使用的是哪种命令解释器</td></tr></tbody></table><ol start="7"><li>系统会把用户的密码记录到/etc/shadow文件中<code>root:$6$WsTIl5zL$6dD0Mv:19186:0:99999:7:::</code><table><thead><tr><th></th><th>意义</th></tr></thead><tbody><tr><td><code>root</code></td><td>用户名</td></tr><tr><td><code>$6$</code></td><td>加密以后的密码</td></tr><tr><td><code>19186</code></td><td>上次更改密码的日期(从1970-1-1到现在的天数)</td></tr><tr><td><code>0</code></td><td>最短密码的期限(按天算,0代表无期限)</td></tr><tr><td><code>99999</code></td><td>最长密码的期限(按天算)</td></tr></tbody></table></li><li>系统会把用户组的信息记录到<code>/etc/group</code>文件中</li></ol><h3 id="用户管理的命令"><a href="#用户管理的命令" class="headerlink" title="用户管理的命令"></a>用户管理的命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>sudo useradd 用户名</code></td><td>创建用户</td></tr><tr><td><code>sudo passwd 用户名</code></td><td>为新用户设置密码(修改密码)</td></tr><tr><td><code>sudo su 用户名</code></td><td>切换用户</td></tr><tr><td><code>ctrl + d</code></td><td>结束当前用户登陆终端</td></tr><tr><td><code>sudo userdel 用户名</code></td><td>删除用户(只删除用户)</td></tr><tr><td><code>sudo userdel -r 用户名</code></td><td>删除用户(伴随着创建的东西都会被删除掉)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础(2)</title>
      <link href="/2022/10/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(2)/"/>
      <url>/2022/10/09/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(2)/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础-2"><a href="#Linux基础-2" class="headerlink" title="Linux基础(2)"></a>Linux基础(2)</h1><h2 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">命令提示符命令</span><br><span class="line">命令提示符命令 选项</span><br><span class="line">命令提示符命令 参数</span><br><span class="line">命令提示符命令 选项 参数 参数</span><br></pre></td></tr></table></figure><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>reboot/init 6</code></td><td>重起系统</td></tr><tr><td><code>init 0</code></td><td>关闭系统</td></tr><tr><td><code>sleep</code></td><td>睡眠</td></tr><tr><td><code>cal</code></td><td>查看日历</td></tr><tr><td><code>uname</code></td><td>查看系统信息</td></tr></tbody></table><h4 id="cd-改变目录-切换目录"><a href="#cd-改变目录-切换目录" class="headerlink" title="cd-改变目录/切换目录"></a><code>cd</code>-改变目录/切换目录</h4><p>效果和双击打开文件夹的效果一样，cd命令只作用于目录或者路径</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center"><code>cd</code></td><td align="center">直接回到家目录</td></tr><tr><td align="center"><code>cd + 目录名</code></td><td align="center">进入到该目录中</td></tr><tr><td align="center"><code>cd + 路径</code></td><td align="center">进入到该路径中</td></tr></tbody></table><h4 id="ls-查看文件名"><a href="#ls-查看文件名" class="headerlink" title="ls-查看文件名"></a><code>ls</code>-查看文件名</h4><p><strong>用来显示文件名</strong></p><ul><li><code>ls</code>：显示当前目录下文件的文件名</li><li><code>ls -l</code>：以长格式显示文件信息</li></ul><p>输出示例：<br><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202209211349975.png" alt="输出示例"></p><p><strong>显示的文件信息</strong></p><p>执行完<code>ls -l</code>命令后在终端显示的文件信息，具体可以分为8个部分，如图：<br><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202209211957382.png" alt="文件信息"></p><p><strong>1.文件的类型</strong></p><p>在Linux环境中有7种文件类型：</p><table><thead><tr><th align="center">文件信息</th><th align="center">文件类型</th></tr></thead><tbody><tr><td align="center"><code>-</code></td><td align="center">普通文件</td></tr><tr><td align="center"><code>d</code></td><td align="center">目录文件</td></tr><tr><td align="center"><code>c</code></td><td align="center">字符设备文件</td></tr><tr><td align="center"><code>b</code></td><td align="center">块设备文件</td></tr><tr><td align="center"><code>p</code></td><td align="center">管道文件</td></tr><tr><td align="center"><code>s</code></td><td align="center">网络套接字文件</td></tr><tr><td align="center"><code>l</code></td><td align="center">链接文件（符号链接文件）硬链接</td></tr></tbody></table><p><strong>2.文件的权限</strong><br>分为基本权限和特殊权限<br>文件权限又分为三个部分：文件所属者的权限、文件所属组的权限和其他用户的权限。</p><table><thead><tr><th align="center">符号</th><th align="center">数字</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center"><code>r</code></td><td align="center">4</td><td align="center">可读</td></tr><tr><td align="center"><code>w</code></td><td align="center">2</td><td align="center">可写</td></tr><tr><td align="center"><code>x</code></td><td align="center">1</td><td align="center">可执行</td></tr><tr><td align="center"><code>-</code></td><td align="center">0</td><td align="center">该处无权限</td></tr></tbody></table><p><strong>3.文件链接数</strong></p><p>在Linux环境中有两种链接方式(<strong>硬链接</strong>和<strong>符号链接</strong>)</p><p>创建链接文件有两种方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln 源文件文件名 目标文件文件名#创建硬链接文件</span><br><span class="line">ln -s 源文件文件名 目标文件文件名  #创建符号链接文件</span><br></pre></td></tr></table></figure><p><strong>硬链接和符号链接的特点</strong></p><p>——-硬链接———</p><ul><li>源文件和目标文件共用同一个inode号</li><li>当修改其中一个文件,另外的一个文件也会跟着修改</li><li>移动或者删除其中一个文件,不会对另外的一个文件影响</li></ul><p>——-符号链接———</p><ul><li>符号链接文件相当于是windows操作系统中的快捷方式</li><li>源文件和目标文件使用的inode号不同</li><li>当修改其中一个文件,另外的一个文件也会跟着修改</li><li>移动或者删除源文件,会对符号链接文件有影响</li></ul><blockquote><p><strong>总结：</strong></p><p><font style="font-size:18px">硬链接</font></p><p>创建方式 : <code>ln 源文件 目标文件</code></p><p>其实硬链接就是一个文件拥有多个文件名</p><p>源文件和硬链接文件可以在相同目录下,也可以在不同目录下</p><p><font style="background-color:red">注意:</font></p><ol><li><p><font style="font-size:12px">修改源文件或者硬链接文件,对于另外一个文件也会发生修改</font></p></li><li><p><font style="font-size:12px">移动或者删除其中一个文件,不会对另外的一个文件影响</font></p></li><li><p><font style="font-size:12px">硬链接文件不占用存储空间</font></p></li><li><p><font style="font-size:12px">不能对于目录文件创建硬链接</font></p><p><font style="font-size:12px">即使是超级用户也不能对于目录文件创建硬链接，但是系统默认会对目录创建硬链接</p></font><font style="font-size:12px">`.`就是当前目录的硬链接，`..`就是上一级目录的硬链接</font></li><li><p><font style="font-size:12px">硬链接文件不能跨系统分区</font></p></li></ol><p><font style="font-size:18px">符号链接</font></p><p>创建方式 : <code>ln -s 源文件 目标文件</code></p><p>符号链接文件类似于windows操作系统中的快捷方式</p><p>符号链接文件内存保存的是源文件的文件名或者路径</p><p><font style="background-color:red">注意:</font></p><ol><li><font style="font-size:12px">符号链接文件会占用存储空间,保存的是源文件的文件名或者路径</font></li><li><font style="font-size:12px">符号链接文件是一个独立的文件,文件inode号和源文件不同</font></li><li><font style="font-size:12px">如果移动、重命名、删除源文件，对于符号链接文件会有影响</font></li></ol></blockquote><p><strong>4.文件所属者</strong><br><strong>5.文件所属组</strong><br><strong>6.文件的字节数</strong><br>可以发现目录文件的字节数都是4096<br>目录为了可以快速访问其中的子文件和子目录，其中有一个表（索引），这个表（索引）大小为4096</p><p><strong>7.文件最后修改时间</strong><br><strong>8.文件名</strong></p><p><strong>pwd</strong>                </p><p>查看当前所在目录的绝对路径</p><h4 id="touch-创建普通文件"><a href="#touch-创建普通文件" class="headerlink" title="touch-创建普通文件"></a><code>touch</code>-创建普通文件</h4><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>touch 文件名</code></td><td align="left">创建以文件名命名的普通文件</td></tr><tr><td align="left"><code>touch 已有文件名/目录名</code></td><td align="left">会修改文件的最后修改时间</td></tr><tr><td align="left"><code>touch 文件名 文件名</code></td><td align="left">可以创建多个文件</td></tr><tr><td align="left"><code>touch &#123;1..20&#125;.c</code></td><td align="left">可以创建<code>1.c ... 20.c</code></td></tr><tr><td align="left"><code>touch 路径/文件名</code></td><td align="left">可以是绝对路径或者相对路径<br/>但是必须是一个正确的路径</td></tr></tbody></table><h4 id="mkdir-创建目录文件"><a href="#mkdir-创建目录文件" class="headerlink" title="mkdir-创建目录文件"></a><code>mkdir</code>-创建目录文件</h4><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>mkdir 目录名</code></td><td align="left">创建以目录名命名的目录文件</td></tr><tr><td align="left"><code>mkdir 目录名 目录名</code></td><td align="left">创建多个目录</td></tr><tr><td align="left"><code>mkdir dir&#123;a..z&#125;</code></td><td align="left">创建了<code>dira ... dirz</code>目录</td></tr></tbody></table><h4 id="rm-删除文件"><a href="#rm-删除文件" class="headerlink" title="rm-删除文件"></a><code>rm</code>-删除文件</h4><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>rm 文件名</code></td><td align="left">用来删除普通文件</td></tr><tr><td align="left"><code>rm -r 文件名</code></td><td align="left">用来删除目录文件</td></tr><tr><td align="left"><code>rm *.c</code></td><td align="left">删除所有以<code>.c</code>结尾的文件</td></tr><tr><td align="left"><code>rm -r dir*</code></td><td align="left">删除所有以<code>dir</code>开头的目录文件</td></tr></tbody></table><p><em><em>注意 : 谨慎使用    rm -rf /</em>     -r是递归的操作</em>*</p><table><thead><tr><th>命令</th><th></th></tr></thead><tbody><tr><td><code>cat 普通文件名</code></td><td>可以把普通文件的文件内容打印到终端中</td></tr><tr><td><code>less</code></td><td>从文件的起始位置开始显示,可以通过鼠标滚轮或键盘的上下按键进行翻阅,按<code>q</code>退出</td></tr><tr><td><code>more</code></td><td>从文件的起始位置开始显示,可以显示百分比<br/><code>s</code>向下翻阅<code>b</code>向上翻阅<code>q</code>退出</td></tr><tr><td><code>head</code></td><td>默认显示文件的前10行内容</td></tr><tr><td><code>tail</code></td><td>默认显示文件的末尾10行内容</td></tr></tbody></table><h4 id="cp-拷贝文件内容"><a href="#cp-拷贝文件内容" class="headerlink" title="cp-拷贝文件内容"></a><code>cp</code>-拷贝文件内容</h4><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>cp 源文件文件名 目标文件文件名</code></td><td align="left">把源文件拷贝成目标文件<br />如果目标文件不存在,会新创建一个新的普通文件,并且把源文件的文件内容拷贝到目标文件中<br/>如果目标文件存在,会把源文件的文件内容覆盖到目标文件中</td></tr><tr><td align="left"><code>cp -r 源目录目录名 目标目录目录名</code></td><td align="left">把源目录拷贝成目标目录<br/>如果目标目录不存在,会新创建一个新的目录文件,并且把源目录中的子文件内容拷贝到目标目录中<br/>如果目标目录存在,会把源目录拷贝到目标目录的内部</td></tr></tbody></table><h4 id="mv-移动-剪切-文件改名"><a href="#mv-移动-剪切-文件改名" class="headerlink" title="mv-移动/剪切/文件改名"></a><code>mv</code>-移动/剪切/文件改名</h4><p><code>mv 源文件名 目标文件名</code>            在剪切目录文件时不需要加 -r 的操作</p><h4 id="tar-打压缩包-解压缩包"><a href="#tar-打压缩包-解压缩包" class="headerlink" title="tar-打压缩包/解压缩包"></a><code>tar</code>-打压缩包/解压缩包</h4><table><thead><tr><th align="left">命令</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left"><code>tar cvf 最终生成tar包的名字 打压缩的文件</code></td><td align="left">打压缩包</td></tr><tr><td align="left"><code>tar xvf tar包的名字</code></td><td align="left">默认解压到当前目录</td></tr><tr><td align="left"><code>tar xvf tar包的名字 -C 目录</code></td><td align="left">指定解压的目录</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础(1)</title>
      <link href="/2022/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(1)/"/>
      <url>/2022/10/08/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E5%9F%BA%E7%A1%80(1)/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础-1"><a href="#Linux基础-1" class="headerlink" title="Linux基础(1)"></a>Linux基础(1)</h1><h2 id="VMware和centOS安装"><a href="#VMware和centOS安装" class="headerlink" title="VMware和centOS安装"></a>VMware和centOS安装</h2><p>VMware的安装没有什么需要注意的到网上随便搜个教程即可</p><p>关于centOS的安装，之前安装过许多次，但是看了韩顺平老师的课程后，才发现有许多需要注意的问题，下面列出一些比较重要的问题。<a href="https://www.bilibili.com/video/BV1Sv411r7vd?p=5&spm_id_from=pageDriver&vd_source=5b4d08529df3a64bc1463e2ab87b4577">教程点这里&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</a></p><h3 id="centOS安装注意事项"><a href="#centOS安装注意事项" class="headerlink" title="centOS安装注意事项"></a>centOS安装注意事项</h3><h4 id="网络适配器的选择"><a href="#网络适配器的选择" class="headerlink" title="网络适配器的选择"></a>网络适配器的选择</h4><p>对于网络连接的设置我们选择默认的<strong>NAT模式</strong>即可，而对于另外两种<strong>桥接模式</strong>和<strong>主机模式</strong>这三种网络连接方式的特点如下：</p><ul><li><strong>桥接模式：</strong>虚拟的Linux系统可以和外部系统通信，使用的是类似<code>192.168.0.xxx</code>的同一网段，因为每一位的最大值只有255(可能没有255个其中<code>.1</code>是做网关和<code>.55</code>是做广播地址)，当连接过多时<strong>容易造成IP冲突</strong>。</li><li><strong>NAT模式：</strong>又叫网络地址转换模式，NAT模式使用的是代理方式和外部系统通信，在NAT模式下配置Linux虚拟系统的IP地址后，主机上对应也会生成一个虚拟网卡，虚拟网卡和Linux虚拟系统间会生成一个独立的可以相互通信的网络。而Linux虚拟系统会通过主机IP代理找到外部系统进行通信，这样Linux虚拟系统不仅可以和外部系统进行通信，同时不占用外部系统的IP，这样就<strong>不会产生IP的冲突</strong>。但是外部系统不能直接和Linux虚拟系统进行通信。</li><li><strong>主机模式：</strong>独立的系统，不和外界发生联系。</li></ul><p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210092006761.png"></p><blockquote><p><strong>总结：</strong></p><ol><li>桥接模式，虚拟机可以和外部系统直接通信，但是容易造成IP冲突。</li><li>NAT模式，网络地址转换模式，虚拟系统可以和外部系统通讯，不会造成IP冲突。</li><li>主机模式，独立的系统，不和外界发生联系。</li></ol></blockquote><h4 id="软件的选择"><a href="#软件的选择" class="headerlink" title="软件的选择"></a>软件的选择</h4><p>在之前的安装过程中一直选择的是最小安装，这就需要我们手动安装最小安装中没有的gcc、JDK、MySQL等基本的开发环境。选择GNOME桌面，并勾选上途中附加选项即可。</p><p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210092007395.png"></p><h4 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h4><p><font style="background-color:red">磁盘分区一定要手动进行分区</font></p><p>网上大部分的安装教程，对于磁盘的分区都差不多，都是分为<code>/boot</code>引导分区，<code>swap</code>交换分区和<code>/</code>根分区。</p><p>其中<code>swap</code>分区到底有什么作用呢？程序运行时，我们需要将程序加载到内存中，但是内存的容量是有限的，当我们的内存被占满时其他的程序就进入不了内存。这个时候就产生了交换分区的方案就是我们的<code>swap</code>分区，它可以在内存被占满时临时地充当内存，是对内存机制地补充。所以在内存被占满的场景下，后来的程序会先加载到swap分区中，当实际内存中有空间会将此程序加载进来。但是swap分区的速度要慢于实际内存的读写速度。</p><blockquote><p><strong>总结：</strong></p><p>swap分区可以理解为是操作系统提供的一种内存不足的解决机制，可以理解为windows中的虚拟内存。</p><p><a href="http://c.biancheng.net/view/907.html">具体看这里&gt;&gt;&gt;&gt;</a></p></blockquote><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h4><p>当进行手动分区时，<code>/boot</code>和<code>/</code>在centOS 7的文件系统中，默认选择的都是xfs-64位高性能日志文件系统，在centOS 6中默认使用的是ext4-第四代文件扩展系统。但是在韩顺平老师的视频中在安装centOS 7的情况下，依然选择了ext4文件系统。</p><blockquote><p><strong>知识补充</strong></p><img src="https://raw.githubusercontent.com/dpool110/picgo/master/202210091923780.png" style="zoom:50%;" /><p>应用程序——–用户应用的程序(微信 游戏)<br>库文件———–静态库和动态库<br>根文件系统—–可以把硬盘中二进制的数据转变为不同类型的文件<br>Kernel———–启动内核<br>GRUB———–引导内核 在linux操作系统中，在boot目录下<br>BIOS————-检测硬件    (在ARM架构中 BIOS + GRUB = bootloader –作用–&gt;检测硬件+引导内核)</p></blockquote><h2 id="Linux操作系统的认知"><a href="#Linux操作系统的认知" class="headerlink" title="Linux操作系统的认知"></a>Linux操作系统的认知</h2><p><strong>在 Windows 下</strong>，打开 “我的电脑”，我们看到的是一个个的驱动器盘符，每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形<br><strong>在 Linux 下</strong>，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）：Linux没有盘符这个概念，只有一个根目录 <code>/</code>，所有文件都在它下面</p><table><thead><tr><th align="center">目录</th><th align="center">用处</th></tr></thead><tbody><tr><td align="center"><code>bin</code></td><td align="center">存放的是二进制的文件（命令）</td></tr><tr><td align="center"><code>boot</code></td><td align="center">存放的是引导内核的文件</td></tr><tr><td align="center"><code>dev</code></td><td align="center">存放的是各种设备文件</td></tr><tr><td align="center"><code>etc</code></td><td align="center">存放的是各种配置文件</td></tr><tr><td align="center"><code>home</code></td><td align="center">存放的是超级用户的家目录</td></tr><tr><td align="center"><code>lib</code></td><td align="center">存放的是各种库文件</td></tr><tr><td align="center"><code>media</code></td><td align="center">用来挂载存储介质或者流媒体介质的文件</td></tr><tr><td align="center"><code>mnt</code></td><td align="center">系统默认用来挂载的目录</td></tr><tr><td align="center"><code>proc</code></td><td align="center">动态的目录（不能用于存储文件）<br />（系统内核的信息、进程的信息、内存映射的信息）</td></tr><tr><td align="center"><code>root</code></td><td align="center">超级用户的家目录</td></tr></tbody></table><h2 id="终端的使用"><a href="#终端的使用" class="headerlink" title="终端的使用"></a>终端的使用</h2><h3 id="终端的打开"><a href="#终端的打开" class="headerlink" title="终端的打开"></a>终端的打开</h3><ol><li><p>鼠标右键-&gt;打开终端</p></li><li><p>左下角-&gt;显示应用程序-&gt;终端</p></li><li><p>快捷键 <code>ctrl + alt + t</code></p></li></ol><h3 id="终端标签页的使用"><a href="#终端标签页的使用" class="headerlink" title="终端标签页的使用"></a>终端标签页的使用</h3><ol><li>打开终端标签页 <code>ctrl + shift + t</code></li><li>打开终端标签页<code>ctrl + shift + w</code></li><li>切换终端标签页 <code>ctrl + pgup / pgdn</code></li></ol><blockquote><p>注意：有些键盘功能键还有其他功能，使用<code>fn</code>加上上述快捷键试一试</p></blockquote><h3 id="终端提示符"><a href="#终端提示符" class="headerlink" title="终端提示符"></a>终端提示符</h3><p>打开终端之后首先看到的就是终端提示符</p><p><code>root@zack-CSTG:~# </code></p><p><code>root@zack-CSTG:~$ </code></p><p>在<code>@</code>之前的位置：显示的是当前登陆终端的用户</p><blockquote><p> 注意 : </p><p>root用户是超级用户,是在安装Ubuntu操作系统时就被系统创建出的用户</p><p><code>#</code>        代表超级用户</p><p><code>$</code>        代表普通用户</p></blockquote><table><thead><tr><th align="center">从@开始</th><th align="center"></th></tr></thead><tbody><tr><td align="center"><code>@</code></td><td align="center">分割信息的分割符号</td></tr><tr><td align="center"><code>zack-CSTG</code></td><td align="center">主机名</td></tr><tr><td align="center"><code>:</code></td><td align="center">分割信息的分割符号</td></tr><tr><td align="center">在<code>:</code>之后</td><td align="center">当前终端所在路径</td></tr></tbody></table><h3 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h3><p>路径可以分为<strong>绝对路径</strong>和<strong>相对路径</strong></p><p>从根目录出发，一层一层递进的路径是<strong>绝对路径</strong>，其余的都是<strong>相对路径</strong></p><blockquote><p><strong>如何区分一个路径是不是绝对路径?</strong></p><p>查看该路径的最左边是不是<code>/</code> ,如果是<code>/</code>就是绝对路径</p><blockquote><p><strong>例:</strong><br><code>/home/zack/桌面</code>    从根目录出发一层一层递进，是绝对路径<br><code>~/桌面</code>    不是绝对路径</p></blockquote></blockquote><h3 id="修改终端提示符长度"><a href="#修改终端提示符长度" class="headerlink" title="修改终端提示符长度"></a>修改终端提示符长度</h3><blockquote><p><strong>注意:</strong><br>如果修改<code>/etc</code>下的配置文件,会影响所有用户<br>如果修改家目录下的配置文件,会影响当前用户</p></blockquote><p>修改终端提示符的配置文件，在终端输入<code>vim ~/.bashrc</code>，大约在文件第60行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\[\033[01;34m\]\W\[\033[00m\]\$ &#x27;</span></span><br></pre></td></tr></table></figure><p>把 <code>@</code> 之后到 <code>:</code> 的内容都删除掉    (删除的是主机名)</p><p><code>\w</code> 修改成 <code>\W</code>（代表目录路径只显示最后一级）</p><p>保存退出，最后终端输入<code>sync</code>，同步信息</p>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌入式开发基础 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件系统</title>
      <link href="/2022/08/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/08/28/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/Linux/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h1><h2 id="Linux文件系统简介"><a href="#Linux文件系统简介" class="headerlink" title="Linux文件系统简介"></a>Linux文件系统简介</h2><p><strong>在Linux系统中一切皆文件</strong></p><p>在我们熟悉的Windows系统中，有着盘符的概念，因为Windows的文件结构是多个并列的树状结构，最顶端是不同的磁盘分区。</p><p>Linux的文件结构是<strong>单个的树状结构，根目录是<code>/</code><strong>，其他目录都要位于根目录下。以<code>/</code>为根目录层层嵌套，层级目录结构，所有的资源，包括硬件设备都是以文件的形式表现出来。这样用户就可以</strong>用读写文件的方式实现对硬件的访问</strong>，优势显而易见。</p><blockquote><p>在Linux中使用正斜杠(/)而不是反斜杠(\)来划分目录。在Linux中，反斜杠是用来标识转义字符的</p></blockquote><h2 id="Ext4和XFS文件系统"><a href="#Ext4和XFS文件系统" class="headerlink" title="Ext4和XFS文件系统"></a>Ext4和XFS文件系统</h2><p>ext4 文件系统由 ext3 文件系统改进而来，而后者又是从 ext2 文件系统改进而来。虽然 ext4 文件系统已经非常稳定，是过去几年中绝大部分发行版的默认选择，但它是基于陈旧的代码开发而来。另外， Linux 操作系统用户也需要很多 ext4 文件系统本身不提供的新功能。虽然通过某些软件能满足这种需求，但性能会受到影响，在文件系统层次做到这些能获得更好的性能。</p><p>ext4 文件系统由 ext3 文件系统改进而来，而后者又是从 ext2 文件系统改进而来。虽然 ext4 文件系统已经非常稳定，是过去几年中绝大部分发行版的默认选择，但它是基于陈旧的代码开发而来。另外， Linux 操作系统用户也需要很多 ext4 文件系统本身不提供的新功能。虽然通过某些软件能满足这种需求，但性能会受到影响，在文件系统层次做到这些能获得更好的性能。</p><p>XFS 文件系统是扩展文件系统的一个扩展。XFS 是 64 位高性能日志文件系统。对 XFS 的支持大概在 2002 年合并到了 Linux 内核，到了 2009 年，红帽企业版 Linux 5.4 也支持了 XFS 文件系统。对于 64 位文件系统，XFS 支持最大文件系统大小为 8 exabytes。XFS 文件系统有一些缺陷，例如它不能压缩，删除大量文件时性能低下。目前RHEL 7.0 文件系统默认使用 XFS。</p><blockquote><p><strong>如何选择文件系统？</strong></p><p>​    ext4 还是赢家。为什么呢？答案在于易用性以及广泛性。对于桌面或者工作站， ext4 仍然是一个很好的文件系统。由于它是默认提供的文件系统，用户可以在上面安装操作系统。同时， ext4 支持最大 1 exabytes 的卷和 16 terabytes 的文件，因此考虑到大小，它也还有很大的进步空间。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 嵌入式开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 文件系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习计划和方法</title>
      <link href="/2022/08/26/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2022/08/26/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="学习计划和方法"><a href="#学习计划和方法" class="headerlink" title="学习计划和方法"></a>学习计划和方法</h1><p><img src="https://s2.loli.net/2022/08/26/vWabw5yUin1d2Yf.png" alt="嵌入式学习路线"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从下个月开始又要在机构进行嵌入式开发的学习，在正式开班之前有大量的时间，打算在此期间先提前对嵌入式进行学习。</p><p>在网上搜了搜，稍微总结了一下嵌入式学习的知识点，看着路线图个人感觉偏向硬件方向，对大学纯软件的我来说是个不小的挑战。</p><p>从之前Java的学习经历和最近的反思，我认为自己有一套较为合理的学习方法，所以在接下来的学习中我要摒弃之前学习的坏毛病，重新真正地投入到嵌入式开发地学习中。</p><h2 id="学习方法和计划"><a href="#学习方法和计划" class="headerlink" title="学习方法和计划"></a>学习方法和计划</h2><p>我将把从今天开始的时间大致划分为两种学习的情况，周末或假期时间充裕的情况和平时上课的情况，分别制定计划。</p><h3 id="每日的学习方法和计划"><a href="#每日的学习方法和计划" class="headerlink" title="每日的学习方法和计划"></a>每日的学习方法和计划</h3><p>在方法上，直到正式开课前主要还是以网上学习的视频为主，前一天计划好第二天需要完成的进度，在看视频期间使用便签记录重要知识点。尽量保证看视频的连贯性，在晚上对看过的视频进行整理总结为博客，及时更新到个人博客当中。第二天时花费一些时间通过记忆和博客内容，对前一天所学知识画出思维导图，过程中复习知识达到巩固的效果。</p><p><img src="https://s2.loli.net/2022/08/26/rDZyxWAzGOpnMf4.png" alt="每日任务"></p><p>对于平时学习的要求，不要求学习的进度，而是要每天保证学习的高效和个人输出的质量，但是在这些要求的前提是每天的学习时间要充分地利用。</p><p>如果学习中发现有多余的时间，对已完成的任务进行优化，看看有什么可以改进的地方。</p><h3 id="具体学习时间的安排"><a href="#具体学习时间的安排" class="headerlink" title="具体学习时间的安排"></a>具体学习时间的安排</h3><p>在之前的学习中，一直没有去划分学习和休息的时间，想着学累了就休息。但是实际情况却是自我的放松，没有很好地利用时间。根据多年摆烂的经验，我感觉没有计划的学习时间，会产生很多的懈怠。所以在平时具体的学习时间的安排上，使用番茄工作法。<strong>工作25分钟 + 休息5分钟</strong>，对于计划中的学习时间最大程度利用好。</p><p><img src="https://s2.loli.net/2022/08/26/mDySQf4txLn9lce.png" alt="番茄工作法"></p><h3 id="反思与总结"><a href="#反思与总结" class="headerlink" title="反思与总结"></a>反思与总结</h3><p>回想多年的学习时间，从来没有过主动去回忆反思一段时间的学习过程。从我自身感觉，定期的反思可以让自己做的更好。</p><p>所以在博客中要定期评估自己上一阶段的学习状态和学习的过程，思考下一次是否可以做的更好。其中针对自己分心或倦怠的原因，思考今后在学习中如何避免类似情况发生。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>报错解决</title>
      <link href="/2022/05/09/Java%E5%90%8E%E7%AB%AF/%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/"/>
      <url>/2022/05/09/Java%E5%90%8E%E7%AB%AF/%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0/%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h1><h2 id="generatorConfig头文件报红"><a href="#generatorConfig头文件报红" class="headerlink" title="generatorConfig头文件报红"></a>generatorConfig头文件报红</h2><p><img src="https://s2.loli.net/2022/05/09/AtEcdGSTbJK3gMv.png" alt="image-20220509142217836"></p><p><a href="https://blog.csdn.net/liu918458630/article/details/111881256">点这里</a></p><h2 id="springboot集成mongodb提示Please-use-‘MongoMappingContext-setAutoIndexCreation-boolean-‘-or-override"><a href="#springboot集成mongodb提示Please-use-‘MongoMappingContext-setAutoIndexCreation-boolean-‘-or-override" class="headerlink" title="springboot集成mongodb提示Please use ‘MongoMappingContext#setAutoIndexCreation(boolean)‘ or override"></a><a href="https://blog.csdn.net/qq_45087553/article/details/120956443">springboot集成mongodb提示Please use ‘MongoMappingContext#setAutoIndexCreation(boolean)‘ or override</a></h2><p><strong>解决方法：在配置文件中加入如下配置：取消自动创建索引</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.data.mongodb.auto-index-creation=false</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>问题总结</title>
      <link href="/2022/05/06/Java%E5%90%8E%E7%AB%AF/%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/05/06/Java%E5%90%8E%E7%AB%AF/%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h1><h2 id="Spring-Boot中application-bootstrap共存问题"><a href="#Spring-Boot中application-bootstrap共存问题" class="headerlink" title="Spring Boot中application  bootstrap共存问题"></a>Spring Boot中<code>application  bootstrap</code>共存问题</h2><blockquote><p> 今天看公司的项目，发现配置文件中<code>application.yml bootstrap.yml</code>两者共同存在于项目中，之前学习只使用过一个，没有两个结合起来使用，产生了疑惑</p></blockquote><p>两者的区别</p><ul><li>bootstrap 配置文件先于 application 配置文件被加载，会先创建初始化 Bootstrap Context，再创建初始化 Application Context，应用于更早期的配置信息，可以理解为系统配置</li><li>bootstrap 和 application 共享同一个 Environment，默认情况下，<strong>bootstrap 的配置不会被覆盖</strong>，而 <strong>application 的配置项可以被覆盖</strong>（比如被 application-dev 覆盖，或被 java 命令行覆盖）</li></ul><p>百度了一波，发现基于Spring Boot构建的Spring Cloud应用程序，会创建一个bootstrap上下文环境，它有别于Spring Boot自身application上下文环境。bootstrap 是应用程序的父上下文，也就是说 <strong>bootstrap 加载优先于 application</strong>。 bootstrap 主要用于从额外的资源来加载配置信息，还可以在本地外部配置文件中解密属性。这两个上下文共用一个环境，它是任何 Spring 应用程序的外部属性的来源。bootstrap 里面的属性会优先加载，它们默认也不能被本地相同配置覆盖。</p><h3 id="bootstrap和application的应用场景"><a href="#bootstrap和application的应用场景" class="headerlink" title="bootstrap和application的应用场景"></a>bootstrap和application的应用场景</h3><p><strong>application</strong></p><p>主要用于spring boot 项目的自动化配置；</p><p><strong>bootstrap</strong></p><p>a、使用 spring Cloud config 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息；</p><p>b、一些固定的不能被覆盖的配置；</p><p>c、一些加密/解密的场景；</p><h2 id="Service层和DTO层的作用"><a href="#Service层和DTO层的作用" class="headerlink" title="Service层和DTO层的作用"></a>Service层和DTO层的作用</h2><p>Service层主要提供的几个作用：<br>1、将业务逻辑层进行封装，对外提供业务服务调用。<br>2、通过外观模式，屏蔽业务逻辑内部方法。<br>3、降低业务逻辑层与UI层的依赖，业务逻辑接口或实现的变化不会影像UI层。<br>4、降低UI层调用的请求次数及数据往返。</p><p>DTO层主要提供的作用：</p><p>在上面的结构中，我们说了Service层的作用，目前还少加入了一层，DTO(数据传输对象层)，该层负责屏蔽后端的实体层，将UI层需要的数据进行重新的定义和封装，在实际的业务场景下，后端实现或存储的数据远比用户需要的数据要庞大和复杂，所以前端需要的数据相对来说要么是组合的，要么是抽取的，不是完整的，因为我们在设计数据存储格式上都会有一些额外的设计和考虑。</p><p>前端的UI层，只是知道DTO的存在，同时前端需要的数据都在一个DTO中，这样，每次调用服务层的时候，只需要调用一次就可以完成所有的业务逻辑操作，而不是原来的直接调用业务逻辑层那样的，需要调用多次，对于分布式场景下，减少服务调用的次数，尤其重要。</p><h2 id="Spring-Boot-使用-Micrometer-集成-Prometheus-监控-Java-应用性能"><a href="#Spring-Boot-使用-Micrometer-集成-Prometheus-监控-Java-应用性能" class="headerlink" title="Spring Boot 使用 Micrometer 集成 Prometheus 监控 Java 应用性能"></a><a href="https://blog.csdn.net/aixiaoyang168/article/details/100866159">Spring Boot 使用 Micrometer 集成 Prometheus 监控 Java 应用性能</a></h2><h2 id="Resource和-Autowired的区别"><a href="#Resource和-Autowired的区别" class="headerlink" title="@Resource和@Autowired的区别"></a><a href="https://blog.csdn.net/waitle500/article/details/122857925">@Resource和@Autowired的区别</a></h2><h2 id="Spring中-Primary注解"><a href="#Spring中-Primary注解" class="headerlink" title="Spring中@Primary注解"></a><a href="https://blog.csdn.net/niugang0920/article/details/116275748">Spring中@Primary注解</a></h2><h2 id="mybatis插件generatorConfiguration-xml配置"><a href="#mybatis插件generatorConfiguration-xml配置" class="headerlink" title="mybatis插件generatorConfiguration.xml配置"></a><a href="https://blog.csdn.net/nishino_shou/article/details/81109740">mybatis插件generatorConfiguration.xml配置</a></h2><h2 id="输入映射"><a href="#输入映射" class="headerlink" title="输入映射"></a>输入映射</h2><p>需求：</p><p>完成用户信息的综合查询，查询的条件比较复杂，针对需求我们需要封装查询类出来</p><p>封装的查询类在数据库中是不存在的</p><h3 id="不同对象含义（PO-VO-…）"><a href="#不同对象含义（PO-VO-…）" class="headerlink" title="不同对象含义（PO VO …）"></a><a href="https://blog.csdn.net/qq_35246620/article/details/77247427">不同对象含义（PO VO …）</a></h3><p><img src="C:/Users/23508/blog/source/_posts/%E5%B7%A5%E4%BD%9C%E5%AD%A6%E4%B9%A0/%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.assets/20170816144718827.png" alt="img"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>医院挂号项目</title>
      <link href="/2022/04/14/Java%E5%90%8E%E7%AB%AF/%E5%8C%BB%E9%99%A2%E6%8C%82%E5%8F%B7%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/04/14/Java%E5%90%8E%E7%AB%AF/%E5%8C%BB%E9%99%A2%E6%8C%82%E5%8F%B7%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="医院挂号项目"><a href="#医院挂号项目" class="headerlink" title="医院挂号项目"></a>医院挂号项目</h1><h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><p><img src="https://s2.loli.net/2022/04/14/hT5CFjOW1rd3oy8.png" alt="image-20220414103527885"></p><h2 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h2><img src="https://s2.loli.net/2022/04/14/3PuRV7BZHSmxkv4.png" alt="医院挂号业务流程"  /><h2 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h2><p><img src="https://s2.loli.net/2022/04/14/Kfsl7dyANhRUWCB.png" alt="服务架构"></p><h2 id="项目模块搭建"><a href="#项目模块搭建" class="headerlink" title="项目模块搭建"></a>项目模块搭建</h2><p><img src="https://s2.loli.net/2022/04/14/YQM2ruVDRwXlh5k.png" alt="项目模块搭建"></p><p><img src="C:/Users/23508/blog/source/_posts/%E5%8C%BB%E9%99%A2%E6%8C%82%E5%8F%B7%E9%A1%B9%E7%9B%AE.assets/image-20220414112406568.png" alt="image-20220414112406568"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式事务</title>
      <link href="/2022/04/13/Java%E5%90%8E%E7%AB%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
      <url>/2022/04/13/Java%E5%90%8E%E7%AB%AF/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><h2 id="一图解读分布式事务"><a href="#一图解读分布式事务" class="headerlink" title="一图解读分布式事务"></a>一图解读分布式事务</h2><p><img src="https://img-blog.csdnimg.cn/20210710220330858.png" alt="分布式事务"></p><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><ul><li><p><strong>事务：</strong>事务是由一组操作构成的可靠的独立的工作单元，事务具备ACID的特性，即原子性、一致性、隔离性和持久性。</p></li><li><p><strong>本地事务：</strong>当事务由资源管理器本地管理时被称作本地事务。本地事务的优点就是支持严格的ACID特性，高效，可靠，状态可以只在资源管理器中维护，而且应用编程模型简单。但是本地事务不具备分布式事务的处理能力，隔离的最小单位受限于资源管理器。</p></li><li><p><strong>全局事务：</strong>当事务由全局事务管理器进行全局管理时成为全局事务，事务管理器负责管理全局的事务状态和参与的资源，协同资源的一致提交回滚。</p></li><li><p><strong>CAP定理：</strong>对于共享数据系统，最多只能同时拥有CAP其中的两个，任意两个都有其适应的场景，真是的业务系统中通常是ACID与CAP的混合体。分布式系统中最重要的是满足业务需求，而不是追求高度抽象，绝对的系统特性。C表示一致性，也就是所有用户看到的数据是一样的。A表示可用性，是指总能找到一个可用的数据副本。P表示分区容错性，能够容忍网络中断等故障。</p></li></ul><h2 id="分布式事务与分布式锁的区别："><a href="#分布式事务与分布式锁的区别：" class="headerlink" title="分布式事务与分布式锁的区别："></a>分布式事务与分布式锁的区别：</h2><blockquote><p><strong>分布式锁</strong>解决的是分布式资源抢占的问题；<strong>分布式事务和本地事务</strong>是解决流程化提交问题。</p></blockquote><h2 id="事务简介"><a href="#事务简介" class="headerlink" title="事务简介"></a>事务简介</h2><p>事务(Transaction)是操作数据库中某个数据项的一个**程序执行单元(**unit)。</p><p>事务应该具有4个属性：<strong>原子性、一致性、隔离性、持久性</strong>。这四个属性通常称为<strong>ACID</strong>特性。</p><h3 id="事务的四个特征："><a href="#事务的四个特征：" class="headerlink" title="事务的四个特征："></a>事务的四个特征：</h3><h4 id="Atomic原子性"><a href="#Atomic原子性" class="headerlink" title="Atomic原子性"></a>Atomic原子性</h4><p>事务必须是一个原子的操作序列单元，事务中包含的各项操作在一次执行过程中，要么全部执行成功，要么全部不执行，任何一项失败，整个事务回滚，只有全部都执行成功，整个事务才算成功。</p><h4 id="Consistency一致性"><a href="#Consistency一致性" class="headerlink" title="Consistency一致性"></a>Consistency一致性</h4><p>事务的执行不能破坏数据库数据的完整性和一致性，事务在执行之前和之后，数据库都必须处于一致性状态。</p><h4 id="Isolation隔离性"><a href="#Isolation隔离性" class="headerlink" title="Isolation隔离性"></a>Isolation隔离性</h4><p>在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。即不同的事务并发操纵相同的数据时，每个事务都有各自完整的数据空间，即一个事务内部的操作及使用的数据对其他并发事务是隔离的，并发执行的各个事务之间不能相互干扰。</p><h4 id="SQL中的4个事务隔离级别："><a href="#SQL中的4个事务隔离级别：" class="headerlink" title="SQL中的4个事务隔离级别："></a>SQL中的4个事务隔离级别：</h4><p><strong>读未提交</strong></p><p>允许脏读。如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此事务没有提交，与此同时，允许另一个事务也能够访问该数据。例如A将变量n从0累加到10才提交事务，此时B可能读到n变量从0到10之间的所有中间值。</p><p><strong>读已提交</strong></p><p>允许不可重复读。只允许读到已经提交的数据。即事务A在将n从0累加到10的过程中，B无法看到n的中间值，之中只能看到10。同时有事务C进行从10到20的累加，此时B在同一个事务内再次读时，读到的是20。</p><p><strong>可重复读</strong></p><p>允许幻读。保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻时是一致的。禁止脏读、不可重复读。幻读即同样的事务操作，在前后两个</p><p><strong>串行化</strong></p><p> 最严格的事务，要求所有事务被串行执行，不能并发执行。</p><p>如果不对事务进行并发控制，我们看看数据库并发操作是会有那些异常情形</p><ol><li>一类丢失更新：两个事物读同一数据，一个修改字段1，一个修改字段2，后提交的恢复了先提交修改的字段。</li><li>二类丢失更新：两个事物读同一数据，都修改同一字段，后提交的覆盖了先提交的修改。</li><li>脏读：读到了未提交的值，万一该事物回滚，则产生脏读。</li><li>不可重复读：两个查询之间，被另外一个事务修改了数据的内容，产生内容的不一致。</li><li>幻读：两个查询之间，被另外一个事务插入或删除了记录，产生结果集的不一致。</li></ol><h4 id="Durability持久性"><a href="#Durability持久性" class="headerlink" title="Durability持久性"></a>Durability持久性</h4><p>持久性（durability）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久性的。</p><p>即使发生系统崩溃或机器宕机，只要数据库能够重新启动，那么一定能够将其恢复到事务成功结束时的状态。</p><blockquote><p>比方说：一个人买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试题</title>
      <link href="/2022/04/11/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/11/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/Mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql面试题"><a href="#Mysql面试题" class="headerlink" title="Mysql面试题"></a>Mysql面试题</h1><h2 id="MySQL中的存储引擎"><a href="#MySQL中的存储引擎" class="headerlink" title="MySQL中的存储引擎"></a>MySQL中的存储引擎</h2><p><strong>常用的存储引擎有以下：</strong></p><ul><li><strong>Innodb引擎：</strong>Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li><li><strong>MyIASM引擎(Mysql5.5前的默认引擎)：</strong>不提供事务的支持，也不支持行级锁和外键。</li><li><strong>MEMORY引擎：</strong>所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li></ul><p><strong>MyISAM与InnoDB区别：</strong></p><table><thead><tr><th align="center"></th><th align="center">MyISAM</th><th align="center">Innodb</th></tr></thead><tbody><tr><td align="center">是否支持事务</td><td align="center">不支持事务， 但是每次查询都是原子的</td><td align="center">支持 ACID 的事务， 支持事务的四种隔离级别</td></tr><tr><td align="center">锁支持</td><td align="center">支持表级锁定</td><td align="center">支持行级锁定、表级锁定，锁定力度小并发能力高</td></tr><tr><td align="center">是否支持外键</td><td align="center">不支持外键</td><td align="center">支持外键</td></tr><tr><td align="center">存储结构</td><td align="center">每张表被存放在三个文件：索引文件MYI、数据文件MYD、frm表结构文件</td><td align="center">所有的表都保存在同一个数据文件中（也可以是多个），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td></tr><tr><td align="center">存储空间</td><td align="center">MyISAM可被压缩，存储空间较小</td><td align="center">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td></tr><tr><td align="center">文件格式</td><td align="center">数据和索引是分别存储的，数据.MYD，索引.MYI</td><td align="center">数据和索引是集中存储的，.ibd</td></tr><tr><td align="center">可移植性、备份及恢复</td><td align="center">跨平台的数据转移中会很方，在备份和恢复时可单独针对某个表进行操作</td><td align="center">可以拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td></tr><tr><td align="center">记录存储顺序</td><td align="center">按记录插入顺序保存</td><td align="center">按主键大小有序插入</td></tr><tr><td align="center">哈希索引</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持</td><td align="center">不支持(但可以使用Sphinx插件)</td></tr></tbody></table><blockquote><p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点。</p><p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。<br>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p></blockquote><h2 id="数据库三大范式"><a href="#数据库三大范式" class="headerlink" title="数据库三大范式"></a>数据库三大范式</h2><ul><li>第一范式： <strong>属性</strong>不可再分</li><li>第二范式： 在一范式的基础上，<strong>消除</strong>了部份<strong>依赖</strong>，<strong>属性</strong>完全依赖于<strong>主键</strong></li><li>第三范式： 在二范式的基础上，<strong>消除了传递依赖</strong>，属性不依赖于其它非主属性 <strong>属性直接依赖于主键</strong></li></ul><h2 id="数据库中的事务是什么-事务的特性？"><a href="#数据库中的事务是什么-事务的特性？" class="headerlink" title="数据库中的事务是什么?事务的特性？"></a>数据库中的事务是什么?事务的特性？</h2><p>事务（ transaction） 是一组有序的数据库操作。如果组中的所有操作都成功， 则认为事务成功，提交事务。 如果一个操作失败， 则事务将回滚， 该事务所有操作的影响都将取消。（事务是逻辑上的一组操作，要么都执行，要么都不执行）</p><ol><li>原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><h3 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h3><ul><li>官方介绍索引是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>。更通俗的说，数据库索引好比是一本书前面的目录，能<strong>加快数据库的查询速度</strong>。</li><li>一般来说索引本身也很大，不可能全部存储在内存中，因此<strong>索引往往是存储在磁盘上的文件中的</strong>（可能存储在单独的索引文件中，也可能和数据一起存储在数据文件中）。</li><li><strong>我们通常所说的索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。</strong></li></ul><h3 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h3><p><strong>优势：</strong></p><ul><li><strong>可以提高数据检索的效率，降低数据库的IO成本</strong>，类似于书的目录。</li><li>通过<strong>索引列对数据进行排序</strong>，降低数据排序的成本，降低了CPU的消耗。<ul><li>被索引的列会自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。</li><li>如果按照索引列的顺序进行排序，对应order by语句来说，效率就会提高很多。</li></ul></li></ul><p><strong>劣势：</strong></p><ul><li><strong>索引会占据磁盘空间</strong></li><li><strong>索引虽然会提高查询效率，但是会降低更新表的效率</strong>。比如每次对表进行增删改操作，MySQL不仅要保存数据，还有保存或者更新对应的索引文件。</li></ul><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p><strong>主键索引</strong></p><p>索引列中的值必须是唯一的，不允许有空值。</p><p><strong>普通索引</strong></p><p>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。</p><p><strong>唯一索引</strong></p><p>索引列中的值必须是唯一的，但是允许为空值。</p><p><strong>全文索引</strong></p><p>只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。 MyISAM和InnoDB中都可以使用全文索引。</p><p><strong>空间索引</strong></p><p>MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这方面遵循OpenGIS几何数据模型规则。</p><p><strong>前缀索引</strong></p><p>在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不能指定。</p><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>Hash表，在Java中的HashMap，TreeMap就是Hash表结构，以键值对的方式存储数据。我们使用Hash表存储表数据Key可以存储索引列，Value可以存储行记录或者行磁盘地址。Hash表在等值查询时效率很高，时间复杂度为O(1)；但是不支持范围快速查找，范围查找时还是只能通过扫描全表方式。</p><p><strong>显然这种并不适合作为经常需要查找和范围查找的数据库索引使用。</strong></p><h3 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h3><p>二叉树，我想大家都会在心里有个图。</p><p><img src="https://img-blog.csdnimg.cn/20201024113453660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MTkwNDky,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试扫盲问题</title>
      <link href="/2022/04/09/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E6%89%AB%E7%9B%B2%E9%97%AE%E9%A2%98/"/>
      <url>/2022/04/09/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E6%89%AB%E7%9B%B2%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="面试扫盲问题"><a href="#面试扫盲问题" class="headerlink" title="面试扫盲问题"></a>面试扫盲问题</h1><h2 id="什么是OpenFeign"><a href="#什么是OpenFeign" class="headerlink" title="什么是OpenFeign"></a>什么是OpenFeign</h2><h3 id="OpenFeign概念："><a href="#OpenFeign概念：" class="headerlink" title="OpenFeign概念："></a>OpenFeign概念：</h3><p>OpenFeign是<strong>Spring Cloud</strong>家族的一个成员， 它最核心的作用是为 HTTP 形式的 Rest API提供了非常简洁高效的 <strong>RPC 调用方式</strong></p><h3 id="OpenFeign的用途及实现原理"><a href="#OpenFeign的用途及实现原理" class="headerlink" title="OpenFeign的用途及实现原理"></a>OpenFeign的用途及实现原理</h3><p>OpenFeign的用途：<strong>服务发现，负载均衡，服务调用</strong></p><p>OpenFeign的实现原理：基于@EnableFeignClients 将所有被@FeignClient注解的类 注册到容器中。当这些被@FeignClient注解的类被调用时会创建一个动态代理的对象为我们创建被调用类的实例，然后都会被统一转发给 <a href="https://so.csdn.net/so/search?q=Feign&spm=1001.2101.3001.7020">Feign</a> 框架所定义的一个 InvocationHandler ， 由该 Handler 完成后续的 HTTP 转换， 发送， 接收， 翻译HTTP响应的工作。</p><h2 id="什么是API网关"><a href="#什么是API网关" class="headerlink" title="什么是API网关"></a>什么是API网关</h2><p>在微服务架构中，通常会有多个服务提供者。设想一个电商系统，可能会有商品、订单、支付、用户等多个类型的服务，而每个类型的服务数量也会随着整个系统体量的增大也会随之增长和变更。作为UI端，在展示页面时可能需要从多个微服务中<strong>聚合数据</strong>，而且服务的划分位置结构可能会有所改变。<strong>网关就可以对外暴露聚合API，屏蔽内部微服务的微小变动，保持整个系统的稳定性。</strong></p><p>当然这只是网关众多功能中的一部分，它还可以做<strong>负载均衡，统一鉴权，协议转换，监控监测</strong>等一系列功能。</p><h2 id="什么是Zuul"><a href="#什么是Zuul" class="headerlink" title="什么是Zuul"></a>什么是Zuul</h2><p>Zuul是<strong>Spring Cloud</strong>全家桶中的微服务API网关。</p><p>有从设备或网站来的请求都会经过Zuul到达后端的Netflix应用程序。作为一个边界性质的应用程序，Zuul提供了<strong>动态路由、监控、弹性负载和安全功能</strong>。Zuul底层利用各种filter实现如下功能：</p><ul><li>认证和安全 识别每个需要认证的资源，拒绝不符合要求的请求。</li><li>性能监测 在服务边界追踪并统计数据，提供精确的生产视图。</li><li>动态路由 根据需要将请求动态路由到后端集群。</li><li>压力测试 逐渐增加对集群的流量以了解其性能。</li><li>负载卸载 预先为每种类型的请求分配容量，当请求超过容量时自动丢弃。</li><li>静态资源处理 直接在边界返回某些响应。</li></ul><h2 id="什么是跨域，什么跨域问题，如何解决"><a href="#什么是跨域，什么跨域问题，如何解决" class="headerlink" title="什么是跨域，什么跨域问题，如何解决"></a>什么是跨域，什么跨域问题，如何解决</h2><p>跨域是正常的，<strong>协议，ip 或域名，端口号</strong>，任一不同，都属于跨域请求。</p><p>跨域问题，指的 ajax 发起请求，请求可以到达服务器，但是服务器无法响应 json 数据的问题。 </p><p>解决方案： </p><ol><li>服务器端运行跨域 设置 CORS 等于 *； </li><li>在单个接口使用注解 @CrossOrigin 运行跨域； </li><li>使用 jsonp 跨域；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitMQ面试题</title>
      <link href="/2022/04/07/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/rabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/07/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/rabbitMQ%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="项目中用过消息队列么？你为啥用消息队列？"><a href="#项目中用过消息队列么？你为啥用消息队列？" class="headerlink" title="项目中用过消息队列么？你为啥用消息队列？"></a>项目中用过消息队列么？你为啥用消息队列？</h2><p>采用<strong>微服务的设计思想</strong>，<strong>分布式的部署方式</strong>，所以拆分了很多的服务，随着体量的增加以及业务场景越来越复杂了，很多场景单机的技术栈和中间件以及不够用了，而且对系统的友好性也下降了，最后做了很多技术选型的工作，我们决定引入<strong>消息队列中间件</strong>。</p><h2 id="在什么场景用到了消息队列？"><a href="#在什么场景用到了消息队列？" class="headerlink" title="在什么场景用到了消息队列？"></a>在什么场景用到了消息队列？</h2><p>嗯，我从三个方面去说一下我使用的场景吧。<strong>异步、削峰、解耦</strong></p><p>我们之前的场景里面有很多步骤都是在一个流程里面需要做完的，就比如说我的下单系统吧，本来我们业务简单，下单了付了钱就好了，流程就走完了。</p><p>但是后面来了个产品经理，搞了个<strong>优惠券系统</strong>，OK问题不大，流程里面多100ms去扣减优惠券。</p><p>后来产品经理灵光一闪说我们可以搞个<strong>积分系统</strong>啊，也行吧，流程里面多了200ms去增减积分。</p><p>再后来后来隔壁的产品老王说：下单成功后我们要给用户发短信，也将就吧，100ms去发个短信。</p><p><img src="https://s2.loli.net/2022/04/08/cbkHgYFsEeTRnM5.jpg" alt="img"></p><p>这样的链路下去，整个系统时间就很长，用户体验很差</p><h3 id="链路长了就慢了，那你怎么解决的？"><a href="#链路长了就慢了，那你怎么解决的？" class="headerlink" title="链路长了就慢了，那你怎么解决的？"></a>链路长了就慢了，那你怎么解决的？</h3><p>那链路长了就慢了，但是我们发现上面的流程其实可以<strong>同时做</strong>的呀，你支付成功后，我去校验优惠券的同时我可以去增减积分啊，还可以同时发个短信啊。</p><p>那正常的流程我们是没办法实现的呀，怎么办，<strong>异步</strong>。</p><p><img src="https://s2.loli.net/2022/04/08/rmtT3IEyVRABKQv.jpg" alt="img"></p><h3 id="异步，那我用线程，线程池去做不是一样的么？"><a href="#异步，那我用线程，线程池去做不是一样的么？" class="headerlink" title="异步，那我用线程，线程池去做不是一样的么？"></a>异步，那我用线程，线程池去做不是一样的么？</h3><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><p>因为用线程去做，带来的是代码量的增多</p><p>你一个订单流程，你扣积分，扣优惠券，发短信，扣库存。。。等等这么多业务要调用这么多的接口，<strong>每次加一个你要调用一个接口然后还要重新发布系统</strong>，写一次两次还好，写多了你就说：老子不干了！</p><p>你下单了，你就把你<strong>支付成功的消息告诉别的系统</strong>，他们收到了去处理就好了，你只用走完自己的流程，把自己的消息发出去，那后面要接入什么系统简单，直接订阅你发送的支付成功消息，你支付成功了我<strong>监听就好了</strong>。</p><p><img src="https://s2.loli.net/2022/04/08/qTY6iPKLy9pmrSt.jpg" alt="img"></p><h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><p>你平时流量很低，但是你要做秒杀活动00 ：00的时候流量疯狂怼进来，你的服务器，<strong>Redis</strong>，<strong>MySQL</strong>各自的承受能力都不一样，你直接<strong>全部流量照单全收</strong>肯定有问题啊，直接就打挂了。</p><p>把请求放到队列里面，然后至于每秒消费多少请求，就看自己的<strong>服务器处理能力</strong>，你能处理5000QPS你就消费这么多，可能会比正常的慢一点，但是<strong>不至于打挂服务器</strong>，等流量高峰下去了，你的服务也就没压力了。</p><h3 id="消息队列有啥问题么？"><a href="#消息队列有啥问题么？" class="headerlink" title="消息队列有啥问题么？"></a>消息队列有啥问题么？</h3><h4 id="系统复杂性"><a href="#系统复杂性" class="headerlink" title="系统复杂性"></a>系统复杂性</h4><p>本来蛮简单的一个系统，我代码随便写都没事，现在你凭空接入一个中间件在那，我是不是要考虑去维护他，而且使用的过程中是不是要考虑各种问题，比如消息<strong>重复消费</strong>、<strong>消息丢失</strong>、<strong>消息的顺序消费</strong>等等，反正用了之后就是贼烦。</p><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><p>这个其实是分布式服务本身就存在的一个问题，<strong>不仅仅是消息队列的问题</strong>，但是用了消息队列这个问题会暴露得比较严重一点。</p><p><strong>分布式事务</strong>：把下单，优惠券，积分。。。都放在一个事务里面一样，要成功一起成功，要失败一起失败。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>你搞个系统本身没啥问题，你现在突然接入一个中间件在那放着，万一挂了怎么办？我下个单<strong>MQ挂了</strong>，优惠券不扣了，积分不减了。</p><h2 id="技术选型为什么使用rabbitMQ"><a href="#技术选型为什么使用rabbitMQ" class="headerlink" title="技术选型为什么使用rabbitMQ"></a>技术选型为什么使用rabbitMQ</h2><p><img src="https://s2.loli.net/2022/04/08/UjKt7ic3aInAOfN.jpg" alt="img"></p><p>高可用，并发能力强，延时最低，不会丢失消息（不像ActiveMQ和kafka会丢失消息）社区活跃度高</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis面试题</title>
      <link href="/2022/04/07/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/redis%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/04/07/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/redis%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="什么是redis"><a href="#什么是redis" class="headerlink" title="什么是redis"></a>什么是redis</h2><p>redis 是一个 C 语言开发的，基于内存的，高性能 key-value 形式的，单线程的 NoSQL 数据库。可以用作数据库、缓存、消息中间件等，主要用于缓存和 session 共享。提高查询效率和用户体验，为分布式系统提供 session 共享。</p><p>Redis作为一个<strong>非关系型</strong>内存数据库</p><ol><li>性能优秀，数据在<strong>内存中</strong>，<strong>读写速度非常快</strong>，支持<strong>并发10W QPS</strong>；</li><li><strong>单进程单线程</strong>，是<strong>线程安全</strong>的，采用<strong>IO多路复用机制</strong>；</li><li>丰富的数据类型，支持字符串（strings）、散列（hashes）、列表（lists）、集合（sets）、有序集合（<strong>zset</strong>）等；</li><li>支持数据持久化。可以将内存中数据保存在磁盘中，重启时加载；</li><li>主从复制，哨兵，高可用；</li><li>可以用作分布式锁；</li><li>可以作为消息中间件使用，<strong>支持发布订阅</strong></li></ol><h2 id="Redis五种数据类型"><a href="#Redis五种数据类型" class="headerlink" title="Redis五种数据类型"></a>Redis五种数据类型</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/648f7d3c9ae46ba1b9baa220f7caeaf8.png" alt="img"></p><ol><li>string是redis最基本的类型，可以理解成与memcached一模一样的类型，一个key对应一个value。value不仅是string，也可以是数字。string类型是二进制安全的，意思是redis的string类型可以包含任何数据，比如jpg图片或者序列化的对象。string类型的值最大能存储512M。</li><li>Hash是一个键值（key-value）的集合。redis的hash是一个string的key和value的映射表，Hash特别适合存储对象。常用命令：hget,hset,hgetall等。</li><li>list列表是简单的字符串列表，<strong>按照插入顺序排序</strong>。可以添加一个元素到列表的头部（左边）或者尾部（右边）  常用命令：lpush、rpush、lpop、rpop、lrange(获取列表片段)等。<strong>应用场景：</strong>list应用场景非常多，也是Redis最重要的数据结构之一，比如twitter的关注列表，粉丝列表都可以用list结构来实现。数据结构：list就是链表，可以用来当消息队列用。redis提供了List的push和pop操作，还提供了操作某一段的api，可以直接查询或者删除某一段的元素。<strong>实现方式：</strong>redis list的是实现是一个双向链表，既可以支持反向查找和遍历，更方便操作，不过带来了额外的内存开销。</li><li><strong>set是string类型的无序集合</strong>。集合是通过hashtable实现的。set中的元素是没有顺序的，而且是没有重复的。常用命令：sdd、spop、smembers、sunion等。应用场景：redis set对外提供的功能和list一样是一个列表，特殊之处在于<strong>set是自动去重的</strong>，而且set提供了判断某个成员是否在一个set集合中。</li><li>zset和set一样是string类型元素的集合，且不允许重复的元素。常用命令：zadd、zrange、zrem、zcard等。使用场景：sorted set可以通过用户额外提供一个优先级（score）的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set结构。和set相比，sorted set<strong>关联了一个double类型权重的参数score</strong>，使得集合中的元素能够按照score进行有序排列，redis正是通过score来为集合中的成员进行从小到大的排序。实现方式：Redis sorted set的内部使用**HashMap和跳跃表(skipList)**来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score，使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。</li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><input checked="" disabled="" type="checkbox"> 手写的RedisTemplate</li></ul><p><img src="https://s2.loli.net/2022/04/07/mRb6Lnh3IaiHufF.png"></p><h2 id="redis使用中的问题"><a href="#redis使用中的问题" class="headerlink" title="redis使用中的问题"></a>redis使用中的问题</h2><h3 id="缓存和数据库数据一致性问题"><a href="#缓存和数据库数据一致性问题" class="headerlink" title="缓存和数据库数据一致性问题"></a>缓存和数据库数据一致性问题</h3><p>分布式环境下非常容易出现<strong>缓存和数据库间数据一致性问题</strong>，针对这一点，如果项目对缓存的要求是强一致性的，那么就不要使用缓存。我们只能采取合适的策略来降低缓存和数据库间数据不一致的概率，而无法保证两者间的强一致性。合适的策略包括合适的缓存更新策略，更新数据库后及时更新缓存、缓存失败时增加重试机制。</p><p>因为<strong>写和读是并发的</strong>，<strong>没法保证顺序</strong>，如果删了缓存，还没有来得及写库，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。如果先写了库，再删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。 如果是redis集群，或者主从模式，写主读从，由于redis复制存在一定的<strong>时间延迟</strong>，也有可能导致数据不一致。</p><h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><h4 id="双删加超时"><a href="#双删加超时" class="headerlink" title="双删加超时"></a>双删加超时</h4><p>在写库前后都进行<code>redis.del(key)</code>操作，并且<strong>设定合理的超时时间</strong>。这样最差的情况是在超时时间内存在不一致，当然这种情况极其少见，可能的原因就是服务宕机。此种情况可以满足绝大多数需求。 当然这种策略要考虑redis和数据库主从同步的耗时，所以在第二次删除前最好休眠一定时间，比如500毫秒，这样毫无疑问又增加了写请求的耗时</p><h4 id="异步淘汰缓存"><a href="#异步淘汰缓存" class="headerlink" title="异步淘汰缓存"></a>异步淘汰缓存</h4><p>通过读取binlog的方式，异步淘汰缓存。</p><p><strong><img src="https://s2.loli.net/2022/04/08/YTdZN9fgnOqlv4y.png" alt="img"></strong></p><p>好处：业务代码侵入性低，将缓存与数据库不一致的时间尽可能缩小。</p><h3 id="Redis缓存雪崩"><a href="#Redis缓存雪崩" class="headerlink" title="Redis缓存雪崩"></a>Redis缓存雪崩</h3><p>我了解的，目前电商首页以及热点数据都会去做缓存，一般缓存都是定时任务去刷新，或者查不到之后去更新缓存的，定时任务刷新就有一个问题。举个栗子：如果首页所有Key的失效时间都是12小时，中午12点刷新的，我零点有个大促活动大量用户涌入，假设每秒6000个请求，本来缓存可以抗住每秒5000个请求，但是缓存中所有Key都失效了。此时6000个/秒的请求全部落在了数据库上，数据库必然扛不住，真实情况可能DBA都没反应过来直接挂了，此时，如果没什么特别的方案来处理，DBA很着急，重启数据库，但是数据库立马又被新流量给打死了。这就是我理解的缓存雪崩。</p><p>同一时间大面积失效，瞬间Redis跟没有一样，那这个数量级别的请求直接打到数据库几乎是灾难性的，你想想如果挂的是一个用户服务的库，那其他依赖他的库所有接口几乎都会报错，如果没做熔断等策略基本上就是瞬间挂一片的节奏，你怎么重启用户都会把你打挂，等你重启好的时候，用户早睡觉去了</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>处理缓存雪崩简单，在批量往Redis存数据的时候，把每个Key的失效时间都加个随机值就好了，这样可以保证数据不会再同一时间大面积失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setRedis（key, value, time+Math.random()*<span class="number">10000</span>）;</span><br></pre></td></tr></table></figure><p>如果Redis是集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效。或者设置热点数据永不过期，有更新操作就更新缓存就好了（比如运维更新了首页商品，那你刷下缓存就好了，不要设置过期时间），电商首页的数据也可以用这个操作，保险</p><h2 id="Redis缓存击穿、缓存穿透"><a href="#Redis缓存击穿、缓存穿透" class="headerlink" title="Redis缓存击穿、缓存穿透"></a>Redis缓存击穿、缓存穿透</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>先说下缓存穿透吧，缓存穿透是指缓存和数据库中都没有的数据，而用户（黑客）不断发起请求，举个栗子：我们数据库的id都是从1自增的，如果发起id=-1的数据或者id特别大不存在的数据，这样的不断攻击导致数据库压力很大，严重会击垮数据库。</p><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>至于缓存击穿嘛，这个跟缓存雪崩有点像，但是又有一点不一样，缓存雪崩是因为大面积的缓存失效，打崩了DB，而缓存击穿不同的是缓存击穿是指一个Key非常热点，在不停地扛着大量的请求，大并发集中对这一个点进行访问，当这个Key在失效的瞬间，持续的大并发直接落到了数据库上，就在这个Key的点上击穿了缓存</p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><p>缓存穿透我会在接口层增加校验，比如用户鉴权，参数做校验，不合法的校验直接return，比如id做基础校验，id&lt;=0直接拦截</p><p>我记得Redis里还有一个高级用法<strong>布隆过滤器（Bloom Filter）</strong> 这个也能很好的预防缓存穿透的发生，他的原理也很简单，就是利用高效的数据结构和算法快速判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查DB刷新KV再return。</p><p>缓存击穿的话，设置热点数据永不过期，或者加上互斥锁就搞定了。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。.</p><h2 id="redis为什么这么快"><a href="#redis为什么这么快" class="headerlink" title="redis为什么这么快"></a>redis为什么这么快</h2><p>官方提供的数据可以达到<strong>100000+的QPS</strong>（每秒内的查询次数）</p><p>Redis是<strong>单进程单线程的模型</strong>，因为Redis完全是<strong>基于内存</strong>的操作，<strong>CPU不是Redis的瓶颈</strong>，Redis的瓶颈最有可能是<strong>机器内存的大小或者网络带宽</strong>。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章的采用单线程的方案了（毕竟采用多线程会有很多麻烦）。</p><ol><li>Redis完全基于内存，绝大部分请求是纯粹的<strong>内存操作</strong>，非常迅速，数据存在内存中，<strong>类似于HashMap</strong>，HashMap的优势就是查找和操作的时间复杂度是O(1)。</li><li><strong>数据结构简单</strong>，对数据操作也简单。</li><li>采用<strong>单线程</strong>，避免了不必要的上下文切换和竞争条件，不存在多线程导致的CPU切换，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有死锁问题导致的性能消耗。</li><li>使用<strong>多路复用IO模型</strong>，非阻塞IO。</li></ol><h2 id="Redis和Memcached的区别"><a href="#Redis和Memcached的区别" class="headerlink" title="Redis和Memcached的区别"></a>Redis和Memcached的区别</h2><ol><li><strong>存储方式上：</strong>memcache会把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。<em><strong>redis有部分数据存在硬盘上，这样能保证数据的持久性。</strong></em></li><li><strong>数据支持类型上：</strong>memcache对数据类型的支持简单，只支持简单的key-value，，而<em><strong>redis支持五种数据类型</strong></em>。</li><li><strong>使用底层模型不同：</strong>它们之间底层实现方式以及与客户端之间通信的应用协议不一样。<em><strong>redis直接自己构建了VM机制</strong></em>，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li><li><strong>value的大小：</strong>redis可以达到<strong>1GB</strong>，而memcache只有<strong>1MB</strong>。</li></ol><h2 id="redis淘汰策略"><a href="#redis淘汰策略" class="headerlink" title="redis淘汰策略"></a>redis淘汰策略</h2><table><thead><tr><th align="left">策略</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">volatile-lru</td><td align="left">从已设置过期时间的KV集中优先对最近<strong>最少使用</strong>(less recently used)的数据淘汰</td></tr><tr><td align="left">volitile-ttl</td><td align="left">从已设置过期时间的KV集中优先对<strong>剩余时间短</strong>(time to live)的数据淘汰</td></tr><tr><td align="left">volitile-random</td><td align="left">从已设置过期时间的KV集中<strong>随机选择</strong>数据淘汰</td></tr><tr><td align="left">allkeys-lru</td><td align="left">从<strong>所有KV集中优先对最近最少使用</strong>(less recently used)的数据淘汰</td></tr><tr><td align="left">allKeys-random</td><td align="left">从<strong>所有KV集中随机</strong>选择数据淘汰</td></tr><tr><td align="left">noeviction</td><td align="left">不淘汰策略，若超过最大内存，返回错误信息</td></tr></tbody></table><p>补充一下：Redis4.0加入了LFU(least frequency use)淘汰策略，包括volatile-lfu和allkeys-lfu，通过统计访问频率，将访问频率最少，即最不经常使用的KV淘汰。</p><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>redis为了保证效率，<strong>数据缓存在了内存中</strong>，但是会<strong>周期性</strong>的把更新的数据<strong>写入磁盘</strong>或者把修改操作写入追加的记录文件中，<strong>以保证数据的持久化</strong>。</p><p>Redis的持久化策略有两种</p><ol><li><strong>RDB：</strong>快照形式是<strong>直接把内存中的数据保存到一个dump的文件</strong>中，定时保存，保存策略。</li><li><strong>AOF：</strong>把<strong>所有的对Redis的服务器进行修改的命令都存到一个文件里</strong>，命令的集合。</li></ol><p>Redis默认是快照RDB的持久化方式。当Redis重启的时候，它会优先使用AOF文件来还原数据集，因为AOF文件保存的数据集通常比RDB文件所保存的数据集更完整。你甚至可以关闭持久化功能，让数据只在服务器运行时存储。</p><h3 id="RDB是怎么工作的"><a href="#RDB是怎么工作的" class="headerlink" title="RDB是怎么工作的"></a>RDB是怎么工作的</h3><p>默认Redis是会以快照”RDB”的形式将数据持久化到磁盘的一个二进制文件dump.rdb。工作原理简单说一下：当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉，这样的好处是可以copy-on-write。</p><p>RDB的优点是：这种文件非常适合用于备份：比如，你可以在最近的24小时内，每小时备份一次，并且在每个月的每一天也备份一个RDB文件。这样的话，即使遇上问题，也可以随时将数据集还原到不同的版本。RDB非常适合灾难恢复。RDB的缺点是：如果你需要尽量避免在服务器故障时丢失数据，那么RDB不合适你。</p><h3 id="AOF是怎么工作的"><a href="#AOF是怎么工作的" class="headerlink" title="AOF是怎么工作的"></a>AOF是怎么工作的</h3><p>每一个写命令都通过write函数追加到appendonly.aof中，配置方式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendfsync yes   appendfsync always     #每次有数据修改发生时都会写入AOF文件。appendfsync everysec   #每秒钟同步一次，该策略为AOF的缺省策略。复制代码</span><br></pre></td></tr></table></figure><p>AOF可以做到全程持久化，只需要在配置中开启 appendonly yes。这样redis每执行一个修改数据的命令，都会把它添加到AOF文件中，当redis重启时，将会读取AOF文件进行重放，恢复到redis关闭前的最后时刻。</p><p>使用AOF的优点是会让redis变得非常耐久。可以设置不同的fsync策略，aof的默认策略是每秒钟fsync一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的fsync策略，AOF的速度可能会慢于RDB。</p><h3 id="如何选择持久化策略"><a href="#如何选择持久化策略" class="headerlink" title="如何选择持久化策略"></a>如何选择持久化策略</h3><p>如果你非常关心你的数据，但仍然可以承受数分钟内的数据丢失，那么可以额只使用RDB持久。AOF将Redis执行的每一条命令追加到磁盘中，处理巨大的写入会降低Redis的性能，不知道你是否可以接受。数据库备份和灾难恢复：定时生成RDB快照非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度快。当然了，redis支持同时开启RDB和AOF，系统重启后，redis会优先使用AOF来恢复数据，这样丢失的数据会最少。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><blockquote><p>redis单节点存在单点故障问题，为了解决单点问题，一般都需要对redis配置从节点，然后使用哨兵来监听主节点的存活状态，如果主节点挂掉，从节点能继续提供缓存功能，你能说说redis主从复制的过程和原理吗？</p></blockquote><p>主从配置结合哨兵模式能解决单点故障问题，提高redis可用性。从节点仅提供读操作，主节点提供写操作。对于读多写少的状况，可给主节点配置多个从节点，从而提高响应效率</p><ol><li>从节点执行<code>slaveof[masterIP][masterPort]</code>，保存主节点信息</li><li>从节点中的定时任务发现主节点信息，建立和主节点的socket连接</li><li>从节点发送Ping信号，主节点返回Pong，两边能互相通信</li><li>连接建立后，主节点将所有数据发送给从节点（数据同步）</li><li>主节点把当前的数据同步给从节点后，便完成了复制的建立过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性。</li></ol><h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><blockquote><p>那主从复制会存在哪些问题呢？</p></blockquote><p>主从复制会存在以下问题：</p><p>1、一旦主节点宕机，从节点晋升为主节点，同时需要修改应用方的主节点地址，还需要命令所有从节点去复制新的主节点，整个过程需要人工干预。</p><p>2、主节点的写能力受到单机的限制。</p><p>3、主节点的存储能力受到单机的限制。</p><p>4、原生复制的弊端在早期的版本中也会比较突出，比如：redis复制中断后，从节点会发起psync。此时如果同步不成功，则会进行全量同步，主库执行全量备份的同时，可能会造成毫秒或秒级的卡顿。</p><p>比较主流的解决方案是哨兵</p><p><img src="https://s2.loli.net/2022/04/07/yF5DZ3dQvGYTArK.jpg" alt="Redis Sentinel（哨兵）架构图"></p><p>Redis Sentinel（哨兵）的架构图。Redis Sentinel（哨兵）主要功能包括<strong>主节点存活检测</strong>、<strong>主从运行情况检测</strong>、<strong>自动故障转移</strong>、<strong>主从切换</strong>。Redis Sentinel最小配置是一主一从。Redis的Sentinel系统可以用来管理多个Redis服务器，该系统可以执行以下四个任务：</p><p>1、监控：不断检查主服务器和从服务器是否正常运行。</p><p>2、通知：当被监控的某个redis服务器出现问题，Sentinel通过API脚本向管理员或者其他应用程序发出通知。</p><p>3、自动故障转移：当主节点不能正常工作时，Sentinel会开始一次自动的故障转移操作，它会将与失效主节点是主从关系的其中一个从节点升级为新的主节点，并且将其他的从节点指向新的主节点，这样人工干预就可以免了。</p><p>4、配置提供者：在Redis Sentinel模式下，客户端应用在初始化时连接的是Sentinel节点集合，从中获取主节点的信息。</p><h3 id="哨兵的工作原理"><a href="#哨兵的工作原理" class="headerlink" title="哨兵的工作原理"></a>哨兵的工作原理</h3><p>用一个或者多个哨兵来监视主服务器(也就是进行写操作的服务器)是否在正常执行任务，一旦哨兵发现主服务器不可用时，就找到一个合适的从服务器成为主服务器。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MybatisPlus</title>
      <link href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MybatisPlus/"/>
      <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93/MybatisPlus/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo</title>
      <link href="/2022/03/10/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/Dubbo/"/>
      <url>/2022/03/10/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/Dubbo/</url>
      
        <content type="html"><![CDATA[<h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><h2 id="Dubbo是什么"><a href="#Dubbo是什么" class="headerlink" title="Dubbo是什么?"></a>Dubbo是什么?</h2><p>Dubbo是阿里巴巴公司开源的一个高性能优秀的<strong>服务框架</strong>，使得应用可通过高性能的 <strong>RPC</strong> 实现服务的输出和输入功能，可以和Spring框架无缝集成。<br>Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：<strong>面向接口的远程方法调用</strong>，<strong>智能容错和负载均衡</strong>，以及<strong>服务自动注册和发现</strong>。</p><blockquote><p>又是一个框架😵，每次学习框架都感觉学不明白，可能和学习的方式有关系。对于框架还是没有本质的认识，使用来说也没有感觉，脑子里没有框架的思想，所以感觉寸步难行。之前的框架还没有开始复习，现在从Dubbo的学习来找点感觉吧。</p><p>看完基本介绍，想要继续下去，我们先要解决<strong>什么是RPC？</strong>这个问题。    </p></blockquote><h3 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h3><p><em>RPC是<strong>远程过程调用</strong>（Remote Procedure Call）的缩写形式。</em>远程调用对立的就是本地调用，我们之前学习Java时，实现一个个方法之间的调用，这个就是本地调用。再通俗点，就是从你本机上调用方法就是本地调用，而你在本地调用了其他地方机器上的某个方法就是远程调用。 <strong>RPC 框架就是要实现像那小助手一样的东西，目的就是让我们使用远程调用像本地调用一样简单方便，并且解决一些远程调用会发生的一些问题。</strong></p><blockquote><p>RPC底层的的核心技术是<strong>序列化和反序列化</strong></p><ol><li>生产者<strong>发布服务</strong></li><li>消费者按照RPC协议<strong>调用</strong>生产者发布的服务</li><li>生产者<strong>执行方法</strong>得到返回的对象</li><li>生产者将对象<strong>序列化</strong>后返回给消费者</li><li>消费者接收数据后<strong>反序列化</strong>，得到Java对象</li></ol></blockquote><p><img src="https://s2.loli.net/2022/03/10/QYrBbzvSiD2Hd5T.png" alt="image-20220310184149676"></p><h3 id="Dubbo工作原理"><a href="#Dubbo工作原理" class="headerlink" title="Dubbo工作原理"></a>Dubbo工作原理</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dmExLnNpbmFpbWcuY24vbGFyZ2UvMDA3UzhaSWxseTFnaHU5N250c2FjajMwZTAwYWszeXguanBn?x-oss-process=image/format,png" alt="img"></p><ol><li>生产者<strong>启动Dubbo容器</strong> ，生产服务对象</li><li>生产者把生成的服务<strong>发布到注册中心</strong></li><li>消费者向注册中心<strong>订阅服务</strong>，把发布的<strong>服务下载</strong>到本地缓存，订阅服务后，本地缓存会<strong>自动更新生产者发布的服务</strong></li><li>当消费者需要调用服务时，按照RPC协议要求，<strong>向生产者发起服务调用</strong></li><li>生产者将对象交给Dubbo 容器进行<strong>序列化处理</strong>后给消费者</li><li>消费者接收返回的数据对其<strong>反序列化</strong>，得到Java对象</li><li>监视器对服务性能做监控统计</li></ol><table><thead><tr><th align="center">节点</th><th align="center">角色说明</th></tr></thead><tbody><tr><td align="center">Provider</td><td align="center">暴露服务的服务提供方</td></tr><tr><td align="center">Consumer</td><td align="center">调用远程服务的服务消费方</td></tr><tr><td align="center">Registry</td><td align="center">服务注册与发现的注册中心</td></tr><tr><td align="center">Monitor</td><td align="center">统计服务的调用次数和调用时间的监控中心</td></tr><tr><td align="center">Container</td><td align="center">服务运行容器</td></tr></tbody></table><blockquote><p>注册中心Registry和监控中心Monitor都不是必须的，可以缺少</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2022/03/08/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/RabbitMQ/"/>
      <url>/2022/03/08/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/RabbitMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><blockquote><p>这两天学习RabbitMQ，还是一知半解，现在想想根本不知道这玩意是干啥的（刘少还没讲应用）。别说应用了，这玩意课上简单的demo敲完我都一脸懵😵，所以还是好好梳理一下概念和demo的流程（这里说是很值钱💴）。</p></blockquote><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在说RabbitMQ前，先和我们说了AMQP（高级消息队列协议），<span alt="hide"><del>一个提供统一消息服务的应用层标准高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。</del></span></p><p>这一大堆的介绍是一句听不懂，不过RabbitMQ其实就是一个实现了AMQP的开源的<strong>消息中间件</strong>，使用高性能的Erlang编写的。</p><blockquote><p>上面有两个概念刚听到的时候不是太理解，<strong>消息队列</strong>和<strong>消息中间件</strong>。我直接百度一下，万能的百度没有你我可咋办呀🧡💛💚💚💙💙💜🤎💖</p></blockquote><h3 id="什么是消息队列？"><a href="#什么是消息队列？" class="headerlink" title="什么是消息队列？"></a>什么是消息队列？</h3><p><a href="https://www.zhihu.com/question/54152397?sort=created">看这里</a></p><blockquote><p>大佬就是不一样，这种娓娓道来的感觉是真的让我佩服。以后再看见消息队列心里就默念异步、削峰、解耦（异步、削峰、解耦；异步、削峰、解耦…背他个100遍先😠）。</p><p>消息队列简单的说就是把消息放在队列中，其本身就是一个中间件，那什么是消息、什么是队列呢？</p><p><strong>消息就是我们需要传递的数据，而队列就是一种先进先出的数据结构。</strong>简单关联一下我们做的项目，有些数据我们接收后需要传递，传递到某些功能的队列中，根据队列中不同功能的执行顺序依次执行（还是比较模糊😵）</p><p>实际上消息队列和消息中间件是一回事。从实现上来说，它是一个消息的“队列”，把它放到系统里，它就成为了一个中间件。简单说消息队列是概念，消息中间件就是实现概念的产出。</p><p>PS： </p><p><strong>provider</strong><br>   消息的生产者,就是投递消息的程序</p><p><strong>consumer</strong><br>   消息的消费者,就是接收消息的程序</p></blockquote><h2 id="RabbitMQ简单demo"><a href="#RabbitMQ简单demo" class="headerlink" title="RabbitMQ简单demo"></a>RabbitMQ简单demo</h2><p>我们使用RabbitMQ前需要在Linux上进行下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查找镜像</span><br><span class="line">docker search rabbitmq:management</span><br><span class="line"></span><br><span class="line">拉取镜像</span><br><span class="line">docker pull macintoshplus/rabbitmq-management</span><br><span class="line"></span><br><span class="line"> 查看镜像</span><br><span class="line"> docker images</span><br><span class="line"> </span><br><span class="line"> 运行</span><br><span class="line"> docker run -d --hostname chenziyang --name rabbitmq -e RABBITMQ_USER=guest -e RABBITMQ_PASS=guest -p 15672:15672 -p 5672:5672 c20</span><br></pre></td></tr></table></figure><blockquote><p>在Linux上安装完docker后按照步骤一顿复制粘贴就行😂，最后返回一段看不懂的数据就可以</p><p><a href="http://192.168.145.128:15672/#/">http://192.168.145.128:15672/#/</a></p><p>返回成功后进入网页如果能成功进入我们就完成了第一步（其中192.168…这个地址要是你Linux的端口号）</p></blockquote><p><img src="https://s2.loli.net/2022/03/08/hxapEswkyPTzoRQ.png" alt="image-20220308190748744"></p><p>接着我们开始进行配置</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>在pom.xml中我们要导入RabbitMQ的依赖，还要注意Spring Boot版本号，这里用的是2.5.7，太高的版本可能会出现问题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--RabbitMQ依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目名（可以自定义）</span></span><br><span class="line"><span class="attr">pring.application.name</span>=<span class="string">rabbitmq-demo01</span></span><br><span class="line"><span class="comment"># 连接虚拟机中的mq，写自己虚拟机的ip</span></span><br><span class="line"><span class="attr">spring.rabbitmq.host</span>=<span class="string">192.168.145.128</span></span><br><span class="line"><span class="comment"># 指定端口号</span></span><br><span class="line"><span class="attr">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="comment"># 账号密码</span></span><br><span class="line"><span class="attr">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="attr">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"># 自定义属性 没有感知</span></span><br><span class="line"><span class="attr">mq.queue.name</span>=<span class="string">hello-queue</span></span><br></pre></td></tr></table></figure><p>当我们创建RabbitMQ容器时<code>docker run -d --hostname chenziyang --name rabbitmq -e RABBITMQ_USER=guest -e RABBITMQ_PASS=guest -p 15672:15672 -p 5672:5672 c20</code>中15672是提供给web使用，而5672提供个idea使用，账号和密码在创建容器时也已经指定。</p><h3 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h3><p><strong>消息队列配置类QueueConfig</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * QueueConfig</span></span><br><span class="line"><span class="comment"> * 消息队列配置类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈子洋</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 2022-03-08 16:43</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QueueConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列的名字，名字使用$&#123;&#125;从配置文件中获取</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mq.queue.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String queueName;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//对应的包：org.springframework.amqp.core.Queue</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">creatQueue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(queueName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建队列方法中<code>Queue</code>就是声明创建一个名字为<code>queueName</code>的队列，之后发送方<code>provider</code>将信息放到队列中，接收方<code>consumer</code>从队列中读取消息。</p><p><strong>消息生产者类Sender</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sender</span></span><br><span class="line"><span class="comment"> * 消息的生产者，就是投递信息的程序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈子洋</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 2022-03-08 16:48</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Sender</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息队列的模板</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpTemplate template;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取name</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;mq.queue.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String queueName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        template.convertAndSend(queueName,msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的类就是消息的生产者，还是老样子，先说一说里面不明白的地方吧。</p><p>首先，我们给这个类一个注解<code>@Component</code>，虽然大概知道是标记这个类是什么类型，但是具体的还是不太清楚（都是曾经欠下的帐😭），然后就是<code>AmqpTemplate</code>，对于template之前好像也使用过，但是根本不明白他的用途（好像说这个类似于springMVC的内容）最后还有个好像是新的注释<code>@Value</code></p><blockquote><p><strong>AmqpTemplate</strong></p><p>指定一组基本的 AMQP 操作。提供同步发送和接收方法。<code>convertAndSend(Object)</code>and <code>receiveAndConvert()</code>方法允许您发送和接收 POJO 对象。实现应该委托给一个实例<code>MessageConverter</code>来执行与 AMQP byte[] 有效负载类型之间的转换。</p><p>上面是官方API的解释，Template本意也是模板的意思，那这个就可以大体理解了，后面再详细看看。    </p><h5 id="Component"><a href="#Component" class="headerlink" title="@Component"></a>@Component</h5><p>@Component就是spring中的一个注解，作用就是实现bean的注入</p></blockquote></blockquote><p><strong>消息接收者类Receive</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Receive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接收消息 然后处理消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//监听队列</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;$&#123;mq.queue.name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">process</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="comment">//处理消息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Receive&quot;</span>+msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 通过Application启动在RabbitMQ网页上可以看队列的信息说明启动成功。</p><p><strong>测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ApplicationTests</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Sender sender;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        sender.send(<span class="string">&quot;你好...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行测试类，在控制台中就可以看到输出的信息</p><blockquote><p>其实这样看看也不是太难（毕竟是第一个例子）</p><ol><li>消息队列配置类（QueueConfig）中新建了一个名为<code>hello-queue</code>的queue队列，这个名字是我们在<code>application.properties</code>中自定义的属性，在<code>QueueConfig</code>中通过<code>@Value</code>注解通过key值获取。</li><li>在消息生产者类（Sender）类中，通过消息队列模板<code>AmqpTemplate</code>中的方法将要发送的信息打包好发送出去</li><li>消息接收者类通过<code>@RabbitListener</code>注解监听队列名，接收消息</li><li>消息在测试类中，注入消息生产者类，输入要传递的消息</li></ol><blockquote><p>感觉直接去梳理流程太慢了，跟不上课程了，还是先把其中的原理搞清楚，抽空再把流程写出来，还能复习一下。（这两天的东西都没有完成，不能拆东墙补西墙，合理分配时间💪）</p></blockquote></blockquote><h2 id="RabbitMQ工作原理"><a href="#RabbitMQ工作原理" class="headerlink" title="RabbitMQ工作原理"></a>RabbitMQ工作原理</h2><p><img src="https://s2.loli.net/2022/03/09/LOXzaGik36B1RuW.png" alt="image-20220309162532777"></p><p><img src="https://s2.loli.net/2022/03/09/yR1YLjEVpQIbdzl.png"></p><blockquote><p>上面两张图片就是RabbitMQ的工作原理图图片上的概念，我们要稍微梳理一下</p></blockquote><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><table><thead><tr><th align="center"></th><th>解释</th></tr></thead><tbody><tr><td align="center"><strong>Message</strong></td><td>消息 消息是不具名的 它是由消息头和主体组成，消息体不透明 消息头是由一系列的属性组成<code>routing-key</code>（路由键）、优先权、消息的存储(永久的)</td></tr><tr><td align="center"><strong>provider (Publisher)</strong></td><td>消息的生产者,就是投递消息的程序</td></tr><tr><td align="center"><strong>consumer</strong></td><td>消息的消费者,就是接收消息的程序</td></tr><tr><td align="center"><strong>Exchange</strong></td><td>交换器 用来接收生产者发送的消息，将消息路由给服务器中的队列<br/>  三种类型：<br/>    1.订阅与发布 direct<br/>    2.广播 fanout<br/>    3.主题，规则匹配 topic</td></tr><tr><td align="center"><strong>Binding</strong></td><td>绑定消息队列和交换器之间的关联</td></tr><tr><td align="center"><strong>Queue</strong></td><td>消息队列  用来保存消息最终发给消费者</td></tr><tr><td align="center"><strong>Routing-key</strong></td><td>路由键 RabbitMQ决定消息投递到哪个队列的规则</td></tr><tr><td align="center"><strong>Connection</strong></td><td>链接，rabbit和服务器之间建立的tcp 链接</td></tr><tr><td align="center"><strong>Channel</strong></td><td>信道 TCP中的虚拟链接，TCP就被打开，就会创建AMQP，无论是发布、接收、订阅等都是通过信道完成的</td></tr><tr><td align="center"><strong>Broker</strong></td><td>消息队列服务的实体</td></tr></tbody></table><blockquote><p>上面大部分的概念理解起来还是不困难的，最困扰我的还是两个key和Exchange交换器，不知道具体是有什么用处，我们还是先捋一下RabbitMQ这些名词的意思吧。<a href="https://blog.csdn.net/xinbaobaoer/article/details/54907793">参考文章</a></p></blockquote><p>RabbitMQ其实就是一个实现了AMQP的开源的<strong>消息中间件</strong>，再通俗点就是RabbitMQ是消息队列的一种实现。所以我们要围绕队列（queue）来阐述不明白的RabbitMQ中各种名词的含义。</p><p><strong>Exchange</strong>：我们需要让queue都接收到生产者发送的消息时，不可能给每个queue都发送一次消息，而且这样做肯定会造成资源的浪费。所以我们需要想出一种解决方法，给RabbitMQ一个规则，让它自己去解析需要给哪个队列发送消息。Exchange就是干这件事的，这里的规则就对应上面Exchange常用的三种类型。</p><blockquote><p><strong>RabbitMQ为什么需要信道？ 为什么不是TCP 直接通道?</strong></p><ol><li><strong>TCP的创建和销毁开销特别大</strong>，创建需要3次握手，销毁需要4次分手！</li><li>如果不用信道，应用程序就会以tcp方式进行链接，高峰时段每秒数以万计造成巨大的<strong>资源浪费</strong>，而且操作系统每秒钟处理TCP的数量是有限的，就会产生性能的瓶颈。</li><li>信道的原理是一个线程一条通道，多个线程多条通道同用一条TCP链接，一条TCP链接可以容纳无限的信道，请求量过大不会称为<strong>性能瓶颈</strong>。</li></ol></blockquote><h3 id="交换器Exchange"><a href="#交换器Exchange" class="headerlink" title="交换器Exchange"></a><a href="https://zhuanlan.zhihu.com/p/37198933">交换器Exchange</a></h3><p>我们上面说了Exchange是一种规则，向队列queue发送消息的一种规则。<strong>那么为什么我们需要 Exchange 而不是直接将消息发送至队列呢？</strong></p><blockquote><p>在实际应用中我们只需要定义好 Exchange 的<strong>路由策略</strong>，而生产者则不需要关心消息会发送到哪个 Queue 或被哪些 Consumer 消费。在这种模式下生产者只面向 Exchange 发布消息，消费者只面向 Queue 消费消息，Exchange 定义了消息路由到 Queue 的规则，将各个层面的消息传递隔离开，使每一层只需要关心自己面向的下一层，<strong>降低了整体的耦合度</strong>。</p></blockquote><h3 id="理解-Exchange"><a href="#理解-Exchange" class="headerlink" title="理解 Exchange"></a>理解 Exchange</h3><p><strong>Exchange 收到消息时，他是如何知道需要发送至哪些 Queue 呢？</strong>这里就需要了解 Binding 和 RoutingKey 的概念：</p><blockquote><p>Binding 表示 Exchange 与 Queue 之间的关系，我们也可以简单的认为队列对该交换机上的消息感兴趣，绑定可以附带一个额外的参数 RoutingKey。Exchange 就是根据这个 RoutingKey 和当前 Exchange 所有绑定的 Binding 做匹配，如果满足匹配，就往 Exchange 所绑定的 Queue 发送消息，这样就解决了我们向 RabbitMQ 发送一次消息，可以分发到不同的 Queue。RoutingKey 的意义依赖于交换机的类型。</p></blockquote><p>下面就来了解一下 Exchange 的三种主要类型：<code>Fanout</code>、<code>Direct</code> 和 <code>Topic</code>。</p><h4 id="发布与订阅-direct"><a href="#发布与订阅-direct" class="headerlink" title="发布与订阅 direct"></a>发布与订阅 direct</h4><p>也叫完全匹配，如图</p><p><img src="https://s2.loli.net/2022/03/09/6DBAEqlC3M1Z7Gn.png" alt="image-20220309183419779"></p><p>Direct Exchange 是 RabbitMQ 默认的 Exchange，完全根据 routing-key来路由消息。设置 交换器（Exchange） 和队列（Queue）的Binding时需指定routing-key（一般为 queueName），发消息时也指定一样的 routing-key，消息就会被路由到对应的Queue。从别名完全匹配也可以看出来direct的特点，就是精确匹配，routing-key和对应的路由一一匹配。</p><blockquote><p><strong>应用场景</strong></p><p>现在我们考虑只把重要的日志消息写入磁盘文件，例如只把 Error 级别的日志发送给负责记录写入磁盘文件的 Queue。这种场景下我们可以使用指定的 RoutingKey（例如 error）将写入磁盘文件的 Queue 绑定到 Direct Exchange 上。</p></blockquote><h4 id="广播-fanout"><a href="#广播-fanout" class="headerlink" title="广播 fanout"></a>广播 fanout</h4><p>Fanout Exchange 会忽略 RoutingKey 的设置，直接将 Message 广播到所有绑定的 Queue 中。</p><p><img src="https://s2.loli.net/2022/03/12/zHT9n7Xas4MZ8l6.png" alt="image-20220312141625921"></p><blockquote><p><strong>应用场景</strong></p><p>以日志系统为例：假设我们定义了一个 Exchange 来接收日志消息，同时定义了两个 Queue 来存储消息：一个记录将被打印到控制台的日志消息；另一个记录将被写入磁盘文件的日志消息。我们希望 Exchange 接收到的每一条消息都会同时被转发到两个 Queue，这种场景下就可以使用 Fanout Exchange 来广播消息到所有绑定的 Queue。</p></blockquote><h4 id="主题规则匹配-topic"><a href="#主题规则匹配-topic" class="headerlink" title="主题规则匹配 topic"></a>主题规则匹配 topic</h4><p><img src="https://s2.loli.net/2022/03/12/bkFI91rf2ViMzQm.png" alt="image-20220312110041041"></p><p>Topic Exchange 和 Direct Exchange 类似，也需要通过 RoutingKey 来路由消息，区别在于Direct Exchange 对 RoutingKey 是精确匹配，而 Topic Exchange 支持模糊匹配。分别支持<code>*</code>和<code>#</code>通配符，<code>*</code>表示匹配一个单词，<code>#</code>则表示匹配没有或者多个单词。</p><blockquote><p><strong>应用场景</strong></p><p>假设我们的消息路由规则除了需要根据日志级别来分发之外还需要根据消息来源分发，可以将 RoutingKey 定义为 <code>消息来源.级别</code> 如 <code>order.info</code>、<code>user.error</code>等。处理所有来源为 <code>user</code> 的 Queue 就可以通过 <code>user.*</code> 绑定到 Topic Exchange 上，而处理所有日志级别为 <code>info</code> 的 Queue 可以通过 <code>*.info</code> 绑定到 Exchange上。</p></blockquote><h2 id="Rabbit高级"><a href="#Rabbit高级" class="headerlink" title="Rabbit高级"></a>Rabbit高级</h2><h3 id="Rabbit-消息持久化"><a href="#Rabbit-消息持久化" class="headerlink" title="Rabbit 消息持久化"></a>Rabbit 消息持久化</h3><p>如果我们希望即使在RabbitMQ服务重启的情况下，也不会丢失消息，我们可以将Queue与Message都设置为可持久化的（durable），这样可以保证绝大部分情况下我们的RabbitMQ消息不会丢失。当然还是会有一些小概率事件会导致消息丢失。</p><h3 id="Ack"><a href="#Ack" class="headerlink" title="Ack"></a>Ack</h3>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EurekaServerApp注解详解</title>
      <link href="/2022/03/07/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/EurekaServerApp%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/03/07/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/EurekaServerApp%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="EurekaServerApp注解详解"><a href="#EurekaServerApp注解详解" class="headerlink" title="EurekaServerApp注解详解"></a>EurekaServerApp注解详解</h1><blockquote><p>EurekaServerApp中有@SpringBootApplication和@EnableEurekaServer两个注解，简单来说@SpringBootApplication的作用就是表明一个类为spring boot的启动类</p></blockquote><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>秒杀项目</title>
      <link href="/2022/03/06/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/03/06/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>博客自从搭起来零零碎碎的也写了点东西，但是都水的不行，依旧发挥了自己练习多年的CV大法，每篇看着都水的不行。最重要的是大部分都没有动脑子，缺少自己的想法，看着就不像自己的东西。</p><p>来培训了快半年了，东西嘛也多少学到点，就是还是和以前一样没有努力，Java基础、高级到后面框架，都是得过且过。欠的都是要还的，最近再学最后的秒杀项目，学到现在说实话，不懂，一点也不懂。本来打算周末的时候就着手写博客梳理、复习一下的，可是，我这该死的拖延症！！！！！</p><p>不过现在能开始也不是太迟嘛（自我安慰我一直是可以的），接下来主要目标就是把这个秒杀项目搞懂，其中穿插一些复习，还有一个月就要去面试了，压力太大了，这次就好好加油吧。</p><hr><p>OK，让我把我男神刘少的视频打开再跟着他好好学习秒杀项目</p><h2 id="秒杀项目介绍"><a href="#秒杀项目介绍" class="headerlink" title="秒杀项目介绍"></a>秒杀项目介绍</h2><p>前端-》请求-负载均衡（nginx）-网关(zuul)-&gt; eureka server-》配置（config-server）-》用户、商品、秒杀的微服务-消息中间件-websocket</p><img src="https://s2.loli.net/2022/03/07/bUjRnYuGwyVe2xS.png" alt="image-20220307131823424"  /><p>首先是秒杀项目的基本内容，大体内容：负载均衡、网关、eureka、配置、不同的微服务、消息中间件、web socket。</p><h2 id="项目搭建梳理"><a href="#项目搭建梳理" class="headerlink" title="项目搭建梳理"></a>项目搭建梳理</h2><blockquote><p>秒杀项目和之前的所有项目都不同，秒杀项目创建时要创建父子级项目</p><p>搭建微服务项目时，我们需要把公共的部分抽出来放在一个项目中，使用依赖的方式进行引用</p></blockquote><p>父项目：</p><ul><li><p><code>shop-parent [pom]</code></p><p>子项目：</p><ul><li><p><code>eureka-server [jar]</code> 服务注册，可运行的项目就是jar</p></li><li><p><code>config-server [jar]</code> 配置中心，需要连接码云，配置信息放在码云上进行托管</p></li><li><p><code>zuul-server [jar]</code> 网关</p></li><li><p><code>shop-common [jar]</code> 公共部分</p></li><li><p><code>redis-spring-boot-start [jar]</code> 自定义的start，以前写过</p></li><li><p><code>shop-provider [pom]</code> </p><p>子子项目</p><ul><li><code>member-server [jar]</code> 用户微服务</li><li><code>good-server [jar]</code> 商品微服务</li><li><code>seckill-server [jar]</code> 秒杀微服务</li></ul></li><li><p><code>shop-provider-api [pom]</code> </p><ul><li><p><code>member-api[jar]</code> 用户微服务</p></li><li><p><code>good-api[jar]</code> 商品微服务</p></li><li><p><code>seckill-api[jar]</code> 秒杀微服务</p></li></ul></li></ul></li></ul><p>其次就还有<code>fronted-server [jar]</code>前端和<code>websocket-server [jar]</code>消息通知中心两个项目，我们的秒杀项目就是由这些项目构成的。</p><hr><blockquote><p>到这里我得停一下，短短的项目搭建梳理就开始😵了，这里先梳理一下有问题的地方。</p></blockquote><h3 id="秒杀项目到底是什么项目？"><a href="#秒杀项目到底是什么项目？" class="headerlink" title="秒杀项目到底是什么项目？"></a>秒杀项目到底是什么项目？</h3><blockquote><p>要我现在说，我只能说秒杀项目就是微服务项目（spring cloud），那这样说之前学习的spring boot又是什么呢（秒杀项目中的启动类注解还有<code>@SpringBootApplication</code>😥）</p></blockquote><p>首先，我们要遵守程序，把spring boot 和 spring cloud两个基本概念找出来</p><p><strong>spring boot</strong> 用来简化配置的它可以简化spring应用程序的创建和开发过程。</p><p><strong>spring cloud</strong> 是分布式开发的解决方案，基于spring boot,在spring boot做较少的配置。</p><p>看到这，反正我没太懂（之前基础太差，全忘了我🤡），能得出的结论是<strong>spring boot</strong> 和<strong>spring cloud</strong> 两者相辅相成（废话🤣）。</p><p>百度找了一圈终于找到能让我理解的解释了：</p><p><img src="https://s2.loli.net/2022/03/07/Qn8Bl3ZOMatwExT.png" alt="image-20220307175307436"></p><blockquote><p>说的一下就让我明白了，果然牛的人不是懂技术的，是懂技术，还能讲出来，并且能让小白听懂。这里的问题解决了，那在我们搭建的项目中<code>pom</code>和<code>jar</code>两者的关系又是什么呢😟？</p></blockquote><h3 id="项目中pom和jar两者的关系又是什么？"><a href="#项目中pom和jar两者的关系又是什么？" class="headerlink" title="项目中pom和jar两者的关系又是什么？"></a>项目中<code>pom</code>和<code>jar</code>两者的关系又是什么？</h3><p>刘少说的是<code>jar</code>是可以运行的项目，而<code>pom</code>项目不需要写Java代码，所以创建项目后<code>src</code>文件夹可以删除，而<code>pom</code>项目也不执行任何代码，只是为了聚合工程或传递依赖用的。</p><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><h3 id="父项目"><a href="#父项目" class="headerlink" title="父项目"></a>父项目</h3><h4 id="shop-parent"><a href="#shop-parent" class="headerlink" title="shop-parent"></a>shop-parent</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--当前为springboot项目--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.shop.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shop-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span><span class="comment">&lt;!--当前项目为pom项目--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring-cloud.version 要找到对应的版本Greenwich.SR1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--版本仲裁--&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    </span><br></pre></td></tr></table></figure><h3 id="子项目"><a href="#子项目" class="headerlink" title="子项目"></a>子项目</h3><h4 id="eureka-server"><a href="#eureka-server" class="headerlink" title="eureka-server"></a>eureka-server</h4><p><img src="https://s2.loli.net/2022/03/07/acGsFtLXnHQP7b3.png" alt="image-20220307213721670"></p><p>当我们在父项目<code>shop-parent [pom]</code>下创建子项目时，父项目<code>pom.xml</code>中就会自动添加依赖，而子项目的<code>pom.xml</code>中也不需要写<code>spring boot</code>相关的依赖，由父项目传递相应的依赖（子承父业👶🧔）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启服务中心--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="application-yml"><a href="#application-yml" class="headerlink" title="application.yml"></a>application.yml</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="comment"># 配置端口</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8761</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">  <span class="comment"># 应用实例主机名</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="comment"># 是否从Eureka获取注册信息</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 是否向注册中心注册自己</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="comment"># Eureka服务器的地址，类型为HashMap，缺省的Key为 defaultZone；缺省的Value为http://localhost:8761/eureka</span></span><br><span class="line">      <span class="comment"># 如果服务注册中心为高可用集群时，多个注册中心地址以逗号分隔。 </span></span><br><span class="line">      <span class="attr">defualtZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka</span></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/zyon/p/11023750.html">Spring Cloud Eureka 之常用配置解析</a></p><h5 id="EurekaServerApp（服务注册与发现中心）"><a href="#EurekaServerApp（服务注册与发现中心）" class="headerlink" title="EurekaServerApp（服务注册与发现中心）"></a>EurekaServerApp（服务注册与发现中心）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> <span class="comment">//springboot启动类</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">//将项目作为SpringCloud中的注册中心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EurekaServerApp</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EurekaServerApp.class,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>刚写完这些又去刷手机了，罪过罪过，还是要控制住自己，以上的是eureka.server项目中基本的配置，简单几个文件里就有好多迷惑的地方（真是欠的债都要慢慢还呀😩），简单说一下其中的困惑，慢慢去百度解决吧。</p><p>父项目和子项目中<code>pom</code>配置与依赖还好，说是工作后不用自己写（希望吧😕就业压力山大），而其中<code>application.yml</code>的用处以及和之前的内容还有迷惑的地方，还有就是<code>EurekaServerApp</code>里面的两个注解，虽然知道他的用法，但是知道地详细点也没坏处（注解还得好好复习😵知其然还要知其所以然）</p></blockquote><h4 id="application-yml的用处"><a href="#application-yml的用处" class="headerlink" title="application.yml的用处"></a>application.yml的用处</h4><p>在<code>yml</code>之前使用最多的配置文件形式是<code>xml</code>和<code>properties</code>文件。<code>xml</code>文件太过繁琐，看过的人都知道，想要新加一个配置节点的话还需要包含在<code>&lt;&gt;</code>标签里；而<code>properties</code>配置文件没有了标签，不过当你的配置有很多层级的时候，写完之后你会发现会有大量重复的代码。而<code>yml/yaml</code>文件结合了两者的优势，当你新增节点配置的时候，不需要标签，在写多层级配置的时候也不会产生重复代码。</p><h4 id="EurekaServerApp注解"><a href="#EurekaServerApp注解" class="headerlink" title="EurekaServerApp注解"></a>EurekaServerApp注解</h4><p>在这里就多说了<a href="https://dpool110.github.io/2022/03/07/EurekaServerApp%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/">看这里</a></p><h4 id="config-server"><a href="#config-server" class="headerlink" title="config-server"></a>config-server</h4>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringCloud </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题</title>
      <link href="/2022/02/28/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/02/28/Java%E5%90%8E%E7%AB%AF/%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>graph TD<br>a(用户发起请求)–&gt;b(zuulControlelr)<br>b–&gt;c(zuulServlet)<br>c–&gt;d(zuulRunner)<br>d–&gt;e(zuulRunner调用FilterProcessor执行各种Filter)<br>e–&gt;f(FilterProcessor通过FilterLoader加载Filter)<br>f–&gt;g(init初始化,pre前置Filter,router路由Filter,post后置Filter,error异常Filter)<br>g–&gt;h(将执行结果返回)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">a(用户发起请求)--&gt;b(zuulControlelr)</span><br><span class="line">b--&gt;c(zuulServlet)</span><br><span class="line">c--&gt;d(zuulRunner)</span><br><span class="line">d--&gt;e(zuulRunner调用FilterProcessor执行各种Filter)</span><br><span class="line">e--&gt;f(FilterProcessor通过FilterLoader加载Filter)</span><br><span class="line">f--&gt;g(init初始化,pre前置Filter,router路由Filter,post后置Filter,error异常Filter)</span><br><span class="line">g--&gt;h(将执行结果返回)</span><br></pre></td></tr></table></figure><h2 id="当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么"><a href="#当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么" class="headerlink" title="当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么?"></a>当你的浏览器中地址栏输入并回车的一瞬间到页面能够展示回来，经历了什么?</h2><h2 id="网站是如何访问的"><a href="#网站是如何访问的" class="headerlink" title="网站是如何访问的?"></a>网站是如何访问的?</h2><ol><li>输入一个域名</li><li>检查本机下C:\Windows\System32\drivers\etc\hosts配置文件下有没有这个域名映射<ol><li>有直接返回对应的ip地址，这个地址中，有我们需要访问的web程序，可以直接访问(127.0.0.1 “域名”)</li><li>没有就去DNS服务器找，找到就返回，找不着就返回找不到</li></ol></li></ol><p><img src="https://s2.loli.net/2021/12/23/QMAqWFmNs9uUaOe.png"></p><h2 id="构造器Constructor是否可被override"><a href="#构造器Constructor是否可被override" class="headerlink" title="构造器Constructor是否可被override?"></a>构造器Constructor是否可被override?</h2><p>Constructor不能被继承，所以Constructor也就不能被override。每一个类必须有自己的构造函数，负责构造自己这部分的构造。子类不会覆盖父类的构造函数，相反必须负责在一开始调用父类的构造函数。</p><p>Java在构造实例时的顺序是这样的：</p><p>1、分配对象空间，并将对象中成员初始化为0或者空，java不允许用户操纵一个不定值的对象。</p><p>2、执行属性值的显式初始化 　　</p><p>3、执行构造器 　　</p><p>4 、将变量关联到堆中的对象上</p><p>而执行构造器的步骤有可以分为以下几步：</p><p>1、Bind构造器的参数</p><p>2、如果显式的调用了this，那就递归调用this构造器然后跳到步骤5</p><p>3、递归调用显式或者隐式的父类构造器，除了Object以外，因为它没有父类</p><p>4、执行显式的实例变量初始化（也就是上边的流程中的第二步，调用返回以后执行，</p><p>这个步骤相当于在父构造器执行后隐含执行的，看样子像一个特殊处理）</p><p>三、构造器不可被orerride（why）</p><p>其实你只需要记住一句话：构造器不是方法，那么用来修饰方法特性的所有修饰符都不能用来修饰构造器（并不等与构造器具备这些特性，虽然不能用static修饰构造器，但它却有静态特性）构造器只能用 public private protected这三个权限修饰符，且不能有返回语句。</p><h2 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h2><p><strong>重载</strong>： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同</p><p><strong>重写</strong>： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法</p><h2 id="String-为什么是不可变的-StringBuffer、StringBuilder为什么是可变的？"><a href="#String-为什么是不可变的-StringBuffer、StringBuilder为什么是可变的？" class="headerlink" title="String 为什么是不可变的?StringBuffer、StringBuilder为什么是可变的？"></a>String 为什么是不可变的?StringBuffer、StringBuilder为什么是可变的？</h2><p>String类中有一个char数组，并且这个char数组是被final修饰的。因为数组一旦创建长度不可变。并且被final修饰的引用一旦指向某个对象之后，不可在指向其它对象，所以String是不可变的。    StringBuffer、StringBuilder内部实际上是一个char[ ]数组，这个char[ ]数组没有被final修饰，StringBuffer和StringBulider的初始化容量应该为16，当存满之后会进行扩容，底层调用了数组拷贝的方法：System.arraycopy()…扩容的，所以StringBuffer/StringBuilder适用于字符串的频繁拼接操作，并且StringBuffer是线程安全的，StringBuilder是非线程安全的。</p><h2 id="String、StringBuffer-和-StringBuilder-的区别是什么"><a href="#String、StringBuffer-和-StringBuilder-的区别是什么" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别是什么?"></a>String、StringBuffer 和 StringBuilder 的区别是什么?</h2><p><strong>可变性：</strong>String类中使用字符数组保存字符串，<code>private final char value[]</code>，所以string对象是不可变的。<br>StringBuilder与StringBuffer都继承<strong>AbstractStringBuilder</strong>类，在AbstractStringBuilder中也是使用字符数组保存字符串，<code>char[] value</code>，所以这两种对象都是可变的。</p><p><strong>线程安全性：</strong> String中的对象是不可变的，也就可以理解为常量，所以线程安全；<br><strong>AbstractStringBuilder是StringBuilder与StringBuffer的公共父类</strong>，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。<br>StringBuffer对方法加了同步锁或者<strong>对调用的方法加了同步锁</strong>，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</p><p><strong>性能</strong>：每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder相比使用StringBuffer仅能获得10%~15%左右的性能提升，但却要冒多线程的不安全。<br>总结：<strong>如果数据较少的情况下：多线程和单线程都可以使用String对象；但数据较多时，单线程操作字符串缓冲区使用StringBuilder，多线程操作字符串缓冲区使用StringBuffer。</strong></p><h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p><strong>自动装箱</strong>就是自动将基本数据类型转化为包装器类型；<br><strong>自动拆箱</strong>就是自动将包装器类型转化为基本数据类型。</p><h2 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h2><p><strong>相同点：</strong></p><p>1、都可以定义属性和方法</p><p>2、都是特殊的类，都需要子类来操作具体的逻辑</p><p>3、都没有抽象方法</p><p>4、都不能创建对象</p><p>5、都可以利用多态操作数据</p><p>6、子类必须实现里面的抽象方法</p><p>7、java1.8以后，都可以拥有带方法体的方法</p><p><strong>不同点：</strong></p><p>1、接口<strong>可以被子类实现</strong>，但是抽象类由于java本身的特性<strong>只能单继承</strong>；</p><p>2、抽象类的方法，可以用protect<strong>修饰</strong>，接口只能是public </p><p>3、抽象类可以拥有自己的<strong>构造</strong>，接口不能拥有</p><p>4、接口之间可以被<strong>多继承</strong>，抽象类只能<strong>单继承</strong></p><p>5、java1.8以后接口可以拥有<strong>default修饰的方法体</strong>，还有<strong>stastic静态方法体</strong>，<strong>抽象类没有</strong></p><p><strong>总结：</strong></p><p>抽象类和接口<strong>两者都不能被实例化</strong>，<u>接口就是抽象类的一种特殊情况</u>。</p><h2 id="构造方法有哪些特性？"><a href="#构造方法有哪些特性？" class="headerlink" title="构造方法有哪些特性？"></a>构造方法有哪些特性？</h2><p>1.名字与类名<strong>相同</strong>。</p><p>2.<strong>没有返回值，但不能用 void 声明构造函数</strong>。</p><p>3.<strong>生成类的对象时自动执行</strong>，无需调用。</p><h2 id="1在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#1在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="1在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>1在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h2><p>帮助子类做初始化工作</p><h2 id="与-equals区别"><a href="#与-equals区别" class="headerlink" title="== 与 equals区别"></a>== 与 equals区别</h2><p>==号在比较基本数据类型时比较的是值，而用==号比较两个对象时比较的是两个对象的地址值； </p><p>equals()方法存在于 Object 类中，默认效果和==号的效果一样，也是比较的地址值，然而，Java 提供的所有类中， 绝大多数类都重写了 equals()方法，比如 string，integer 等，重写后的 equals()方法一般都是比较两个对象的值 。 </p><h2 id="你重写过-hashcode-和-equals-么，为什么重写-equals-时必须重写-hashCode-方法？"><a href="#你重写过-hashcode-和-equals-么，为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？"></a>你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？</h2><ol><li>使用hashcode方法<strong>提前校验</strong>，可以<strong>避免</strong>每一次比对都<strong>调用equals方法</strong>，提高效率</li><li><strong>保证是同一个对象</strong>，如果重写了equals方法，而没有重写hashcode方法，<strong>会出现equals相等的对象，hashcode不相等的情况</strong>，重写hashcode方法就是为了避免这种情况的出现。</li></ol><h2 id="线程有哪些基本状态-并描述每种状态"><a href="#线程有哪些基本状态-并描述每种状态" class="headerlink" title="线程有哪些基本状态,并描述每种状态?"></a>线程有哪些基本状态,并描述每种状态?</h2><ol><li>**初始(NEW)**：新创建了一个线程对象，但还没有调用start()方法。</li><li>**运行(RUNNABLE)**：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）。就绪状态的线程在获得CPU时间片后变为运行中状态（running）。</li><li>**阻塞(BLOCKED)**：表示线程阻塞于锁。</li><li>**等待(WAITING)**：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>**超时等待(TIMED_WAITING)**：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li>**终止(TERMINATED)**：表示该线程已经执行完毕。</li></ol><h2 id="final-关键字修饰这三个地方：变量、方法、类，会有什么作用"><a href="#final-关键字修饰这三个地方：变量、方法、类，会有什么作用" class="headerlink" title="final 关键字修饰这三个地方：变量、方法、类，会有什么作用"></a>final 关键字修饰这三个地方：变量、方法、类，会有什么作用</h2><ol><li><strong>final修饰类</strong></li></ol><p> <strong>final类不能被继承</strong>，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，<strong>类的实现细节不允许改变</strong>，并且确信这个<strong>类不会载被扩展</strong>，那么就设计为final类。<br>2. <strong>final修饰方法</strong><br>如果一个类不允许其子类覆盖某个方法（即<strong>不允许被子类重写</strong>），则可以把这个方法声明为final方法。使用final方法的原因有二：把方法锁定，防止任何继承类修改它的意义和实现。高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。<br>3. <strong>final修饰变量(常量)</strong><br>用final修饰的成员变量表示常量，<strong>值一旦给定就无法改变</strong>！final修饰的变量有三种：<strong>静态变量、实例变量和局部变量</strong>，分别表示三种类型的常量。一旦给final变量初值后，值就不能再改变了。另外，final变量定义的时候，可以<strong>先声明，而不给初值</strong>，这种变量也称为final空白，无论什么情况，编译器都确保空白final<strong>在使用之前必须被初始化</strong>。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</p><h2 id="Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>Java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用<strong>transient关键字修饰</strong>。<br>transient关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被transient修饰的变量值不会被持久化和恢复。<strong>transient只能修饰变量，不能修饰类和方法。</strong></p><h2 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span>  <span class="operator">=</span> input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> input.readLine();</span><br></pre></td></tr></table></figure><h2 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h2><p>因为字节流转换成字符流，过程很耗时。如果你必须要使用字符流，但你只得到了字节流，就要经历这个转换，其中编码也容易出问题。所以就直接把字符流单独作为了一个部分，从而提高使用字符流的效率。</p><h2 id="描述深拷贝和浅拷贝"><a href="#描述深拷贝和浅拷贝" class="headerlink" title="描述深拷贝和浅拷贝"></a>描述深拷贝和浅拷贝</h2><p><strong>浅拷贝：</strong>被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，<strong>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象</strong>。<br><strong>深拷贝：</strong>被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向被复制过的新对象.而不再是原有的那些被引用的对象。换言之，<strong>深拷贝把要复制的对象所引用的对象都复制了一遍</strong></p><h2 id="说说-amp-和-amp-amp-的区别。"><a href="#说说-amp-和-amp-amp-的区别。" class="headerlink" title="说说&amp;和&amp;&amp;的区别。"></a>说说&amp;和&amp;&amp;的区别。</h2><p> &amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。<br>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式</p><h2 id="final-finally-finalize的区别。"><a href="#final-finally-finalize的区别。" class="headerlink" title="final, finally, finalize的区别。"></a>final, finally, finalize的区别。</h2><ol><li>如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在new一个对象时初始化（即只能在声明变量或构造器或代码块内初始化），而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能覆盖(重写)。</li><li>finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收。</li><li>finally为区块标志，用于try语句中，表示必须运行的区块部分</li></ol><h2 id="ArrayList和Vector的区别"><a href="#ArrayList和Vector的区别" class="headerlink" title="ArrayList和Vector的区别"></a>ArrayList和Vector的区别</h2><p><a href="https://imgtu.com/i/bpTeKI"><img src="https://s4.ax1x.com/2022/02/23/bpTeKI.png" alt="bpTeKI.png"></a></p><h2 id="ArrayList的扩容机制"><a href="#ArrayList的扩容机制" class="headerlink" title="ArrayList的扩容机制"></a>ArrayList的扩容机制</h2><p>ArrayList每次添加元素时都会<strong>检查是否需要扩容</strong>：ArrayList一次添加元素时，赋予ArrayList默认容量10，再往里面添加元素，添加元素前先检查当前元素个数是否已经<strong>达到容量上限</strong>，若是则先以<strong>1.5倍*原容量上限</strong>进行扩容再添加元素。</p><h2 id="HashMap和Hashtable的区别"><a href="#HashMap和Hashtable的区别" class="headerlink" title="HashMap和Hashtable的区别"></a>HashMap和Hashtable的区别</h2><p><strong>1、两者父类不同</strong><br><strong>HashMap</strong>是继承自<strong>AbstractMap</strong>类，而<strong>Hashtable</strong>是继承自<strong>Dictionary</strong>类。不过它们都实现了同时实现了map、Cloneable（可复制）、Serializable（可序列化）这三个接口。<br><strong>2、对外提供的接口不同</strong><br>Hashtable比HashMap多提供了elments() 和contains() 两个方法。<br>elments() 方法继承自Hashtable的父类Dictionnary。elements() 方法用于返回此Hashtable中的value的枚举。<br>contains()方法判断该Hashtable是否包含传入的value。它的作用与containsValue()一致。事实上，contansValue() 就只是调用了一下contains() 方法。<br><strong>3、对null的支持不同</strong><br>Hashtable：<strong>key和value都不能为null</strong>。<br>HashMap：<strong>key可以为null，但是这样的key只能有一个</strong>，因为必须保证key的唯一性；可以有多个key值对应的value为null。<br><strong>4、安全性不同</strong><br><strong>HashMap是线程不安全的</strong>，在多线程并发的环境下，可能会产生死锁等问题，因此需要开发人员自己处理多线程的安全问题。<br><strong>Hashtable是线程安全的</strong>，它的每个方法上都有synchronized 关键字，因此可直接用于多线程中。<br>虽然HashMap是线程不安全的，但是它的效率远远高于Hashtable，这样设计是合理的，因为大部分的使用场景都是单线程。当需要多线程操作的时候可以使用<strong>线程安全</strong>的<strong>ConcurrentHashMap</strong>。<br>ConcurrentHashMap虽然也是线程安全的，但是它的效率比Hashtable要高好多倍。因为ConcurrentHashMap使用了分段锁，并不对整个数据进行锁定。<br><strong>5、初始容量大小和每次扩充容量大小不同</strong><br><strong>6、计算hash值的方法不同</strong></p><h2 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h2><p><strong>List(对付顺序的好帮手)：</strong><br>List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</p><p><strong>Set(注重独一无二的性质):</strong><br>不允许重复的集合。不会有多个元素引用相同的对象。</p><p><strong>Map(用Key来搜索的专家):</strong><br>使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相<br>同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</p><h2 id="什么是线程死锁-如何避免线程死锁"><a href="#什么是线程死锁-如何避免线程死锁" class="headerlink" title="什么是线程死锁?如何避免线程死锁?"></a>什么是线程死锁?如何避免线程死锁?</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p><p>1、尽量使用 tryLock的方法，设置超时时间，超时可以退出防止死锁。 </p><p>2、尽量使用 Java.util.concurrent 并发类代替自己手写锁。 </p><p>3、尽量降低锁的使用粒度，尽量不要几个功能用同一把锁。 </p><p>4、尽量减少同步的代码块。 </p><h2 id="产生死锁的四个必要条件"><a href="#产生死锁的四个必要条件" class="headerlink" title="产生死锁的四个必要条件"></a>产生死锁的四个必要条件</h2><p><strong>互斥条件：</strong>进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。<br><strong>不可剥夺条件：</strong>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。<br><strong>请求与保持条件：</strong>进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。<br><strong>循环等待条件：</strong></p><h2 id="说说-sleep-方法和-wait-方法区别和共同点"><a href="#说说-sleep-方法和-wait-方法区别和共同点" class="headerlink" title="说说 sleep() 方法和 wait() 方法区别和共同点?"></a>说说 sleep() 方法和 wait() 方法区别和共同点?</h2><p><img src="https://s2.loli.net/2022/02/24/9MYkpWSV3lR5vms.png" alt="image-20220224104905303"></p><h2 id="现在有线程-T1、T2-和-T3。你如何确保-T2-线程在-T1-之后执行，并且-T3-线程在-T2-之后执行？"><a href="#现在有线程-T1、T2-和-T3。你如何确保-T2-线程在-T1-之后执行，并且-T3-线程在-T2-之后执行？" class="headerlink" title="现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？"></a>现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？</h2><p>可以利用<a href="https://so.csdn.net/so/search?q=Thread%E7%B1%BB&spm=1001.2101.3001.7020">Thread类</a>的join方法。</p><h2 id="jdk1-8之后的新特性"><a href="#jdk1-8之后的新特性" class="headerlink" title="jdk1.8之后的新特性?"></a>jdk1.8之后的新特性?</h2><p>1：支持函数式编程 Lambda 表达式</p><p>2：方法引用</p><p>3：集合的stream处理</p><p>最大的变化是:jdk的内存结构发生重大变化永久代弃用，class信息使用本地内存，存储常量池移动到堆当中</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>可以通过 class 字节码文件对象，操作类的成员(构造方法，成员变量，成员方法)，动态获取类的信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。 </p><h2 id="反射的作用和应用场景"><a href="#反射的作用和应用场景" class="headerlink" title="反射的作用和应用场景"></a>反射的作用和应用场景</h2><p>可以通过配置文件来动态配置和加载类，以实现软件工程理论里所提及的类与类，模块与模块之间的解耦</p><h2 id="反射获取文件对象的三种方式"><a href="#反射获取文件对象的三种方式" class="headerlink" title="反射获取文件对象的三种方式"></a>反射获取文件对象的三种方式</h2><p>1、Class.forName(类的全限定名) </p><p>2、类名.class </p><p>3、对象.getClass()</p><h2 id="反射中的常用类"><a href="#反射中的常用类" class="headerlink" title="反射中的常用类"></a>反射中的常用类</h2><p>1、Class 类:反射的核心类，可以获取类的属性，方法等内容信息 </p><p>2、Constractor ：构造方法</p><p>3、Method： 成员方法</p><p>4、Field；</p><h2 id="谈一下hashMap中put是如何实现的？"><a href="#谈一下hashMap中put是如何实现的？" class="headerlink" title="谈一下hashMap中put是如何实现的？"></a>谈一下hashMap中put是如何实现的？</h2><p>1、先将key和value封装到Node节点中<br>2、底层会调用key的hashcode()方法，通过hash函数将hash值转换为数组下标，下标位置上如果没有任何元素，就把该Node添加到该位置上（该下标处）如果该下标处对应的位置上已经存在元素或链表（多于一个元素变成链表），那么就会拿着新节点的key与链表上的每一个人节点中的key进行equals。1、 如果所有对比（equals)都返回false,那么这个新节点将会被添加到链表的尾部。（大于8个就会转换成红黑树）2、 如果其中有一个对比（equals)返回true，那么这个节点上的value将会被新节点的value覆盖。</p><h2 id="谈一下HashMap的底层原理是什么？"><a href="#谈一下HashMap的底层原理是什么？" class="headerlink" title="谈一下HashMap的底层原理是什么？"></a>谈一下HashMap的底层原理是什么？</h2><p>hashmap底层是使用数组+链表+红黑树实现的</p><h2 id="谈一下hashMap中什么时候需要进行扩容，扩容resize-又是如何实现的？"><a href="#谈一下hashMap中什么时候需要进行扩容，扩容resize-又是如何实现的？" class="headerlink" title="谈一下hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？"></a>谈一下hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的？</h2><p>1.初始化数组table</p><p>2.当数组table的size达到阙值时即++size &gt; load factor * capacity 时，也是在putVal函数中</p><p><strong>实现过程：(细讲)</strong></p><p>1.通过判断旧数组的容量是否大于0来判断数组是否初始化过</p><p>否：进行初始化</p><p>判断是否调用无参构造器，</p><p>是:使用默认的大小和阙值</p><p>否:使用构造函数中初始化的容量，当然这个容量是经过tableSizefor计算后的2的次幂数</p><p>是，进行扩容，扩容成两倍(小于最大值的情况下)，之后在进行将元素重新进行与运算复制到新的散列表中</p><p>概括的讲：扩容需要重新分配一个新数组，新数组是老数组的2倍长，然后遍历整个老结构，把所有的元素挨个重新hash分配到新结构中去。</p><h2 id="谈一下hashMap中get是如何实现的？"><a href="#谈一下hashMap中get是如何实现的？" class="headerlink" title="谈一下hashMap中get是如何实现的？"></a>谈一下hashMap中get是如何实现的？</h2><p>对key的hashCode进行hashing，与运算计算下标获取bucket位置，如果在桶的首位上就可以找到就直接返回，否则在树中找或者链表中遍历找，如果有hash冲突，则利用equals方法去遍历链表查找节点。</p><h2 id="为什么不直接将key作为哈希值而是与高16位做异或运算？"><a href="#为什么不直接将key作为哈希值而是与高16位做异或运算？" class="headerlink" title="为什么不直接将key作为哈希值而是与高16位做异或运算？"></a>为什么不直接将key作为哈希值而是与高16位做异或运算？</h2><p>因为数组位置的确定用的是与运算，仅仅最后四位有效，设计者将key的哈希值与高16为做异或运算使得在做&amp;运算确定数组的插入位置时，此时的低位实际是高位与低位的结合，增加了随机性，减少了哈希碰撞的次数。</p><h2 id="为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？"><a href="#为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？" class="headerlink" title="为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？"></a>为什么是16？为什么必须是2的幂？如果输入值不是2的幂比如10会怎么样？</h2><h2 id="谈一下当两个对象的hashCode相等时会怎么样？"><a href="#谈一下当两个对象的hashCode相等时会怎么样？" class="headerlink" title="谈一下当两个对象的hashCode相等时会怎么样？"></a>谈一下当两个对象的hashCode相等时会怎么样？</h2><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。这个时候要理解根据hashcode来划分的数组，如果数组的坐标相同，则进入链表这个数据结构中了，一般的添加都在最前面，也就是和数组下标直接相连的地方，链表长度到达8的时候，jdk1.8上升为红黑树</p><h2 id="请解释一下HashMap的参数loadFactor，它的作用是什么？"><a href="#请解释一下HashMap的参数loadFactor，它的作用是什么？" class="headerlink" title="请解释一下HashMap的参数loadFactor，它的作用是什么？"></a>请解释一下HashMap的参数loadFactor，它的作用是什么？</h2><p>负载因子表示HashMap的拥挤程度，影响hash操作到同一个数组位置的概率。默认负载因子等于0.75，可以自定义负载因子。当HashMap里面的元素已经达到数组长度的75%时，表示HashMap太挤了，需要扩容，扩容后的数组大小是原数组的2倍</p><h2 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h2><p>超过阙值会进行扩容操作，扩容后的数组大小是原数组的2倍，将原来的元素重新哈希放入到新的散列表中去。<br><del>传统hashMap的缺点(为什么引入红黑树？)：</del><br><del>HashMap和ConcurrentHashMap的区别</del><br><del>平时在使用HashMap时一般使用什么类型的元素作为Key？</del><br><del>volatile关键字</del></p><h2 id="tomcat调优"><a href="#tomcat调优" class="headerlink" title="tomcat调优"></a>tomcat调优</h2><p>1.tomcat默认的线程创建方式,是一次请求,创建一个新的线程来处理优化方案,可以配置线程池来创建和管理线程,可以设置线程数量</p><p>2.tomcat默认的连接处理方式是BIO,阻塞的IO,容易造成客户端堵塞优化方案：使用http11Nio协议来进行连接的处理</p><p>3:因为tomcat是基于jvm的,所以应该对jvm的启动参数进行调优(堆栈内存、垃圾收集器)</p><h2 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h2><p><strong>1、url可见性：</strong></p><p>get，参数url可见；</p><p>post，url参数不可见</p><p><strong>2、数据传输上：</strong></p><p>get，通过拼接url进行传递参数；</p><p>post，通过body体传输参数</p><p><strong>3、缓存性：</strong></p><p>get请求是可以缓存的</p><p>post请求不可以缓存</p><p><strong>4、后退页面的反应</strong></p><p>get请求页面后退时，不产生影响</p><p>post请求页面后退时，会重新提交请求</p><p><strong>5、传输数据的大小</strong></p><p>get一般传输数据大小不超过2k-4k（根据浏览器不同，限制不一样，但相差不大）</p><p>post请求传输数据的大小根据php.ini 配置文件设定，也可以无限大。</p><p><strong>6、安全性</strong></p><p>这个也是最不好分析的，原则上post肯定要比get安全，毕竟传输参数时url不可见，但也挡不住部分人闲的没事在那抓包玩。安全性个人觉得是没多大区别的，防君子不防小人就是这个道理。对传递的参数进行加密，其实都一样。</p><h2 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h2><p><strong>地址栏</strong><br>转发：不变，不会显示出转向的地址<br>重定向：会显示转向之后的地址</p><p><strong>请求</strong><br>重定向：至少提交了两次请求</p><p><strong>数据</strong><br>转发：对request对象的信息不会丢失，因此可以在多个页面交互过程中实现请求数据的共享<br>重定向：request信息将丢失</p><p><strong>原理</strong><br>转发：是在服务器内部控制权的转移，是由服务器区请求，客户端并不知道是怎样转移的，因此客户端浏览器的地址不会显示出转向的地址。<br>重定向：是服务器告诉了客户端要转向哪个地址，客户端再自己去请求转向的地址，因此会显示转向后的地址，也可以理解浏览器至少进行了两次的访问请求。</p><h2 id="JSP-九大内置对象"><a href="#JSP-九大内置对象" class="headerlink" title="JSP 九大内置对象"></a>JSP 九大内置对象</h2><p>request：负责得到客户端请求的信息，对应类型：javax.servlet.http.HttpServletRequest</p><p>response:负责向客户端发出响应，对应类型：javax.servlet.http.HttpServletResponse</p><p>session:负责保存同一客户端一次会话过程中的一些信息，对应类型：javax.servlet.http.httpsession </p><p>out：负责管理对客户端的输出，对应类型：javax.serlvet.jsp.jspwriter</p><p>application:表示整个应用环境的信息，对应类型：javax.servlet.servletcontext</p><p>config:表示 ServletConfig，对应类型：javax.servlet.servletconfig </p><p>exception:表示页面中发生的异常，可以通过它获得页面异常信息，对应类型：java.lang.exception </p><p>pagecontext:表示这个 JSP 页面上下文，对应类型：javax.servlet.jsp.pagecontext </p><p>page:表示当前 JSP 页面本身。</p><h2 id="JSP和Servlet是什么关系"><a href="#JSP和Servlet是什么关系" class="headerlink" title="JSP和Servlet是什么关系"></a>JSP和Servlet是什么关系</h2><p>Cookie和Session的的区别<br>JDBC访问数据库的基本步骤是什么？<br>说说preparedStatement和Statement的区别<br>数据库连接池的原理。为什么要使用连接池。</p><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p><h2 id="数据库事务的四个特性"><a href="#数据库事务的四个特性" class="headerlink" title="数据库事务的四个特性"></a>数据库事务的四个特性</h2><p><strong>原子性：</strong>一个事物是应用中不可再分的最小执行体，它们应该是一个整体，要么全部成功，要么全部失败。<br><strong>一致性：</strong>一个事务的执行是从一个一致性状态，变为另一个一致性状态。<br><strong>隔离性：</strong>一个执行的事务，不能被其他事务所干扰<br><strong>持久性：</strong>事务一旦提交，对数据的任何改变应该是永久性的，即使其他操作或故障都不能进行干扰。</p><h2 id="drop-delete与truncate的区别"><a href="#drop-delete与truncate的区别" class="headerlink" title="drop,delete与truncate的区别"></a>drop,delete与truncate的区别</h2><p><strong>drop：</strong>drop table 表名</p><p>   删除内容和定义，并释放空间。执行drop语句，将使此表的结构一起删除。</p><p><strong>truncate (清空表中的数据)：</strong>truncate table 表名</p><p>​    删除内容、释放空间但不删除定义(也就是保留表的数据结构)。与drop不同的是,只是清空表数据而已。</p><p>​    truncate不能删除行数据，虽然只删除数据，但是比delete彻底，它只删除表数据。</p><p><strong>delete：</strong>delete from 表名 （where 列名 = 值）</p><p>​    与truncate类似，delete也只删除内容、释放空间但不删除定义；但是delete即可以对行数据进行删除，也可以对整表数据进行删除。</p><h2 id="sql-怎么调优-索引命中怎么知晓？（重点）"><a href="#sql-怎么调优-索引命中怎么知晓？（重点）" class="headerlink" title="sql 怎么调优,索引命中怎么知晓？（重点）"></a>sql 怎么调优,索引命中怎么知晓？（重点）</h2><p>使用 explain 关键字查看 sql 的执行计划,可以看到该 sql 的索引命中情况、索引命中类型、命中率等相关的信息,通过这种方式可以对 sql 语句进行调优,对关键查询的条件创建索引以及注意一下 sql 语句的用法尽量不使用 like,尽量避免在某一列上进行运算不使用 in not in 使用<br>exist not exist 等等代替</p><h2 id="什么是-Mybatis"><a href="#什么是-Mybatis" class="headerlink" title="什么是 Mybatis"></a>什么是 Mybatis</h2><p>Mybatis 是一个半 ORM（对象关系映射）框架，它内部封装了 JDBC，开发时只需要关注 SQL 语句本身，不需要花费精力去处理加载驱动、创建连接、创建 statement 等繁杂的过程。程序员直接编写原生态 sql，可以严格控制 sql 执行性能，灵活度高</p><h2 id="mybatis的优缺点"><a href="#mybatis的优缺点" class="headerlink" title="mybatis的优缺点"></a>mybatis的优缺点</h2><p>Mybaits 的优点： </p><p><strong>基于 SQL 语句编程，相当灵活</strong>，不会对应用程序或者数据库的现有设计造成任何影响，SQL 写在 XML 里，<strong>解除 sql 与程序代码的耦合</strong>，便于统一管理；提供 XML 标签，<strong>支持编写动态 SQL 语句</strong>，并可重用。 </p><p>MyBatis 框架的缺点： </p><p>SQL 语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写 SQL 语句的功底有一定要求。</p><h2 id="在MyBatis中-和-的区别是什么？"><a href="#在MyBatis中-和-的区别是什么？" class="headerlink" title="在MyBatis中,#{}和${}的区别是什么？"></a>在MyBatis中,#{}和${}的区别是什么？</h2><ol><li>#{}是<strong>占位符</strong>预编译处理，${}是<strong>连接符</strong>字符串替换。</li><li>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；</li><li>Mybatis在处理$ {}时，就是把${}替换成变量的值。</li><li>使用#{}可以有效的防止SQL注入，提高系统安全性。</li></ol><h2 id="mybatis分页如何处理"><a href="#mybatis分页如何处理" class="headerlink" title="mybatis分页如何处理"></a>mybatis分页如何处理</h2><p>mybatis 分页查询有两种方案： </p><p>1、可以通过 <strong>limit 关键字拼接 sql 语句</strong>，需要两个参数，第一个参数开始条数，第二个参数查询个数； </p><p>2、可以通过 <strong>pageHelper 插件</strong>实现</p><h2 id="框架是什么东西"><a href="#框架是什么东西" class="headerlink" title="框架是什么东西"></a>框架是什么东西</h2><p>框架是一组抽象封装的设计,是一种软件半成品,程序员必须得遵守框架的api,配置配置文件和遵循代码规范,极高的提高了开发效率</p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>Mybatis仅支持<strong>association关联对象</strong>和<strong>collection关联集合对象</strong>的延迟加载，association指的就是<strong>一对一</strong>，collection指的就是<strong>一对多</strong>查询。</p><p>在Mybatis配置文件中，可以配置是否启用延迟加载<code>lazyLoadingEnabled=true/false</code>。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，</p><p>比如调用a.getB().getName()，<br>拦截器invoke()方法发现a.getB()是null值，<br>那么就会单独发送事先保存好的查询<br>关联B对象的sql，把B查询上来，然后调用a.setB(b)，<br>于是a的对象b属性就有值了，<br>接着完成a.getB().getName()方法的调用。<br>这就是延迟加载的基本原理。</p><h2 id="简单的说一下MyBatis-的一级缓存和二级缓存"><a href="#简单的说一下MyBatis-的一级缓存和二级缓存" class="headerlink" title="简单的说一下MyBatis 的一级缓存和二级缓存"></a>简单的说一下MyBatis 的一级缓存和二级缓存</h2><p>Mybatis 首先去缓存中查询结果集，如果没有则查询数据库，如果有则从缓存取出返回结果集就不走数据库。</p><p>Mybatis 的二级缓存即查询缓存，它的<strong>作用域</strong>是一个 <strong>mapper 的 namespace</strong>，即在同一个 namespace 中查询 sql 可以从缓存中获取数据。二级缓存是可以跨 SqlSession 的。</p><h2 id="Mybatis中如何执行批处理？"><a href="#Mybatis中如何执行批处理？" class="headerlink" title="Mybatis中如何执行批处理？"></a>Mybatis中如何执行批处理？</h2><p>需要在全局配置文件或获取sqlSession时设置执行类型为<code>BATCH</code></p><h2 id="mybatis-的-mapper-代理底层怎么实现"><a href="#mybatis-的-mapper-代理底层怎么实现" class="headerlink" title="mybatis 的 mapper 代理底层怎么实现?"></a>mybatis 的 mapper 代理底层怎么实现?</h2><p> mybatis 是先通过 xml 解析,反射,最后通过动态代理机制来生成 mapper 接口的实现类对象<br>namespace 的值等于 mapper 接口的类路径、sql 标签的 id 值等于 mapper 接口的方法名,生成的<br>Mapper 代理对象的命名为接口的首字母小写。</p><h2 id="查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a>查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</h2><p>from、join、where、group by、having、select distinct、order by、limit…</p><h2 id="数据库调优（重点）"><a href="#数据库调优（重点）" class="headerlink" title="数据库调优（重点）"></a>数据库调优（重点）</h2><p>数据库结构优化设计数据库的时候,要预估单表的峰值,因为以Mysql为例,当单表的数据超过千万条,查询速度就特别缓慢了,这里就需要对数据库进行分库分表（数据分片）,为了提高查询和写入性能,mysql可以采取主从结构主数据库采用innodb引擎,从数据库采用myIsam引擎,主从之间通过监听主数据库的binlog日志来完成数据一致。</p><p>从服务器有两个线程，一个是IO线程，一个是sql线程，IO线程负责读取主mysql服务器的binlog日志，把读取到的日志放入到中继日志中，sql线程负责读取中继日志，并转成具体的操作，实现数据的一致性。</p><p>SQL优化,本质是通过创建索引,使用explain关键字,查询索引命中情况,对sql进行调优</p><p>使用缓存层,预先对经常常用的数据库数据进行缓存,减少数据库的压力提高数据库性能</p><h2 id="spring-的优点"><a href="#spring-的优点" class="headerlink" title="spring 的优点"></a>spring 的优点</h2><p>spring 属于低侵入式设计，代码的污染极低； </p><p>spring 的 DI 机制将对象之间的依赖关系交由框架处理，减低组件的耦合性； </p><p>Spring 提供了 AOP 技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。 </p><p>spring 对于主流的应用框架提供了集成支持。</p><h2 id="Spring的核心"><a href="#Spring的核心" class="headerlink" title="Spring的核心"></a>Spring的核心</h2><p>IOC、AOP</p><h2 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h2><p>spring支持<strong>编程式事务管理</strong>和<strong>声明式事务管理</strong>两种方式。</p><h2 id="Spring-AOP是什么？"><a href="#Spring-AOP是什么？" class="headerlink" title="Spring AOP是什么？"></a>Spring AOP是什么？</h2><p>即<strong>面向切面编程</strong>，它将业务逻辑的各个部分进行隔离，使开发人员在编写业务逻辑时可以专心于核心业务，从而提高了开发效率。</p><h2 id="Spring-AOP中有哪些不同的通知类型"><a href="#Spring-AOP中有哪些不同的通知类型" class="headerlink" title="Spring AOP中有哪些不同的通知类型?"></a>Spring AOP中有哪些不同的通知类型?</h2><p>前置通知、环绕通知、后置通知、异常通知、最终通知</p><h2 id="Spring-AOP的底层是怎样实现的？"><a href="#Spring-AOP的底层是怎样实现的？" class="headerlink" title="Spring AOP的底层是怎样实现的？"></a>Spring AOP的底层是怎样实现的？</h2><p>1、JDK动态代理</p><p>2、CGLIB代理</p><h2 id="Spring-AOP-默认使用jdk动态代理还是cglib？"><a href="#Spring-AOP-默认使用jdk动态代理还是cglib？" class="headerlink" title="Spring AOP 默认使用jdk动态代理还是cglib？"></a>Spring AOP 默认使用jdk动态代理还是cglib？</h2><p>jdk动态代理</p><h2 id="SpringAOP的应用场景"><a href="#SpringAOP的应用场景" class="headerlink" title="SpringAOP的应用场景"></a>SpringAOP的应用场景</h2><p>1、日志记录</p><p>2、权限验证</p><p>3、效率检查（个人在代码上，喜欢用注解+切面，实现校验，redis分布式锁等功能）</p><p>4、事务管理（spring 的事务就是用AOP实现的）</p><h2 id="Spring中的常用注解-最少写10个"><a href="#Spring中的常用注解-最少写10个" class="headerlink" title="Spring中的常用注解(最少写10个)"></a>Spring中的常用注解(最少写10个)</h2><h2 id="SpringMVC常用注解-最少写5个以上"><a href="#SpringMVC常用注解-最少写5个以上" class="headerlink" title="SpringMVC常用注解(最少写5个以上)"></a>SpringMVC常用注解(最少写5个以上)</h2><p>@Controller、@RequestMapping、@Params、@Autowired、@Resource</p><p>事务的隔离级别 </p><p>读未提及（READ_UNCOMMITTED）</p><p>读未提及，该隔离级别允许脏读取，其隔离级别是最低的。换句话说，如果一个事务正在处理某一数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务；而以此同时，允许另一个事务也能够访问该数据。</p><p>读已提交（READ_COMMITTED）</p><p>读已提交是不同的时候执行的时候只能获取到已经提交的数据。 </p><p>这样就不会出现上面的脏读的情况了。 </p><p>可重复读（REPEATABLE_READ）</p><p>可重复读就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别禁止了不可重复读取和脏读，但是有可能出现幻读的数据。</p><p>串行化（SERIALIZABLE）</p><p>顺序读是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发。 </p><h2 id="spring-中-bean-的作用域"><a href="#spring-中-bean-的作用域" class="headerlink" title="spring 中 bean 的作用域"></a>spring 中 bean 的作用域</h2><p>scope 配置项有 5 个属性，用于描述不同的作用域。 </p><ol><li>singleton(单例) 使用该属性定义 Bean 时，IOC 容器仅创建一个 Bean 实例，IOC 容器每次返回的是同一个 Bean 实例。 </li><li>prototype（多例） 使用该属性定义 Bean 时，IOC 容器可以创建多个 Bean 实例，每次返回的都是一个新的实例。</li><li>request 该属性仅对 HTTP 请求产生作用，使用该属性定义 Bean 时，每次 HTTP 请求都会创建一个新的 Bean，适用于WebApplicationContext 环境。 </li><li>session 该属性仅用于 HTTP Session，同一个 Session 共享一个 Bean 实例。不同 Session 使用不同的实例。 </li><li>global-session 该属性仅用于 HTTP Session，同 session 作用域不同的是，所有的 Session 共享一个 Bean 实例。</li></ol><h2 id="Spring-的-IOC-原理"><a href="#Spring-的-IOC-原理" class="headerlink" title="Spring 的 IOC 原理"></a>Spring 的 IOC 原理</h2><p>IOC 就是控制反转，原来我们需要创建对象的，必须自己 new，但是现在有了 spring 容器，我们不需要再自己 new了，有两个好处，1)解耦2)统一管理对象。 </p><p>SpringIOC，用户只需要进行配置，容器会在容器中自动实例化依赖对象，并且是单例模式，直接通过@autowired 直接注入即可。</p><h2 id="spring-事务传播特性"><a href="#spring-事务传播特性" class="headerlink" title="spring 事务传播特性"></a>spring 事务传播特性</h2><p> （1）propagation_requierd：如果当前没有事务，就新建一个事务，如果已存在一个事务中，加入到这个事务中， </p><p>这是 Spring 默认的选择。 </p><p>（2）propagation_supports：支持当前事务，如果没有当前事务，就以非事务方法执行。 </p><p>（3）propagation_mandatory：使用当前事务，如果没有当前事务，就抛出异常。</p><p>（4）propagation_required_new：新建事务，如果当前存在事务，把当前事务挂起。 </p><h2 id="SpringMVC的流程？"><a href="#SpringMVC的流程？" class="headerlink" title="SpringMVC的流程？"></a>SpringMVC的流程？</h2><ol><li>用户发送请求到前端控制器DispatcherServlet</li><li>DispatcherServlet收到请求调用处理器映射器 HandlerMapping</li><li>HandlerMapping找到具体的处理器（通过xml 或者注解配置）最终能生成处理器对象以及处理器拦截器（如果有的情况下），一起返回给DispatcherServlet</li><li>DispatcherServlet调用HandlerAdapter（处理器适配器）</li><li>HandlerAdapter经过适配调用具体的处理器的某个方法（Handler/Controller）</li><li>Controller执行完成返回ModelAndView对象</li><li>HandlerAdapter将Controller返回的ModelAndView再返回给DispatcherServlet</li><li>DispatcherServlet将ModelAndView传给ViewReslover （视图解析器）</li><li>ViewReslover解析后返回具体的View（视图）</li><li>DispatcherServlet根据View进行渲染视图(也就是将模型数据填充到视图中)</li><li>DispatcherServlet响应用户</li></ol><h2 id="SpringMVC怎么样设定重定向和转发的？"><a href="#SpringMVC怎么样设定重定向和转发的？" class="headerlink" title="SpringMVC怎么样设定重定向和转发的？"></a>SpringMVC怎么样设定重定向和转发的？</h2><p>一般情况下,控制器方法返回字符串类型的值会被当成逻辑视图名处理。如果返回的字符串中带 forward: 或 redirect: 前缀时,SpringMVC会对他们进行特殊处理:将 forward: 和redirect: 当成指示符,其后的字符串作为 URL 来处理。</p><h2 id="SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？"><a href="#SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？" class="headerlink" title="SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？"></a>SpringMVC如何解决POST请求中文乱码问题，GET的又如何处理呢？</h2><p><strong>POST：</strong>在web.xml文件中配置字符编码过滤器。</p><p><strong>GET：</strong>修改tomcat配置文件、对request获取的参数重新进行编码</p><h2 id="SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解"><a href="#SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解" class="headerlink" title="SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解"></a>SpingMVC需要接受前台JSON字符串并注入到对象中需要使用什么注解</h2><p>@RequestBody</p><h2 id="Spring框架中用到了哪些设计模式"><a href="#Spring框架中用到了哪些设计模式" class="headerlink" title="Spring框架中用到了哪些设计模式"></a>Spring框架中用到了哪些设计模式</h2><ul><li>工厂模式：BeanFactory 就是简单工厂模式的体现，用来创建对象的实例； </li><li>单例模式：Bean 默认为单例模式。 </li><li>代理模式：Spring 的 AOP 功能用到了 JDK 的动态代理和 CGLIB 字节码生成技术；</li><li>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。 </li></ul><h2 id="什么是-Spring-Boot？-Spring-Boot特性"><a href="#什么是-Spring-Boot？-Spring-Boot特性" class="headerlink" title="什么是 Spring Boot？ Spring Boot特性"></a>什么是 Spring Boot？ Spring Boot特性</h2><p>SpringBoot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><p><strong>特性</strong></p><ul><li>能够快速的创建基于Spring的应用程序</li><li>能够直接运行（使用main方法的方式）启动内置的tomcat运行SpringBoot 程序，不需要进行部署</li><li>提供约定的 starter pom 来简化maven 的配置,让maven配置更加简单</li><li>SpringBoot添加一个依赖 自动配置其相关联的配置</li><li>SpringBoot 提供健康检查机制</li><li>基本可以完全不使用xml配置文件，采用注解进行配置</li></ul><h2 id="Spring-Boot的四大核心"><a href="#Spring-Boot的四大核心" class="headerlink" title="Spring Boot的四大核心"></a>Spring Boot的四大核心</h2><p><strong>自动配置</strong><br>     针对于spring应用和常见的功能，SpringBoot提供了自动相关配置</p><p><strong>起步依赖</strong><br>    你告诉SpringBoot 你需要什么功能,它就能够引入需要的依赖库</p><p><strong>Actuator</strong><br>    帮助我们了解SpringBoot内部信息</p><p><strong>命令行界面</strong><br>     Spring Boot 可选择的特性  了解即可</p><h2 id="Spring-Boot的优点？"><a href="#Spring-Boot的优点？" class="headerlink" title="Spring Boot的优点？"></a>Spring Boot的优点？</h2><p><strong>独立运行</strong></p><p>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。</p><p><strong>简化配置</strong></p><p>spring-boot-starter-web启动器自动依赖其他组件，减少了maven的配置。</p><p><strong>自动配置</strong></p><p>Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。</p><p><strong>无代码生成和XML配置</strong></p><p>Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。</p><p><strong>应用监控</strong></p><p>Spring Boot提供一系列端点可以监控服务及应用，做健康检测。</p><h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><ol><li><p><code>SpringApplication.run(Application.class, args);</code> 执行流程中有 <code>refreshContext(context)</code> 这句话</p></li><li><p><code>refreshContext(context)</code>内部会对我们配置类上面的标签进行解析( <code>@SpringBootApplication</code>)<br>  实现自动装配的注解 <code>@EnableAutoConfiguration</code></p></li><li><p><code>@EnableAutoConfiguration</code> 注解里面  @Import 引入配置类 <code>AutoConfigurationImportSelector</code> </p></li><li><p><code>AutoConfigurationImportSelector</code> 中的方法  <code>getCandidateConfigurations</code> 中<br> <code>SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</code></p></li><li><p><code>loadFactoryNames</code> 的作用是 读取我们jar包中的  <code>META-INF/spring.factories</code></p></li><li><p>该文件中配置了自动装配类</p><p><code>DruidDataSourceAutoConfigure</code></p></li></ol><h2 id="自定义一个starter的步骤："><a href="#自定义一个starter的步骤：" class="headerlink" title="自定义一个starter的步骤："></a>自定义一个starter的步骤：</h2><ol><li>创建一个模块<br>命名规则：<br>spring-boot-starter 官方的命名<br>redis-spring-boot-starter 第三方命名</li><li>在resources中创建 META-INF 文件夹 ，在文件夹中创建  spring.factories文件</li><li>spring.factories中进行如下配置<br><code>org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.liushao.redis.boot.MyRedisAutoConfigure</code></li><li>添加配置类,需要按照规则创建对象</li><li>在内部根据条件创建redis对象 （操作redis）</li><li>有一个类 RedisProperties 【主机地址、端口、密码】</li></ol><h2 id="常见的HTTP相应状态码（最少写5个）"><a href="#常见的HTTP相应状态码（最少写5个）" class="headerlink" title="常见的HTTP相应状态码（最少写5个）"></a>常见的HTTP相应状态码（最少写5个）</h2><p>200 – 请求成功</p><p>301 – 资源(网页等)被永久转移到其它</p><p>URL404 – 请求的资源(网页等)不存在</p><p>405方法不被允许</p><p>500 – 内部服务器错误</p><h2 id="JVM运行时数据区域有哪些"><a href="#JVM运行时数据区域有哪些" class="headerlink" title="JVM运行时数据区域有哪些?"></a>JVM运行时数据区域有哪些?</h2><p>程序计数器（线程私有）</p><p>Java虚拟机栈（线程私有）</p><p>本地方法栈（线程私有）</p><p>Java 堆（线程共享）</p><p>方法区（线程共享）</p><p>运行时常量池</p><h2 id="JVM运行是数据区域哪些是私有的，哪些是共享的"><a href="#JVM运行是数据区域哪些是私有的，哪些是共享的" class="headerlink" title="JVM运行是数据区域哪些是私有的，哪些是共享的?"></a>JVM运行是数据区域哪些是私有的，哪些是共享的?</h2><p>程序计数器（线程私有）</p><p>Java虚拟机栈（线程私有）</p><p>本地方法栈（线程私有）</p><p>Java 堆（线程共享）</p><p>方法区（线程共享）</p><p>运行时常量池</p>]]></content>
      
      
      <categories>
          
          <category> 编程开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud——服务熔断</title>
      <link href="/2022/02/25/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/SprinCloud%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/02/25/Java%E5%90%8E%E7%AB%AF/%E6%A1%86%E6%9E%B6/SprinCloud%E7%86%94%E6%96%AD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2>]]></content>
      
      
      <categories>
          
          <category> 编程开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SrpingBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象（上）</title>
      <link href="/2021/09/22/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2021/09/22/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="Java面向对象（上）"><a href="#Java面向对象（上）" class="headerlink" title="Java面向对象（上）"></a>Java面向对象（上）</h1><h2 id="面对对象概述"><a href="#面对对象概述" class="headerlink" title="面对对象概述"></a>面对对象概述</h2><h3 id="面向过程-POP-与面向对象-OOP"><a href="#面向过程-POP-与面向对象-OOP" class="headerlink" title="面向过程(POP)与面向对象(OOP)"></a>面向过程(POP)与面向对象(OOP)</h3><p><strong>面向过程：</strong>强调的是功能行为，以函数为最小单位，<strong>考虑怎么做</strong>。</p><p><strong>面向对象：</strong>强调具有功能的对象，以类/对象为最小单位，<strong>考虑谁来做</strong>。面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法和原则，如抽象、分类、继承、聚合、多态等。</p><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><ol><li>封装</li><li>继承</li><li>多态</li></ol><h3 id="面向对象的思想概述"><a href="#面向对象的思想概述" class="headerlink" title="面向对象的思想概述"></a>面向对象的思想概述</h3><p>程序员从面向过程的之性质转化成了面向对象的指挥者。</p><p>面向对象分析方法分析问题的思路和步骤：</p><ol><li>根据问题需要，选择问题所针对的现实世界中的实体。</li><li>从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了概念世界中的类。</li><li>把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造晨计算机能够识别和处理的数据结构。</li><li>将实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。 </li></ol><h2 id="面向对象的两个要素——类和对象"><a href="#面向对象的两个要素——类和对象" class="headerlink" title="面向对象的两个要素——类和对象"></a>面向对象的两个要素——类和对象</h2><p>对象：是实际纯在的该事物的每个个体，因而也称为实例(instance)</p><h3 id="定义类"><a href="#定义类" class="headerlink" title="定义类"></a>定义类</h3><p>类(class)和对象(object，也被称为实例)，其中类是对一类事物的描述，是抽象的、概念上的定义。定义类的简单语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] class 类名 &#123;</span><br><span class="line">    零到多个构造器定义...</span><br><span class="line">零到多个成员变量...</span><br><span class="line">零到多个方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计类，其实就是设计类的成员，对与一个类定义而言，可以包含三种常见的成员：构造器、成员变量和方法，这些成员都可以定义零到多个。</p><p>创建类的对象 = 类的实例化 = 实例化类</p><p>其中修饰符可以是<code>public、final、abstract</code>，也可以省略。为了程序的可读性，Java类名是一个或多个有意义的单词连接而成，采用驼峰命名规则。</p><p>对于一个类的定义而言，构造器、成员变量和方法可以定义零到多个，但在类中三个成员数量都为零，就相当于建了一个空类没有太大的意义。</p><p>类中三项成员定义的顺序没有任何影响，各成员之间可以相互调用，<label style="color:red">static修饰的成员不能访问没有static修饰的成员</label></p><p><strong>成员变量</strong>用于定义该类或该类的对象（实例）所包含的的状态数据，<strong>方法</strong>则用于定义该类或该类实例的行为特征或功能实现。<strong>构造器</strong>用于构造该类的对象（实例），Java语言通过关键字来调用构造器，从而返回该类的对象（实例）。</p><p><strong>构造器是一个类创建对象的根本途径</strong>，如果一个类没有构造器，这个类通常无法创建实例。</p><p><strong>定义成员变量的语法格式如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 类型 成员变量名 = [默认值] </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><ul><li><strong>修饰符：</strong>可以是<code>public、protected、private、static、final</code>，其中<code>public、protected、private</code>三个最多出现一个，可以于<code>static、final</code>组合修饰成员变量，<code>public static final int a = 0;</code>其中修饰的成员变量a被称为<strong>常量</strong>。</li><li><strong>类型：</strong>包括基本数据类型和引用数据类型。</li><li><strong>成员变量名：</strong>成员变量名是一个合法的标识符即可。</li><li><strong>默认值：</strong>定义的成员变量还可以指定一个可选的默认值。</li></ul><blockquote><p>在类中成员变量一般不赋初始值，当某个类有age成员变量（属性）时，意味着该类包含setAge()和getAge()两个方法。</p></blockquote><p><strong>定义方法的语法格式如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 方法返回值类型 方法名 (形参列表)&#123;</span><br><span class="line">    <span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;hello&quot;</span>+a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>修饰符：</strong>可以是<code>public、protected、private、static、final</code>，其中<code>public、protected、private</code>三个最多出现一个，<code>static、final</code>最多可以出现一个，它们可以和<code>static</code>组合修饰方法。</li><li><strong>方法返回值类型：</strong>方法返回值类型可以是基本数据类型或引用数据类型，如果方法声明了方法返回值类型，在方法体内必须有一个有效的<code>return</code>语句。</li><li><strong>方法名：</strong>方法名命名规则和成员变量命名规则相同。</li><li><strong>形参列表：</strong>形参列表用于定义该方法可以接收的参数，可以不接受任何参数，一旦在定义方法时指定了形参列表，则调用方法时，必须传入一个对应的参数值。</li></ul><p>在方法体中多条可执行语句间有严格的执行顺序，排在方法体前的总是先执行。</p><h4 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h4><p>static是一个特殊的关键字，它可以修饰方法、成员变量等。<strong>static修饰的成员表示它属于这个类本身，而不属于该类的单个实例</strong>，通常把static修饰的成员变量和方法称为类变量、类方法。static翻译为静态的，因此也把static修饰的成员变量和方法称为静态变量和静态方法，静态成员不能直接访问非静态成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test09</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//报错，静态成员不能直接访问非静态成员</span></span><br><span class="line"><span class="comment">//test1();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test2是静态方法可以直接访问</span></span><br><span class="line">test2();</span><br><span class="line"></span><br><span class="line"><span class="comment">//想访问test1方法需要创建对象</span></span><br><span class="line"><span class="type">Test09</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test09</span>();</span><br><span class="line">t.test1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是非静态成员&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我是静态成员&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>static的真正作用就是区分成员变量、方法、内部类、初始化块，这四个成员到底属于类本身还是属于实例。</strong>在类中定义的成员，static相当于一个标志，有static修饰属于类的本身，没有static属于该类的实例。</p></blockquote><h4 id="类中属性的使用"><a href="#类中属性的使用" class="headerlink" title="类中属性的使用"></a>类中属性的使用</h4><p>属性(成员变量)和局部变量区别</p><p>相同点：</p><ol><li>定义变量的格式： 数据类型  变量名  =  变量值</li><li>先声明、后使用</li><li>变量都有其对应的作用域</li></ol><p>不同点：</p><ol><li><p>在类中声明的位置不同</p><p>属性：直接在类的一对括号中声明</p><p>局部变量：声明在方法内、方法形参、代码块内、构造器内部的变量。</p></li><li><p>关于权限修饰符的不同</p><p>属性：可以在声明属性时，指明其权限，使用权限修饰符</p><p>​    常见的权限修饰符：private、public、protected、缺省 –&gt;封装性</p><p>局部变量：不可以使用权限修饰符</p></li><li><p>默认初始化的情况</p><p>属性： 类的属性，根据其类型，都有初始化值</p><p>​    整型：0</p><p>​    浮点型：0.0</p><p>​    字符型（char）：0或(‘\u0000’)</p><p>​    布尔型：false</p><p>​    引用类型变量（类、数组、接口）：null</p><p>局部变量：没有初始化值</p><p>​    在调用前一定要显示赋值，形参调用时再赋值</p></li><li><p>在内存中加载的位置</p><p>属性：加载到对空间中</p><p>局部变量：加载到栈空间</p></li></ol><h4 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[修饰符] 构造器名(形参列表)&#123;</span><br><span class="line">    <span class="comment">//零到多条可执行语句组成的构造器执行体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">String name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//普通方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>修饰符：</strong>修饰符可以省略，也可以是<code>public、protected、private</code>其中之一。</li><li><strong>构造器名：</strong>构造器名必须和类名相同。</li><li><strong>形参列表：</strong>和定义方法的形参列表相同</li></ul><p>构造器既不能定义返回值类型，如果构造器定义了返回值类型，或使用void声明构造器没有返回值，Java会将这个构造器当作方法处理，它就不再是构造器。</p><blockquote><p>实际上构造器是有返回值的，当使用new关键字来调用构造器时，构造器就返回该类的实例，可以将这个实例当作构造器的返回值，因此构造器的返回值类型总是当前类，无需定义返回值类型。要注意的是：<strong>不要在构造器中使用return来返回当前类的对象，因为构造器的返回值是隐式的。</strong></p></blockquote><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    public Person() &#123;</span></span><br><span class="line"><span class="comment">super();</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//定义方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String content)</span>&#123;</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中Person类中没有定义构造器，系统会为它提供一个默认的构造器，系统提供的构造器总是没有参数的。</p><p><strong>Java类的作用：定义变量、创建对象、调用类的类方法或访问类的类变量。</strong></p><h4 id="类中方法的使用"><a href="#类中方法的使用" class="headerlink" title="类中方法的使用"></a>类中方法的使用</h4><p>方法：描述类应该具有的功能</p><blockquote><p>比如：Math类：sqrt()\random()…</p><p>​          Scanner类：NextXxx()…</p><p>​          Arrays类：sort()\toString()\equals()…</p></blockquote><ol><li>方法的声明：``     </li></ol><p>​    </p><h3 id="对象的产生和使用"><a href="#对象的产生和使用" class="headerlink" title="对象的产生和使用"></a>对象的产生和使用</h3><p>创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Person定义一个Person类型的对象</span></span><br><span class="line">Person p;</span><br><span class="line"><span class="comment">//通过new关键字调用Person类的构造器，返回一个Person实例</span></span><br><span class="line"><span class="comment">//将该Person实例赋值给p变量</span></span><br><span class="line">p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述代码也可转换成</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>创建对象后，就可使用该对象，Java的对象作用有：<strong>访问对象的实例变量、调用对象的方法。</strong>如果访问权限允许，类中定义的方法和成员变量都可以通过类或实例调用。</p><p><strong>static</strong>修饰的<strong>类方法</strong>和成员变量，既可以通过类来调用，也可以通过实例来调用。没有<strong>static</strong>修饰的<strong>普通方法</strong>和成员变量，只有通过实例来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.eat();</span><br><span class="line">p.hight(<span class="number">180</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;吃饭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hight</span><span class="params">(<span class="type">int</span> tall)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;身高为：&quot;</span>+tall);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分时候定义一个类就是为了重复创建该类的实例，同一个类的多个实例具有相同的特征，而类则是定义了多个实例的共同特征。从某个角度看，类定义的是多个实例的特征，因此类不是一个具体的存在，实例才是具体的存在。</p><h3 id="对象、引用和指针"><a href="#对象、引用和指针" class="headerlink" title="对象、引用和指针"></a>对象、引用和指针</h3><p>在<code>Person p = new Person();</code>代码中创建了一个<code>Person</code>类型的实例，也被称为<code>Person</code>对象，这个<code>Person</code>对象被赋给变量<code>p</code>。上述代码中其实产生了两个东西：一个是变量<code>p</code> ，一个是<code>Person</code>对象。</p><h4 id="对象内存解析"><a href="#对象内存解析" class="headerlink" title="对象内存解析"></a>对象内存解析</h4><p><img src="https://i.loli.net/2021/11/08/RdL6AqZ1KzmHuMi.png" alt="Jvm内存"></p><p>与数组类型类似，类也是一个引用数据类型，在程序中<code>Person</code>类型的变量实际上是一个引用，它被存放在栈内存中，实际指向Person对象。真正的Person对象则存放在堆内存中。</p><p><img src="https://i.loli.net/2021/10/30/fIXG4zZhjcM6Tai.png" alt="引用对象指向实际对象"></p><p>栈内存中的引用变量并未真正存储对象的成员变量，对象的成员变量数据实际存放在堆内存中。而引用变量只是指向该堆内存里的对象。实际上，Java里的引用就是C里的指针。</p><p>当一个对象被创建成功以后，这个对象将保存在堆内存中，Java程序不允许直接访问堆内存中的对象，只能通过该对象的引用操作该对象。不管对象还是数组，都只能通过引用来访问它们。</p><blockquote><p>不管对象还是数组，当程序访问引用变量的成员变量或方法时，实际上是访问引用变量所引用的数组、对象的成员变量或方法。</p></blockquote><p>堆内存中的对象可以有多个引用，即多个引用指向一个对象。</p><h4 id="对象this引用"><a href="#对象this引用" class="headerlink" title="对象this引用"></a>对象this引用</h4><p>this关键字总是指向调用该方法的对象，根据this出现位置的不同有两种情况：</p><ol><li>构造器中引用该构造器正在初始化的对象。</li><li>在方法中引用调用该方法的对象。</li></ol><p><strong>this关键字最大的作用就是让类中的一个方法，访问该类里另一个方法或实例变量。</strong></p><p>大部分时候，一个方法访问该类中定义的其他方法、成员变量时加不加this前缀的效果是完全一样的。对于<strong>static</strong>修饰的方法而言，则可以使用类来直接调用该方法，如果在static修饰的方法中使用this关键字，则这个关键字就无法指向合适的对象。所以static修饰的方法不能使用this引用，<strong>Java语法规定：静态成员不能直接访问非静态成员。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/2021/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
      <url>/2021/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h2 id="1、初始数据库"><a href="#1、初始数据库" class="headerlink" title="1、初始数据库"></a>1、初始数据库</h2><h3 id="1-1、安装MySQL"><a href="#1-1、安装MySQL" class="headerlink" title="1.1、安装MySQL"></a>1.1、安装MySQL</h3><ol><li><p>下载压缩包</p></li><li><p>解压到自己想要安装的目录</p></li><li><p>添加环境变量</p><ol><li><p>我的电脑—属性—高级—环境变量</p></li><li><p>选择PATH，在后面添加mysql安装文件下的bin文件夹</p></li><li><p>在bin当前目录新建my.ini文件</p></li><li><p>编辑my.ini注意替换路径位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line">#目录一定换成自己的</span><br><span class="line">basedir=E:\mysql\mysql-5.7.23\</span><br><span class="line">datadir=E:\mysql\mysql-5.7.23\data\</span><br><span class="line">port=3306</span><br><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure></li><li><p>管理员模式启动cmd，并将路径切换至mysql下的bin目录，然后输入mysqld -install</p><blockquote><p>重新安装mysql可能会出现数据库已经存在并报错此时使用 <code>mysqld remove</code> 然后再执行 <code>mysqld -install</code> 即可</p></blockquote></li><li><p>再输入<code>mysqld --initialize-insecure --user=mysql</code>初始化数据文件</p></li><li><p>然后再启动mysql 用命令<code>mysql -u root -p</code>进入mysql管理界面（密码可为空）</p></li><li><p>进入界面后更改root密码（sql语句后面一定要加分号）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updata mysql,user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host=&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p>最后输入flush privileges;刷新权限</p></li><li><p>修改my.ini文件删除最后一句skip-grant-atbles</p></li><li><p>重启mysql即可使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net satrt mysql #启动数据库</span><br><span class="line">net stop mysql #停止数据库</span><br><span class="line">sc delete mysql #清空服务（安装出错时执行）</span><br></pre></td></tr></table></figure></li><li><p>注释掉my.ini中最后一行，重启mysql，测试连接</p></li></ol></li></ol><h3 id="1-2、连接数据库"><a href="#1-2、连接数据库" class="headerlink" title="1.2、连接数据库"></a>1.2、连接数据库</h3><p>命令行连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p123456 --连接数据库</span><br><span class="line"></span><br><span class="line">update mysql.user set authentication_string=password(&#x27;123456&#x27;) where user=&#x27;root&#x27; and Host=&#x27;localhost&#x27;；--修改用户密码</span><br><span class="line">flush privileges; --刷新权限</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb</title>
      <link href="/2021/03/09/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/JavaWeb/"/>
      <url>/2021/03/09/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/JavaWeb/</url>
      
        <content type="html"><![CDATA[<h1 id="JavaScript介绍"><a href="#JavaScript介绍" class="headerlink" title="JavaScript介绍"></a>JavaScript介绍</h1><p>Javascript 语言诞生主要是<strong>完成页面的数据验证</strong>。 因此它运行在客户端， 需要运行浏览器来解析执行 JavaScript 代码。<br>JS 是 Netscape 网景公司的产品， 最早取名为 LiveScript;为了吸引更多 java 程序员。 更名为 JavaScript。</p><p><strong>JS 是弱类型， Java 是强类型。</strong></p><blockquote><p>比如int a = 1;那么a不能够再被赋值为其他类型；<br>但是在js中，var a = 1;a还能被赋值为其他类型，比如a = “hello”;</p></blockquote><p>特点</p><ol><li>交互性（它做的就是动态交互）</li><li>安全性（不允许直接访问本地硬盘）</li><li>跨平台性（只要是可以解释JS的浏览器都可以执行，和平台无关）</li></ol><h1 id="JavaScript-和-html-代码的结合方式"><a href="#JavaScript-和-html-代码的结合方式" class="headerlink" title="JavaScript 和 html 代码的结合方式"></a>JavaScript 和 html 代码的结合方式</h1><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><p>只需要在 head 标签中， 或者在 body 标签中， 使用 script 标签来书写 JavaScript 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert是JavaScript语言提供的一个警告框函数。</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 它可以接收任意类型的参数，这个参数就是警告框的提示信息</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;hello javaScript!&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h2><p>使用 script 标签引入 单独的 JavaScript 代码文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&quot;1125 hello!&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        现在需要使用script引入外部的js文件来执行src 属性专门用来引入js文件路径（可以是相对路径，也可以是绝对路径）</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;1.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(<span class="string">&quot;国哥现在可以帅了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：script标签可以用来定义js代码，也可以用来引入js文件<br>但是，两个功能二选一使用。不能同时使用两个功能</strong></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>JavaScript 的变量类型：</p><ul><li>数值类型： number</li><li>字符串类型： string</li><li>对象类型： object</li><li>布尔类型： boolean</li><li>函数类型： function</li></ul><p>JavaScript 里特殊的值：</p><ul><li>undefined 未定义， 所有 js 变量未赋于初始值的时候， 默认值都是 undefined.</li><li>null 空值</li><li>NaN 全称是： Not a Number。 非数字。 非数值。</li></ul><p>JS 中的定义变量格式：</p><ul><li>var 变量名;</li><li>var 变量名 = 值;</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> i;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert(i); // undefined</span></span></span><br><span class="line"><span class="language-javascript">        i = <span class="number">12</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// typeof()是JavaScript语言提供的一个函数。</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( typeof(i) ); // number</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        i = <span class="string">&quot;abc&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 它可以取变量的数据类型返回</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( typeof(i) ); // String</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> a = <span class="number">12</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> b = <span class="string">&quot;abc&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>( a * b ); <span class="comment">// NaN是非数字，非数值。</span></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="关系（比较）运算"><a href="#关系（比较）运算" class="headerlink" title="关系（比较）运算"></a>关系（比较）运算</h2><p>等于： == 等于是简单的做字面值的比较<br>全等于： === 除了做字面值的比较之外， 还会比较两个变量的数据类型</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> a = <span class="string">&quot;12&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> b = <span class="number">12</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>( a == b ); <span class="comment">// true</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>( a === b ); <span class="comment">// false</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul><li>且运算： &amp;&amp;</li><li>或运算： ||</li><li>取反运算： !</li></ul><p>在 JavaScript 语言中， 所有的变量， 都可以做为一个 boolean 类型的变量去使用。<br><strong>0 、 null、 undefined、 ””(空串) 都认为是 false；</strong></p><ol><li>&amp;&amp; 且运算<br>有两种情况：<br>第一种： 当表达式全为真的时候。 返回最后一个表达式的值。<br>第二种： 当表达式中， 有一个为假的时候。 返回第一个为假的表达式的值</li><li>|| 或运算<br>第一种情况： 当表达式全为假时， 返回最后一个表达式的值<br>第二种情况： 只要有一个表达式为真。 就会把回第一个为真的表达式的值</li></ol><p><strong>并且 &amp;&amp; 与运算 和 ||或运算有短路。<br>短路就是说， 当这个&amp;&amp;或||运算有结果了之后 。 后面的表达式不再执行</strong></p><blockquote><p>表达式1 || 表达式2 || 表达式3…|| 表达式n，如果表达式1的运算结果为true，则整个表达式的结果为true，同时不会再对后面的表达式2、表达式3到表达式n进行运算判断，&amp;&amp;同理</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">/*     在JavaScript语言中，所有的变量，都可以做为一个boolean类型的变量去使用。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        0 、null、 undefined、””(空串) 都认为是 false；*/</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// var a = 0;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// if (a) &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;零为真&quot;);</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125; else &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;零为假&quot;);//√</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// var b = null;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// if (b) &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;null为真&quot;);</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125; else &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;null为假&quot;);//√</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// var c = undefined;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// if (c) &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;undefined为真&quot;);</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125; else &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;undefined为假&quot;);//√</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// var d = &quot;&quot;;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// if (d) &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;空串为真&quot;);</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125; else &#123;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     alert(&quot;空串为假&quot;);//√</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="comment">/*         &amp;&amp; 且运算。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">有两种情况：</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">第一种：当表达式全为真的时候。返回最后一个表达式的值。</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">第二种：当表达式中，有一个为假的时候。返回第一个为假的表达式的值*/</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> a = <span class="string">&quot;abc&quot;</span>;<span class="comment">//true</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> b = <span class="literal">true</span>;<span class="comment">//true</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> d = <span class="literal">false</span>;<span class="comment">//false</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> c = <span class="literal">null</span>;<span class="comment">//false</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( a &amp;&amp; b );//true</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( b &amp;&amp; a );//abc</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( a &amp;&amp; d ); // false</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( a &amp;&amp; c ); // null</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"> <span class="comment">/*      || 或运算</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">       第一种情况：当表达式全为假时，返回最后一个表达式的值</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">       第二种情况：只要有一个表达式为真。就会把回第一个为真的表达式的值*/</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( d || c ); // null</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( c|| d ); //false</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( a || c ); //abc</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( b || c ); //true</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="数组-重要"><a href="#数组-重要" class="headerlink" title="数组(重要)"></a>数组(重要)</h1><h2 id="数组定义方式"><a href="#数组定义方式" class="headerlink" title="数组定义方式"></a>数组定义方式</h2><p><strong><label style="color:red">var 数组名 = []; // 空数组<br>var 数组名 = [1 , ’abc’ , true]; // 定义数组同时赋值元素</label></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> arr = [<span class="literal">true</span>,<span class="number">1</span>]; <span class="comment">// 定义一个空数组</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( arr.length ); </span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        arr[<span class="number">0</span>] = <span class="number">12</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( arr[0] );//12</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// javaScript语言中的数组，只要我们通过数组下标赋值，那么最大的下标值，就会自动的给数组做扩容操作。</span></span></span><br><span class="line"><span class="language-javascript">        arr[<span class="number">2</span>] = <span class="string">&quot;abc&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(arr.<span class="property">length</span>); <span class="comment">//3</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert(arr[1]);// 如果数组初始化为空时，那么下标为1的元素为undefined</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 数组的遍历</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(arr[i]);<span class="comment">//12 1 abc</span></span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="函数（重要）"><a href="#函数（重要）" class="headerlink" title="函数（重要）"></a>函数（重要）</h1><h2 id="函数的两种定义方式"><a href="#函数的两种定义方式" class="headerlink" title="函数的两种定义方式"></a>函数的两种定义方式</h2><p>第一种， 可以使用 function 关键字来定义函数。<br>使用的格式如下:<br><strong><label style="color:red">function 函数名(形参列表){ 函数体 }</label></strong></p><p>在JavaScript 语言中， 如何<strong>定义带有返回值的函数？</strong><br>只需要<strong>在函数体内直接使用 return 语句返回值</strong>即可！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 定义一个无参函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;无参函数fun()被调用了&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 函数调用===才会执行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// fun();</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun2</span>(<span class="params">a ,b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;有参函数fun2()被调用了 a=&gt;&quot;</span> + a + <span class="string">&quot;,b=&gt;&quot;</span>+b);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// fun2(12,&quot;abc&quot;);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 定义带有返回值的函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1,num2</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> result = num1 + num2;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>( <span class="title function_">sum</span>(<span class="number">100</span>,<span class="number">50</span>) );</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">````</span><br><span class="line"></span><br><span class="line">函数的第二种定义方式， 格式如下：</span><br><span class="line">使用格式如下：</span><br><span class="line">**<span class="tag">&lt;<span class="name">label</span> <span class="attr">style</span>=<span class="string">&quot;color:red&quot;</span>&gt;</span>var 函数名 = function(形参列表) &#123; 函数体 &#125;<span class="tag">&lt;/<span class="name">label</span>&gt;</span>**</span><br><span class="line"></span><br><span class="line">``` HTML</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> fun = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;无参函数&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// fun();</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> fun2 = <span class="keyword">function</span> (<span class="params">a,b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;有参函数a=&quot;</span> + a + <span class="string">&quot;,b=&quot;</span> + b);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// fun2(1,2);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> fun3 = <span class="keyword">function</span> (<span class="params">num1,num2</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> num1 + num2;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>( <span class="title function_">fun3</span>(<span class="number">100</span>,<span class="number">200</span>) );</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：在 Java 中函数允许重载。 但是在 JS 中函数的重载会直接覆盖掉上一次的定义</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a,b</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;有参函数fun(a,b)&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;无参函数fun()&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">fun</span>(<span class="number">1</span>,<span class="string">&quot;ad&quot;</span>);<span class="comment">//无参函数fun()</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="函数的-arguments-隐形参数（只在-function-函数内）"><a href="#函数的-arguments-隐形参数（只在-function-函数内）" class="headerlink" title="函数的 arguments 隐形参数（只在 function 函数内）"></a>函数的 arguments 隐形参数（只在 function 函数内）</h2><p>就是在 function 函数中不需要定义， 但却可以直接用来获取所有参数的变量。 我们管它叫隐形参数。<br>隐形参数特别像 java 基础的可变长参数一样。<br>public void fun( Object … args );<br>可变长参数其实是一个数组。</p><p>那么 js 中的隐形参数也跟 java 的可变长参数一样。 操作类似数组。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">fun</span>(<span class="params">a</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>( <span class="variable language_">arguments</span>.<span class="property">length</span> );<span class="comment">//可看参数个数</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>( <span class="variable language_">arguments</span>[<span class="number">0</span>] );</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>( <span class="variable language_">arguments</span>[<span class="number">1</span>] );</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>( <span class="variable language_">arguments</span>[<span class="number">2</span>] );</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;a = &quot;</span> + a);</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>( <span class="variable language_">arguments</span>[i] );</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;无参函数fun()&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// fun(1,&quot;ad&quot;,true);</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 需求：要求 编写 一个函数。用于计算所有参数相加的和并返回</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">num1,num2</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> result = <span class="number">0</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">if</span> (<span class="title function_">typeof</span>(<span class="variable language_">arguments</span>[i]) == <span class="string">&quot;number&quot;</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                    result += <span class="variable language_">arguments</span>[i];</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span> result;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>( <span class="title function_">sum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&quot;abc&quot;</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>) );<span class="comment">//没有加if判断的话，结果为；10abc56789</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JS中的自定义对象"><a href="#JS中的自定义对象" class="headerlink" title="JS中的自定义对象"></a>JS中的自定义对象</h1><h2 id="Object形式的自定义对象"><a href="#Object形式的自定义对象" class="headerlink" title="Object形式的自定义对象"></a>Object形式的自定义对象</h2><p><strong>对象的定义：</strong><br>var 变量名 = new Object(); // 对象实例（空对象）<br>变量名.属性名 = 值; // 定义一个属性<br>变量名.函数名 = function(){} // 定义一个函数<br><strong>对象的访问：</strong><br>变量名.属性 / 函数名();</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 对象的定义：</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     var 变量名 = new Object();   // 对象实例（空对象）</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     变量名.属性名 = 值;  // 定义一个属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     变量名.函数名 = function()&#123;&#125;  // 定义一个函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">name</span> = <span class="string">&quot;华仔&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">age</span> = <span class="number">18</span>;</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="property">fun</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; , 年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 对象的访问：</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     变量名.属性 / 函数名();</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// alert( obj.age );</span></span></span><br><span class="line"><span class="language-javascript">        obj.<span class="title function_">fun</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="花括号形式的自定义对象"><a href="#花括号形式的自定义对象" class="headerlink" title="{}花括号形式的自定义对象"></a>{}花括号形式的自定义对象</h2><p><strong>对象的定义：</strong><br>var 变量名 = { // 空对象<br>属性名： 值, // 定义一个属性<br>属性名： 值, // 定义一个属性<br>函数名： function(){} // 定义一个函数<br>};<br><strong>对象的访问：</strong><br>变量名.属性 / 函数名();</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 对象的定义：</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// var 变量名 = &#123;// 空对象</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     属性名：值,// 定义一个属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     属性名：值,// 定义一个属性</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     函数名：function()&#123;&#125;// 定义一个函数</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// &#125;;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> obj = &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">name</span>:<span class="string">&quot;国哥&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">age</span>:<span class="number">18</span>,</span></span><br><span class="line"><span class="language-javascript">                fun : <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">alert</span>(<span class="string">&quot;姓名：&quot;</span> + <span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot; , 年龄：&quot;</span> + <span class="variable language_">this</span>.<span class="property">age</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 对象的访问：</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//     变量名.属性 / 函数名();</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(obj.<span class="property">name</span>);</span></span><br><span class="line"><span class="language-javascript">        obj.<span class="title function_">fun</span>();</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="js中的事件"><a href="#js中的事件" class="headerlink" title="js中的事件"></a>js中的事件</h1>]]></content>
      
      
      <categories>
          
          <category> 编程开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaWeb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java程序流程控制与数组</title>
      <link href="/2020/10/16/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/java02/"/>
      <url>/2020/10/16/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/java02/</url>
      
        <content type="html"><![CDATA[<h1 id="程序流程控制与数组"><a href="#程序流程控制与数组" class="headerlink" title="程序流程控制与数组"></a>程序流程控制与数组</h1><h2 id="顺序结构测试"><a href="#顺序结构测试" class="headerlink" title="顺序结构测试"></a>顺序结构<a id="测试">测试</a></h2><ul><li>程序从上到下逐行执行，中间没有任何判断和跳转。</li><li>如果没有任何流程控制，程序总是从上到下执行每条语句。</li></ul><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><ul><li>根据条件，选择性地执行某段代码。</li><li>有if-else和switch-case两种分支语句。</li></ul><h3 id="if-else结构"><a href="#if-else结构" class="headerlink" title="if-else结构"></a>if-else结构</h3><ul><li>else是可选的</li><li>针对多个条件表达式之间是“互斥”关系（或者没有交集的关系）。</li><li>如果多个条件表达式之间有交集关系，需要根据实际情况，考虑应该将哪个结构声明在上面。</li><li>如果多个条件表达式之间有包含关系，<strong>一定要先处理包含范围小的情况</strong>，否则范围小的没机会运行。</li><li>if-else结构是可以嵌套的。</li></ul><p><strong>if语句三种格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/06/hw8v29WiysljbzS.png" alt="java_circl_01"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/06/TXJ6aOz5pLiwnNl.png" alt="java_circl_02"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>&#123;</span><br><span class="line">执行表达式<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式n；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/06/xbyAjGagsk1cSJe.png" alt="java_circl_03"></p><p><strong>具体举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IfTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//格式1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">hearBeats</span> <span class="operator">=</span> <span class="number">78</span>;</span><br><span class="line"><span class="keyword">if</span>(hearBeats &lt; <span class="number">60</span> || hearBeats &gt; <span class="number">100</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;需要进一步检查！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;检查结束&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span>(age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你不能结婚&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你可以结婚&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//格式3</span></span><br><span class="line"><span class="keyword">if</span>(age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;您输入数据非法！&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &lt; <span class="number">18</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;青年时期&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(age &lt; <span class="number">35</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;青壮年时期&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(]age &lt; <span class="number">60</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;中年时期&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;老年时期&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>if、else-if、else后面花括号内的多行代码被称为代码块，<strong>一个代码块通常看作一个整体来执行</strong>（除非运行过程中遇到<strong>return、break、continue</strong>等关键字，或是遇到了异常。）</li><li>else的含义是“否则”，<strong>else本身就是一个条件</strong>，这也是把if、else后面代码块统称为条件执行体的原因，<strong>else的隐含条件是对前面的条件取反</strong>。</li></ul><h3 id="switch-case结构"><a href="#switch-case结构" class="headerlink" title="switch-case结构"></a>switch-case结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">语句<span class="number">1</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">case</span> 常量N:</span><br><span class="line">语句N ;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"><span class="keyword">default</span>;</span><br><span class="line">语句;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/08/CakJsuxehjVKy7g.png" alt="switch-case结构"></p><ul><li>根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。当调用完执行语句后，仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或程序终止为止。</li><li>在switch-case结构中，一旦执行break关键字，就跳出switch-case结构。</li><li>switch结构表达式，只能是<strong>byte、short、char、int四种整数类型和枚举类型、String类型（Java7开始允许）</strong>，6中数据类型之一，<strong>不能是boolean类型</strong>。</li><li>case之后只能声明常量不能声明 范围。</li><li>break关键字是可选的。</li><li>default相当于if-else中的else。</li></ul><p><em><strong>例子</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">season</span> <span class="operator">=</span> <span class="string">&quot;summer&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span>(season)&#123;</span><br><span class="line"><span class="keyword">case</span><span class="string">&quot;spring&quot;</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="string">&quot;summer&quot;</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="string">&quot;autumn&quot;</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;秋天&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span><span class="string">&quot;winter&quot;</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;冬天&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">&quot;季节输入有误！&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于break例题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从键盘输入2019年的“month”和“day”，要求通过程序输入的日期为2019年的第几天</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SwitchCaseTest2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入2019年month：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;请输入2019年day：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">sumDays += <span class="number">30</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">sumDays += <span class="number">28</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">sumDays += <span class="number">31</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">sumDays += day;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sumDays);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>说明break在switch-case中是可选的</strong></p><ul><li>凡是使用switch-case的结构，都可以转化为if-else。反之，不成立。</li><li>写分支结构时，当发现既可以使用switch-case，（同时，switch中表达式的取值情况不太多），又可以使用if-else时，我们优先选择使用switch-case。<strong>原因：switch-case执行效率稍高。</strong></li></ul><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><ul><li>在某些条件满足的情况下，反复执行特定代码的功能。</li><li>有for、while、do-while三种循环语句。</li></ul><p><img src="https://i.loli.net/2020/10/09/MCFAhlOHG57tmzT.png" alt="循环结构"><br><strong>注：JDK1.5提供了for-each循环，方便地遍历集合、数组元素。</strong></p><p><strong>循环结构的4个要素</strong></p><blockquote><p>① 初始化条件<br>② 循环条件 （条件是boolean类型）<br>③ 循环体<br>④ 迭代条件</p></blockquote><h3 id="for循环结构的使用"><a href="#for循环结构的使用" class="headerlink" title="for循环结构的使用"></a>for循环结构的使用</h3><p><strong>for循环的结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ … -&gt; ② </p><p>for循环圆括号内两个分号是必须的，初始化语句、循环条件、迭代语句都是可以省略的，如果省略了循环条件，则这个循环条件默认为true，将会产生一个死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text09</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//省略了for循环的三个部分，循环条件一直是true</span></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">System.out.println(<span class="number">123</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出</strong></p><p>123</p><p>123</p><p>…</p></blockquote><p>使用for循环时，还可以把初始化条件定义在循环体外，把循环迭代语句放在循环体内，这种方式类似下面的while循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text10</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (;i&lt;<span class="number">3</span>;) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;循环结束&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>0<br>1<br>2<br>循环结束</p></blockquote><p><strong>for循环例题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">题目 ：输入两个正整数m和n，求其最大公约数和最小公倍数</span></span><br><span class="line"><span class="comment">比如：12和20的最大公约数是4，最小公倍数是60</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入第一个整数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;请输入第一个整数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取两个数的最大公约数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (m &lt;= n)? m : n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> min;i &gt;= <span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(m % i == <span class="number">0</span>&amp;&amp; n %i == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.prinyln(<span class="string">&quot;最大公约数为：&quot;</span> + i);</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//一旦在循环中执行到break，就跳出循环</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取两个数的最小公倍数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (m &gt;=n)? m : n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> max;i &lt;= n*m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(m % i == <span class="number">0</span>&amp;&amp; n %i == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;最小公倍数为：&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出所有的水仙花数，所谓水仙花数是指一个3位数，其各个位上数字立方和等于其本身</span></span><br><span class="line"><span class="comment">例如：153=1*1*1+3*3*3+5*5*5</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForTest2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span> a,b,c,s;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">c=i%<span class="number">10</span>;</span><br><span class="line">b=(i/<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">a=i/<span class="number">100</span>;</span><br><span class="line"><span class="keyword">if</span>(Math.pow(a,<span class="number">3</span>)+Math.pow(b,<span class="number">3</span>)+Math.pow(c,<span class="number">3</span>)==i)</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;&quot;</span>+i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><blockquote><p>① 初始化条件<br>② 循环条件 （条件是boolean类型）<br>③ 循环体<br>④ 迭代条件  </p></blockquote><p><strong>while循环结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程：① -&gt; ② -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ … -&gt; ② </p><p><strong>说明</strong></p><ul><li>写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</li><li>写程序时，要避免出现死循环，算法要具有有限性。</li><li>for循环和while循环时可以相互转换的<br>  <strong>区别：for循环和while循环的初始化条件部分的作用范围不同。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WhileTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历100以内的所有偶数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">100</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">2</span> ==<span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//出了while循环后，仍可以调用i（for循环和while循环的区别）</span></span><br><span class="line">System.out.println(i);<span class="comment">// i=101</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h3><blockquote><p>① 初始化条件<br>② 循环条件 （条件是boolean类型）<br>③ 循环体<br>④ 迭代条件  </p></blockquote><p><strong>do-while循环结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br></pre></td></tr></table></figure><p>执行过程：① -&gt; ③ -&gt; ④ -&gt; ② -&gt; ③ -&gt; ④ … -&gt; ② </p><p><strong>说明：</strong></p><ul><li>do-while循环至少会执行一次循环体</li><li>开发中，使用for和while循环更多些，较少使用do-while</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DoWhileTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//遍历100以内的偶数，并计算所有偶数的和以及偶数的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录总和</span></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//记录个数</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(num % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">System.out.println(num);</span><br><span class="line">sum += num;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">num++;</span><br><span class="line">&#125;<span class="keyword">while</span>(num &lt;= <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;总和为：&quot;</span>+sum);</span><br><span class="line">System.out.println(<span class="string">&quot;个数为：&quot;</span>+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-true-结构的使用"><a href="#while-true-结构的使用" class="headerlink" title="while(true)结构的使用"></a>while(true)结构的使用</h3><p><strong>题目：从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForWhileTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">positiveNumber</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//记录正数的个数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">negativeNumber</span> <span class="operator">=</span> <span class="number">0</span>;    <span class="comment">//记录负数的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;                     <span class="comment">//for(;;)</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断number的正负情况</span></span><br><span class="line"><span class="keyword">if</span>(number &gt;<span class="number">0</span> )&#123;</span><br><span class="line">positiveNumber++;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(number &lt; <span class="number">0</span>)&#123;</span><br><span class="line">negativeNumber++;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;输入正数有：&quot;</span>+positiveNumber);</span><br><span class="line">System.out.println(<span class="string">&quot;输入负数有：&quot;</span>+negativeNumber);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>不在循环条件部分限制次数的结构：for(;;)或while(true)</li><li>循环结束的方式：<br>  1、循环条件部分返回false<br>  2、在循环体中，执行break</li><li>建议不要在循环体中改变循环变量的值，否则会增加出错的可能性。<strong>（需要修改的情况下，重新定义一个临时变量）</strong></li></ul><blockquote><p><strong>注意</strong></p><p>for循环和while、do-while有区别：while、do-while的循环迭代语句紧跟着循环体，如果循环体不能完全执行（如用continue结束本次循环），循环迭代语句是不会被执行的。但for循环的迭代语句并没有与循环体放在一起，因此不管是否使用continue语句来结束本次循环，迭代语句一样会获得执行。</p></blockquote><h3 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h3><p><strong>嵌套循环的使用</strong></p><ul><li>将一个循环结构A声明在另一个循环结构B的循环体中，就构成了循环嵌套</li><li>外层循环就是循环结构B，内层循环就是循环结构A</li><li>内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</li><li>外层循环执行m次，内层循环执行n次，此时内层循环的循环体一共执行了m*n次。</li></ul><p><strong>嵌套循环联系</strong></p><blockquote><p><strong>九九乘法表</strong><br>1 × 1 = 1<br>2 × 1 = 2  2 × 2 = 4<br>…<br>9 × 1 = 9 … 9 × 9 = 81</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NineTable</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;i &lt;= <span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;j &lt;= i;j++)&#123;</span><br><span class="line"></span><br><span class="line">System.out.print(i+<span class="string">&quot;×&quot;</span>+j+<span class="string">&quot;=&quot;</span>+(i*j));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>100以内所有质数</strong><br>质数：素数，只能被1和他本身整除的自然数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrimeNumberTest</span>&#123;   <span class="comment">//质数</span></span><br><span class="line">p<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">100</span>;i++)&#123; <span class="comment">//遍历100以内的自然数</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt; i;j++) &#123; <span class="comment">//和i做除法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag == <span class="literal">true</span>) &#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>优化算法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimeNumberTest1</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前时间距离1970-01-01 00:00:00的距离</span></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">10000</span>;i++)&#123; <span class="comment">//遍历100以内的自然数</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++) &#123; <span class="comment">//和i做除法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>) &#123;</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;<span class="comment">//优化1：只对本身非质数的自然数有效</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag == <span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">//System.out.println(i);</span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取当前时间距离1970-01-01 00:00:00的距离</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(count);</span><br><span class="line">System.out.println(end-start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h2 id="如何从键盘获取变量"><a href="#如何从键盘获取变量" class="headerlink" title="如何从键盘获取变量"></a>如何从键盘获取变量</h2><p>具体实现步骤:</p><ol><li>导包：import java.util.Scanner;</li><li>Scanner的实例化：Scanner scan = new Scanner(System.in);</li><li>调用Scanner类的相关方法，来获取指定类型的变量。</li></ol><p><strong>注意</strong><br>需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常，导致程序终止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ScannerTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.println(<span class="string">&quot;请输入任意整数：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> scan.nextInt();</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于char型的获取，Scanner没有提供相关方法，只能获取一个字符串。</li></ul><p><strong>如何获取一个随机数</strong></p><p>公式：[a,b]  (int)(Math.random() * (b - a + 1) + a);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取10-90的随机数</span></span><br><span class="line"><span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> (<span class="type">int</span>)(Math.random() * <span class="number">90</span> + <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p><strong>获取字符串对应位置的字符</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">gender</span> <span class="operator">=</span> scan.next();<span class="comment">//输入字符串</span></span><br><span class="line"><span class="type">char</span> <span class="variable">genderChar</span> <span class="operator">=</span> gender.charAt(<span class="number">0</span>);<span class="comment">//获取所以为0位置上的字符，实际为输入字符串第一个字符</span></span><br><span class="line">System.out.println(genderChar);<span class="comment">//输出获取的字符</span></span><br></pre></td></tr></table></figure><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><h3 id="数组的概述"><a href="#数组的概述" class="headerlink" title="数组的概述"></a>数组的概述</h3><p>数组是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，通过编号的方式对这些数据进行统一管理。</p><p>数组是一种<strong>数据结构</strong>，用来储存多个数据，每个数组元素存放一个数据，通常可以通过数组元素的索引<code>arr[i]</code>来访问数组元素。所有的数组元素需具有<strong>相同的数据类型</strong>，一个数组只能存储<strong>一种数据类型</strong>的数据。</p><h3 id="数组的相关概念"><a href="#数组的相关概念" class="headerlink" title="数组的相关概念"></a>数组的相关概念</h3><ul><li>数组名</li><li>元素</li><li>角标、下标、索引</li><li>数组的长度：元素的个数</li></ul><h3 id="数组的特点"><a href="#数组的特点" class="headerlink" title="数组的特点"></a>数组的特点</h3><ol><li>数组是有序排列的</li><li>数组属于引用数据类型的变量。数组的元素既可以是基本数据类型，也可以是引用数据类型</li><li>创建数组对象会在内存中开辟一整块连续的空间</li><li>数组的长度一旦确定，就不能修改</li></ol><h3 id="数组的分类"><a href="#数组的分类" class="headerlink" title="数组的分类"></a>数组的分类</h3><ol><li>按维数分：一维数组、二维数组…..</li><li>按数组元素的类型：基本数据类型元素的数组、引用数据类型的数组</li></ol><h3 id="一维数组的使用"><a href="#一维数组的使用" class="headerlink" title="一维数组的使用"></a>一维数组的使用</h3><h4 id="一维数组的声明和初始化"><a href="#一维数组的声明和初始化" class="headerlink" title="一维数组的声明和初始化"></a>一维数组的声明和初始化</h4><p><strong>数组的初始化</strong></p><p>Java数组必须先初始化，然后才可以使用。初始化就是为数组的数组元素分配内存空间，并为每个数组元素分配初始值。</p><p><strong>静态初始化</strong></p><p>数组的初始化和数组元素的赋值同时进行，初始化时由程序员指定每个数组元素的初始值，由系统决定数组长度。</p><p>静态初始化的语法格式如下：</p><p><code>arrayName = new type[]&#123;element1,element2,element3 ... &#125;</code></p><p>其中<code>type</code>就是数组元素的数据类型，此处的<code>type</code>必须与定义数组变量时所使用的<code>type</code>相同，也可以定义数组时所指定的<code>type</code>的子类</p><p><strong>动态初始化</strong></p><p>数组的初始化和数组元素的赋值同时进行，初始化时程序员只指定数组长度，由系统为每个数组元素指定初始值。</p><p>动态初始化的语法格式如下：</p><p><code>arrayName = new type[length]</code></p><p>其中需要指定一个int的类型的length参数，这个参数指定了数组的长度，也就是可以容纳数组元素的个数。<code>type</code>与静态初始化类似。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//数组数据不能用投个变量名直接获取，需要用a[下标]</span></span><br><span class="line"><span class="comment">//数组定义</span></span><br><span class="line"><span class="comment">//第一种</span></span><br><span class="line"><span class="comment">//int[] b = &#123;1,2,3,4,5&#125;;</span></span><br><span class="line"><span class="comment">//第二种</span></span><br><span class="line"><span class="type">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//[]写在变量右侧是可以的，但一般不这么写</span></span><br><span class="line"><span class="comment">//第三种</span></span><br><span class="line"><span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];<span class="comment">//数组长度是固定的，需要声明</span></span><br><span class="line">c[<span class="number">1</span>] = <span class="number">3</span>;<span class="comment">//数组第二个元素存入3</span></span><br><span class="line"><span class="comment">//第四种</span></span><br><span class="line"><span class="type">int</span>[] e = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//可以先声明后初始化</span></span><br><span class="line"><span class="type">int</span>[] e1;<span class="comment">//声明</span></span><br><span class="line">e1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">System.out.println(e1[<span class="number">3</span>]);<span class="comment">//访问数值元素</span></span><br><span class="line">e1[<span class="number">3</span>] = <span class="number">8</span>;<span class="comment">//修改数组中元素内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问数组如果超过数组中元素的内容，就会报数组下标越界的错误</span></span><br><span class="line"><span class="comment">//System.out.println(e1[10]);//数组e1中只有5个元素，下标为0-4，e[10]会导致越界</span></span><br><span class="line"><span class="comment">//数组e1的长度</span></span><br><span class="line">System.out.println(<span class="string">&quot;e1数组长度：&quot;</span>+e1.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组最大访问下标</span></span><br><span class="line">System.out.println(e1[e1.length-<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>数组一旦初始化完成，数组的长度就确定了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> num;<span class="comment">//声明</span></span><br><span class="line">    num = <span class="number">10</span>;<span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;<span class="comment">//声明+初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一维数组的声明和初始化</span></span><br><span class="line">    <span class="type">int</span>[] ids;<span class="comment">//数组声明</span></span><br><span class="line">    <span class="comment">//静态初始化</span></span><br><span class="line">    ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;<span class="comment">//数组初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动态初始化</span></span><br><span class="line">    String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何调用数组指定位置的元素"><a href="#如何调用数组指定位置的元素" class="headerlink" title="如何调用数组指定位置的元素"></a>如何调用数组指定位置的元素</h4><p>通过角标（索引）的方式调用：<code>arr[i]</code>，数组的角标（索引）从0开始，到数组的长度-1结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line"> String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">    names[<span class="number">0</span>] = <span class="string">&quot;长城&quot;</span>;</span><br><span class="line">    names[<span class="number">1</span>] = <span class="string">&quot;故宫&quot;</span>;</span><br><span class="line">    names[<span class="number">2</span>] = <span class="string">&quot;天坛&quot;</span>;</span><br><span class="line">    names[<span class="number">3</span>] = <span class="string">&quot;鸟巢&quot;</span>;</span><br><span class="line">    names[<span class="number">4</span>] = <span class="string">&quot;圆明园&quot;</span>;</span><br><span class="line"><span class="comment">//  names[5] = &quot;颐和园&quot;;//索引越界异常</span></span><br><span class="line">    <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> names[<span class="number">4</span>].charAt(<span class="number">0</span>);<span class="comment">//提取字符串某一字符</span></span><br><span class="line">System.out.println(b);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果访问数组元素时指定值小于0，或大于等于数组长度，运行时会出现异常报错： java.lang.ArrayIndexOutOfBoundsException：N（数组索引越界异常），其中N就是我们试图访问的数组索引。</p><h4 id="如何获取数组的长度和遍历数组"><a href="#如何获取数组的长度和遍历数组" class="headerlink" title="如何获取数组的长度和遍历数组"></a>如何获取数组的长度和遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="comment">//获取数组长度，属性：length</span></span><br><span class="line">    System.out.println(a.length);<span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何遍历数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; a.length;i++)&#123;</span><br><span class="line">            System.out.println(a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="foreach-循环（增强for循环）"><a href="#foreach-循环（增强for循环）" class="headerlink" title="foreach 循环（增强for循环）"></a>foreach 循环（增强for循环）</h4><p>使用foreach 循环（增强for循环）遍历数组和集合元素时，无需获得数组和集合的长度，无需根据索引来访问数组元素和集合元素，foreach 循环（增强for循环）自动遍历数组和集合的每个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type variableName : array | collection)&#123;<span class="comment">//把冒号右边的数组遍历，遍历出来的元素放到定义的变量中</span></span><br><span class="line">    <span class="comment">//自动迭代访问每个数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>foreach 循环（增强for循环）和普通循环的不同是 ，它无须循环条件，无需迭代语句，这些由系统完成，当每个数组元素都被迭代一次后，foreach 循环（增强for循环）自动结束。</p><p>使用foreach 循环（增强for循环）迭代数组元素时，并不能改变数组元素的值，因此不需要对foreach 循环（增强for循环）的循环变量进行赋值。</p><h4 id="数组元素的默认初始化值"><a href="#数组元素的默认初始化值" class="headerlink" title="数组元素的默认初始化值"></a>数组元素的默认初始化值</h4><p>为数组的数组元素分配内存空间时，一旦分配完空间后，每个内存空间里存储的内容就是该数组元素的值，即使内存空间内存储的内容是空，也是有默认的值（null）</p><p><strong>数组的元素是基本数据类型：</strong></p><ul><li>数组类型是整型：0</li><li>数组类型是浮点型：0.0</li><li>数组类型是char型：0或’\u0000’，而非’0’</li><li>数组类型是boolean型：false</li></ul><p><strong>数组的元素是引用类型（String）：</strong>null</p><blockquote><p><strong>注意：</strong></p><p>不要同时使用静态初始化和动态初始化，也就是说，不要在进行数组初始化时，既指定数组长度也为每个数组元素分配初始值，错误代码如下</p><p><code>int[] arr = new int[5]&#123;1,2,3,4,5&#125;</code><label style="color:red"><strong>错误！！！</strong></label></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//数组元素是整型</span><br><span class="line">        int[] arr = new int[4];</span><br><span class="line">        for(int i = 0;i &lt; arr.length;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">    //数组元素是短整型</span><br><span class="line">        short[] arr1 = new short[4];//byte、long效果相同</span><br><span class="line">        for(int i = 0;i &lt; arr1.length;i++)&#123;</span><br><span class="line">            System.out.print(arr1[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">//数组元素是浮点型</span><br><span class="line">        float[] arr2 = new float[4]; //double效果相同</span><br><span class="line">        for(int i = 0;i &lt; arr2.length;i++)&#123;</span><br><span class="line">            System.out.print(arr2[i]+&quot; &quot;);</span><br><span class="line">            </span><br><span class="line">        System.out.println();</span><br><span class="line">            </span><br><span class="line">//数组元素是char型    </span><br><span class="line">        char[] arr3 = new char[4]; </span><br><span class="line">        for(int i = 0;i &lt; arr3.length;i++)&#123;</span><br><span class="line">            System.out.print(arr3[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        System.out.println();</span><br><span class="line">//数组元素是布尔型</span><br><span class="line">        boolean[] arr4 = new boolean[4]; </span><br><span class="line">        for(int i = 0;i &lt; arr4.length;i++)&#123;</span><br><span class="line">            System.out.print(arr4[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println();</span><br><span class="line">//数组元素是引用数据类型</span><br><span class="line">        String[] arr5 = new String[4]; </span><br><span class="line">        for(int i = 0;i &lt; arr5.length;i++)&#123;</span><br><span class="line">            System.out.print(arr5[i]+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>0 0 0 0<br>0 0 0 0<br>0.0 0.0 0.0 0.0</p><p>​                </p><p>false false false false </p><p>null null null null </p></blockquote><h4 id="一维数组的内存解析"><a href="#一维数组的内存解析" class="headerlink" title="一维数组的内存解析"></a>一维数组的内存解析</h4><p><strong>内存简化结构：</strong> </p><p><img src="https://i.loli.net/2021/10/12/BJ4tjI3lvLFigyD.png" alt="内存简化结构"></p><p><strong>一维数组的内存解析：</strong>    </p><h5 id=""><a href="#" class="headerlink" title=""></a><img src="https://i.loli.net/2021/10/12/BAoTGbafChUJ6Xj.png" alt="一维数组的内存解析"></h5><blockquote><p><strong>程序员进行程序开发时，不仅仅要停留在代码表面，而要深入底层的运行机制，才可以对程序的运行机制有更准确的把握。</strong></p></blockquote><p>看待一个数组时，要把数组看作两个部分：一部分是数组引用，也就是在代码中定义的数组变量；还有一部分是实际的数组对象，这部分是在堆内存里运行的，通常无法直接访问，只能通过数组引用变量来访问。</p><h3 id="二维数组的使用"><a href="#二维数组的使用" class="headerlink" title="二维数组的使用"></a>二维数组的使用</h3>]]></content>
      
      
      <categories>
          
          <category> 编程开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java运算符</title>
      <link href="/2020/10/14/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/java/"/>
      <url>/2020/10/14/Java%E5%90%8E%E7%AB%AF/Java%E5%9F%BA%E7%A1%80/java/</url>
      
        <content type="html"><![CDATA[<h1 id="Java定义的数据类型"><a href="#Java定义的数据类型" class="headerlink" title="Java定义的数据类型"></a>Java定义的数据类型</h1><h2 id="变量按照数据类型分"><a href="#变量按照数据类型分" class="headerlink" title="变量按照数据类型分"></a>变量按照数据类型分</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><blockquote><p>变量就是指在内存中开辟的存储空间，用于存放运算过程中需要用到的数据，变量是可变的。</p></blockquote><h4 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h4><p>Java是个强类型语言，所有变量必须<strong>先声明后使用</strong>，声明会对变量类型进行判断，指定的类型变量只能接收类型与之匹配的值 ，声明的语法只需要指定变量的类型和变量名即可。</p><h4 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;<span class="comment">//如果不给x进行赋值，是不能直接打印的</span></span><br></pre></td></tr></table></figure><p>如果要使用变量必须<strong>初始化</strong>，有两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在声明同时，直接初始化</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//先声明，后初始化</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><blockquote><p>整型：byte、short、int、long<br>浮点型：float、double<br>字符型：char<br>布尔型：boolean</p></blockquote><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><ul><li>Java各整数有固定的表数范围和字段长度，不受具体OS的影响，以保证Java程序的可移植性。</li><li>Java的整型常量默认为int型，声明long型产量须后加’l’或’L’</li><li><strong>Java程序中变量通常声明为int型，除非不足以表示较大的数，才使用long</strong></li></ul><table><thead><tr><th>类型</th><th>占用存储空间</th><th>表数范围</th></tr></thead><tbody><tr><td>byte</td><td>1字节=8bit位</td><td>-128~127</td></tr><tr><td>short</td><td>2字节</td><td>-2^15~2^15-1</td></tr><tr><td>int</td><td>4字节</td><td>-2^31~2^31-1(约21亿)</td></tr><tr><td>long</td><td>8字节</td><td>-2^63~2^63-1</td></tr></tbody></table><p><strong>注意</strong></p><blockquote><p>可以把一个较小的整数值直接赋值给long类型变量，Java并不会将这个变量当作long类型处理，Java依旧会将这个整数值当作int类型来处理，因为int类型的值会自动类型转换到long类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Text02</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123456</span>;</span><br><span class="line">System.out.println(l1);</span><br><span class="line">System.out.println(getType(l1));</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l2</span> <span class="operator">=</span> <span class="number">1234578</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>) (l2*<span class="number">1236789</span>);</span><br><span class="line">System.out.println(a);</span><br><span class="line">System.out.println(getType(a));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object a)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a.getClass().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Java表示进制数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java表示进制数</span></span><br><span class="line"><span class="type">int</span> 八进制 = <span class="number">010</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;八进制的“10”=&quot;</span>+八进制);</span><br><span class="line"><span class="type">int</span> 十六进制 = <span class="number">0x10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;十六进制的“10”=&quot;</span>+十六进制);</span><br><span class="line"><span class="type">int</span> 二进制 = <span class="number">0b10</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;二进制的“10”=&quot;</span>+二进制);</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出：</strong></p><p>八进制的“10”=8<br>十六进制的“10”=16<br>二进制的“10”=2</p></blockquote><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><ul><li>与整数类型类似，Java浮点类型也有固定的表数范围和字段长度，不受具体操作系统的影响。</li><li>float：单精度4字节，尾数可以精确到7为有效数字，很多情况下，精度很难满足。<br>double：双精度8字节，精度是float的两倍，通常采用此类型。</li><li><strong>Java的浮点型常量默认为double型，声明float型常量，须后加’f’或’F’</strong></li></ul><p>Java表示浮点数的两种方法：</p><blockquote><p>十进制数形式：这种形式就是简单的浮点数，如5.12、512.0、.512。<strong>浮点数必须包含一个小数，否则会被当初int类型处理</strong>。</p><p>科学计数法：如5.12e2（记5.12*10^2^）不区分大小写。</p></blockquote><h4 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h4><ul><li>char型数据用来表示通常意义上“字符”(2字节)</li><li>Java中所有字符都使用Unicode编码，故一个字符可以储存一个字母，一个汉字，或其他书面语的一个字符。</li><li>字符型变量的三种表现形式：<br>字符常量是用单引号 ‘’ 括起来的单个字符。例如：char c1 = ‘a’;char c2 = ‘中’;char c3 = ‘9’</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;9&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Java中还允许使用转义字符”\“来将其后的字符转变为特殊字符型常量。<br>直接使用Unicode值来表示字符型常量：’\XXXX’。其中，XXXX代表一个十六进制整数。</p><p><img src="https://i.loli.net/2021/09/14/R1Wrspj8danuJUY.png"></p><ul><li>char类型的值可以直接作为整数值来使用，相当于16位的无符号整数，表数范围为0～65535。</li><li>char类型是可以进行运算的。因为它都对应Unicode码，实际是用该字符对应编码参与运算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">char</span> <span class="variable">aChar</span> <span class="operator">=</span> <span class="string">&#x27;你&#x27;</span>;</span><br><span class="line">System.out.println(aChar);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接将一个char变量当作int类型变量使用</span></span><br><span class="line"><span class="type">int</span> <span class="variable">aValue</span> <span class="operator">=</span> aChar;</span><br><span class="line">System.out.println(aValue);</span><br><span class="line"></span><br><span class="line"><span class="comment">//直接将一个0～65535范围内整数赋值给char类型变量</span></span><br><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">99</span>;</span><br><span class="line">System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出</strong>：</p><p>你<br>20320<br>c</p></blockquote><p><strong>字符串</strong></p><p>Java没有提供表示字符串的基本数据类型，而是通过String类型表示字符串，字符串由多个字符组成，字符串要用双引号括起来。</p><p><strong>字符串拼接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo01</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//字符串拼接——从左向右拼接</span></span><br><span class="line">System.out.println(<span class="number">1</span>+<span class="number">2</span>+<span class="string">&quot;你好&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;你好&quot;</span>+<span class="number">1</span>+<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;你好&quot;</span>+(<span class="number">1</span>+<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>输出</strong></p><p>3你好<br>你好12<br>你好3</p></blockquote><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p><em><strong>只能取两个值之一：true、false</strong></em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(isMarried)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你就不能参加单身party了！很遗憾&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;你可以多谈恋爱！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本数据类型之间的运算规则"><a href="#基本数据类型之间的运算规则" class="headerlink" title="基本数据类型之间的运算规则"></a>基本数据类型之间的运算规则</h3><ul><li><p>自动类型提升<br>  当容量小的数据类型的变量与容量打的数据类型的变量做运算时，结果自动提升为容量大的数据类型。<br>  说明：此时容量大小指的是，表示数的范围大和小。比如：float容量大于long的容量。<br>  <strong>byte、char、short –&gt; int –&gt; long –&gt; float –&gt; double</strong></p><p>  <em><strong>当 byte、char、short三种类型的变量做运算时，结果为int类型</strong></em></p></li></ul><ul><li>强制类型转换（自动类型提升运算的逆运算）</li></ul><ul><li>需要使用强转符：()</li><li>强制类型转换，可能导师精度损失。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//精度损失</span></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.9</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)d1;<span class="comment">//阶段操作，强转为int型</span></span><br><span class="line">System.out.println(i1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有精度损失</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>)l1;</span><br><span class="line">System.out.println(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//精度损失</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i2;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出<br>12<br>123<br>-128</p></blockquote><h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p><strong>String类型变量的使用</strong></p><ul><li>String属于引用的数据类型（字符串）</li><li>声明String类型变量时，使用 “”</li><li>String可以和八种基本数据类型变量做运算，且运算只能是连接运算。</li><li>运算的结果仍然是String类型</li></ul><blockquote></blockquote><p>类(class)<br>接口(interface)<br>数组(array)</p><hr><h1 id="Java的运算符"><a href="#Java的运算符" class="headerlink" title="Java的运算符"></a>Java的运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">运算</th><th align="center">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">正号</td><td align="center">+3</td><td align="center">3</td></tr><tr><td align="center">-</td><td align="center">负号</td><td align="center">b=4;b</td><td align="center">-4</td></tr><tr><td align="center">+</td><td align="center">加</td><td align="center">5+5</td><td align="center">10</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">6-4</td><td align="center">2</td></tr><tr><td align="center">*</td><td align="center">乘</td><td align="center">3*4</td><td align="center">12</td></tr><tr><td align="center">/</td><td align="center">除</td><td align="center">5/5</td><td align="center">1</td></tr><tr><td align="center">%</td><td align="center">取模（取余）</td><td align="center">7%5</td><td align="center">2</td></tr><tr><td align="center">++<br>++</td><td align="center">自增（前）：先运算后取值<br>自增（后）：先取值后运算</td><td align="center">a=2;++a<br>a=2;a++</td><td align="center">a=3;b=3<br>a=3;b=2</td></tr><tr><td align="center">- -<br>- -</td><td align="center">自减（前）：先运算后取值<br>自减（后）：先取值后运算</td><td align="center">a=2;- -a<br>a=2;a- -</td><td align="center">a=1;b=1<br>a=1;b=2</td></tr><tr><td align="center">+</td><td align="center">字符串连接</td><td align="center">“He”+”llo”</td><td align="center">“Hello”</td></tr></tbody></table><ul><li><p>取余运算的符号与被模数的符号相同。</p></li><li><p>开发中，经常使用%来判断能否被除尽的情况。</p></li><li><p>（前）++：先自增1，后运算；（后）++：先运算，后自增1</p></li><li><p>（前）- -：先自减1，后运算；（后）- -：先运算，后自减1</p></li></ul><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p><strong>符号：=</strong></p><ul><li>当 “=” 两侧数据类型不一致时，可以使用自动类型转化或使用强制类型转换原则进行处理。</li><li><strong>支持连续赋值。</strong></li><li>扩展赋值运算符：+=、-=、*=、/=、%=</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//变量实现+1的操作的方法</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line">num = num + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">num += <span class="number">1</span>;<span class="comment">//不会改变数据类型</span></span><br><span class="line"><span class="comment">//方法三</span></span><br><span class="line">num++；</span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">运算</th><th align="center">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">相等于</td><td align="center">4==3</td><td align="center">false</td></tr><tr><td align="center">!=</td><td align="center">不等于</td><td align="center">4!=3</td><td align="center">true</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">4&lt;3</td><td align="center">false</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">4&gt;3</td><td align="center">false</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center">4&lt;=3</td><td align="center">true</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center">4&gt;=3</td><td align="center">true</td></tr><tr><td align="center">instanceof</td><td align="center">检查是否是类的对象</td><td align="center">“Hello”instanceof String</td><td align="center">true</td></tr></tbody></table><ul><li>比较运算符的结果都是boolean型，要么是true，要么是false。</li><li><strong>比较运算符”==”不能误写为”=”</strong> </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CompareTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(i == j);</span><br><span class="line">System.out.println(i = j);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">System.out.println(b2 == b1);</span><br><span class="line">System.out.println(b2 = b1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>    false<br>    20<br>    false<br>    true</p></blockquote><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p><strong>&amp; –&gt; 逻辑与、| –&gt; 逻辑或、! –&gt; 逻辑非、&amp;&amp; –&gt; 短路与、|| –&gt; 短路或、^ –&gt; 逻辑异或</strong></p><table><thead><tr><th align="center">a</th><th align="center">b</th><th align="center">a&amp;b</th><th align="center">a&amp;&amp;b</th><th align="center">a &#124; b</th><th align="center">a &#124;&#124; b</th><th align="center">!a</th><th align="center">a^b</th></tr></thead><tbody><tr><td align="center">true</td><td align="center">true</td><td align="center">true</td><td align="center">true</td><td align="center">true</td><td align="center">true</td><td align="center">false</td><td align="center">false</td></tr><tr><td align="center">true</td><td align="center">false</td><td align="center">false</td><td align="center">false</td><td align="center">true</td><td align="center">true</td><td align="center">false</td><td align="center">false</td></tr><tr><td align="center">false</td><td align="center">true</td><td align="center">false</td><td align="center">false</td><td align="center">true</td><td align="center">true</td><td align="center">true</td><td align="center">true</td></tr><tr><td align="center">false</td><td align="center">false</td><td align="center">false</td><td align="center">false</td><td align="center">false</td><td align="center">false</td><td align="center">true</td><td align="center">false</td></tr></tbody></table><ul><li>逻辑运算符操作的都是bollean类型的变量</li></ul><p>**区分 &amp; 与 &amp;&amp; **</p><ul><li>相同点1： &amp; 与 &amp;&amp;的运算结果相同。</li><li>相同点2：当符号左边是true时，二者都会执行符号右边的运算。</li><li>不同点：当符号左边是false时，&amp; 继续执行符号右边的运算，而 &amp;&amp; 不再执行右边的运算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b1 &amp; (num1++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span>+num1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//短路与 &amp;&amp; 判断为false，后面不执行，前后都要是true</span></span><br><span class="line"><span class="keyword">if</span>(b1 &amp;&amp; (num2++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num2 = &quot;</span>+num2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>    我现在在南京<br>    num1 = 11<br>    我现在在南京<br>    num1 = 10</p></blockquote><p><strong>区分 | 与 ||</strong></p><ul><li>相同点1： | 与 || 的运算结果相同。</li><li>相同点2：当符号左边是false时，二者都会执行符号右边的运算。</li><li>不同点：当符号左边是true时，| 继续执行符号右边的运算，而 || 不再执行右边的运算。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LogicTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span>(b3 | (num3++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num3 = &quot;</span>+num3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b4</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num4</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//短路或 || 判断为true，后面不执行，前后都要是false</span></span><br><span class="line"><span class="keyword">if</span>(b4 || (num4++ &gt; <span class="number">0</span>))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在北京&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;我现在在南京&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;num4 = &quot;</span>+num4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>    我现在在南京<br>    num1 = 11<br>    我现在在南京<br>    num1 = 10</p></blockquote><p><em><strong>开发中推荐使用短路与和短路或</strong></em></p><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><ul><li>位运算符操作都是整型的数据</li><li>“&lt;&lt;”：在一定范围内，每向左移一位，相当于*2</li><li>“&gt;&gt;”：在一定范围内，每向右移一位，相当于/2</li></ul><table><thead><tr><th align="center">运算符</th><th align="center">运算</th><th align="center">范例</th></tr></thead><tbody><tr><td align="center">&lt;&lt;</td><td align="center">左移</td><td align="center">3 &lt;&lt; 2 = 12–&gt;3<em>2</em>2=12</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移</td><td align="center">3 &gt;&gt; 1 = 1–&gt;3/2=1</td></tr><tr><td align="center">&gt;&gt;&gt;</td><td align="center">无符号右移</td><td align="center">3 &gt;&gt;&gt; 1 = 1–&gt;3/2=1</td></tr><tr><td align="center">&amp;</td><td align="center">与运算</td><td align="center">6&amp;3 = 2</td></tr><tr><td align="center">&#124;</td><td align="center">或运算</td><td align="center">6 &#124; 3 = 7</td></tr><tr><td align="center">^</td><td align="center">异或运算</td><td align="center">6^3 = 5</td></tr><tr><td align="center">~</td><td align="center">取反运算</td><td align="center">~6 = -7</td></tr></tbody></table><p><strong>交换两个变量的值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法一：定义临时变量的方式</span></span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：好处：不用定义临时变量</span></span><br><span class="line"><span class="comment">//弊端：1、相加操作可能超出存储范围。2、有局限性，只适用于数值类型。</span></span><br><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 + num2;</span><br><span class="line">num1 = num1 - num2;</span><br><span class="line">System.out.println(<span class="string">&quot;num1 = &quot;</span> + num1 +<span class="string">&quot;,num2 = &quot;</span>+ num2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法三：使用位运算符</span></span><br><span class="line">num1 = num1 ^ num2;</span><br><span class="line">num2 = num1 ^ num2;</span><br><span class="line">num1 = num1 ^ num2;</span><br></pre></td></tr></table></figure><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h2><ul><li>结构：(条件表达式)?表达式1 : 表达式2</li><li>条件表达式的结果为boolean类型</li><li>根据条件表达式的结果为boolean类型</li><li>根据条件表达式真或假，决定执行表达式1，还是表达式2。如果表达式为true，则执行表达式1，如果表达式为false，则执行表达式2。</li><li>表达式1和表达式2要求是一致的类型</li><li>三元运算符是可以嵌套的。</li><li>凡是可以用三元运算符的地方，都可以改写为if-else</li><li>如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。（简洁、执行效率高）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SanYuanTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//获取两个整数较大值</span></span><br><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (m &gt; n)? m : n;</span><br><span class="line">System.out.println(max);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><ul><li>运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。上一行运算符总优先于下一行。</li><li>只有单目运算符、三元运算符、赋值运算符是从右向左运算的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程开发学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模模型算法</title>
      <link href="/2020/08/28/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo05/"/>
      <url>/2020/08/28/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo05/</url>
      
        <content type="html"><![CDATA[<h1 id="数学建模的分类"><a href="#数学建模的分类" class="headerlink" title="数学建模的分类"></a>数学建模的分类</h1><p><strong>按模型的数学方法分</strong></p><blockquote><p>几何模型、图论模型、微分方程模型、概率模型、最优控制模型、规划论模型、马氏链模型等</p></blockquote><p><strong>按模型的特征分</strong></p><blockquote><p>静态和动态模型，确定性模型和随机模型，离散模型和连续性模型、线性模型和非线性模型等</p></blockquote><p><strong>按模型的应用领域分</strong></p><blockquote><p>人口模型、交通模型、经济模型、生态模型、资源模型、环境模型等</p></blockquote><p><strong>按建模的目的分</strong></p><blockquote><p>预测模型、优化模型、决策模型、控制模型等</p></blockquote><p><strong>按对模型的结构了解程度分</strong></p><blockquote><p>白箱模型、灰箱模型、黑箱模型等</p></blockquote><hr><h1 id="十大算法"><a href="#十大算法" class="headerlink" title="十大算法"></a>十大算法</h1><p><strong>1、蒙特卡洛算法（随机性模拟算法）</strong></p><blockquote><p>通过计算机仿真来解决问题的算法，同时可以通过模拟来检验自己模型的正确性</p></blockquote><p><strong>2、数据拟合、参数估计、插值等数据处理算法</strong></p><blockquote><p>处理大量数据</p></blockquote><p><strong>3、线性规划、整数规划、多元规划、二次规划等规划类问题</strong></p><blockquote><p>建模竞赛大多数问题属于最优化问题，很多时候可以用数学规划算法来描述</p></blockquote><p><strong>4、图论算法</strong></p><blockquote><p>包括最短路、网络流、二分图等算法<strong>必须掌握</strong></p></blockquote><p>**5、动态规划、回溯搜索、分治算法、分支定界等计算机算法</p><blockquote><p>这些问题时用来解决一些较困难的最优化问题的算法</p></blockquote><p><strong>6、最优化理论的经典算法：模拟退火、神经网路、遗传算法</strong></p><blockquote><p>解决较难的最优化问题的算法，算法比较难实现</p></blockquote><p><strong>7、网格算法和穷举法</strong></p><blockquote><p>暴力解题方法</p></blockquote><p><strong>8、一些连续离散化方法</strong></p><blockquote><p>很多问题都是从实际来的，数据可以是连续的，而计算机只认识离散的数据，因此将其离散化后进行差分代替微分、求和代替积分等是非常重要的</p></blockquote><p><strong>9、数值分析算法</strong></p><blockquote><p>进行高级语言进行编程，一些数值分析常用的算法比如方程组求解、矩阵运算、函数积分等算法就需要额外编写库函数进行调用</p></blockquote><p><strong>10、图像处理算法</strong></p><blockquote><p>与图形有关，即使与图形无关，论文中也应该要又较多图片。图形如何展示以及处理就是需要处理的问题</p></blockquote><hr><h1 id="建模思想"><a href="#建模思想" class="headerlink" title="建模思想"></a>建模思想</h1><h2 id="预测与预报"><a href="#预测与预报" class="headerlink" title="预测与预报"></a>预测与预报</h2><p><strong>1、灰色预测模型（必掌握）</strong></p><blockquote><p><strong>满足两个条件可用</strong><br>    数据样本点个数少，6-15个<br>    数据呈指数或曲线形式</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数学模型分类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建模学习（四）</title>
      <link href="/2020/07/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo04/"/>
      <url>/2020/07/25/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo04/</url>
      
        <content type="html"><![CDATA[<h1 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h1><p><strong>在相关系数中最常用的是皮尔逊（person）相关系数和斯皮尔曼（spearman）等级相关系数。它们可以用来衡量两个变量之间的相关性的大叫，根据数据满足的不同条件，选择不同的相关系数进行计算和分析</strong></p><h2 id="总体和样本"><a href="#总体和样本" class="headerlink" title="总体和样本"></a>总体和样本</h2><p><strong>总体：</strong>所要考察对象的全部个体叫做总体。</p><p><strong>样本：</strong>从总体所抽取的一部分个体叫做总体的一个样本</p><p><strong>总体的估计量可以通过计算抽取的样本的统计量来计算</strong></p><blockquote><p>例如使用<strong>样本均值、样本标准差</strong>来估计<strong>总体的均值（平均水平）和总体的标准差（偏离程度）。</strong></p></blockquote><h2 id="皮尔逊Person相关系数"><a href="#皮尔逊Person相关系数" class="headerlink" title="皮尔逊Person相关系数"></a>皮尔逊Person相关系数</h2><p>运用皮尔逊相关系数时，必须先确认比较的像个变量是线性相关的</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相关系数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建模学习（三）</title>
      <link href="/2020/07/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo03/"/>
      <url>/2020/07/24/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo03/</url>
      
        <content type="html"><![CDATA[<h1 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><strong>在题中遇到大量数据需要处理时，题目给出的数据往往都存在坏点数据或数据异常。而数据拟合、参数估计、插值等数据处理算法往往是处理这些数据的关键。</strong></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>在实际中，常常要处理由实验或测量所得到的一些离散数据。插值与你和方法就是要通过这些数据去确定某一类已知函数的参数或寻求某个近似函数，使所得到的近似函数与已知数据有较高的拟合精度。</p><p>如果要求这个近似函数（曲线或曲面）经过所已知的所有数据点，则称此类问题为<strong>插值问题</strong>。<em><strong>（不需要函数表达式）</strong></em></p><p>如果不要近似函数通过所有数据点，而是要求它能够较好地反映数据变化规律的近似函数的方法称为<strong>数据拟合</strong>。<em><strong>（必须有函数表达式）</strong></em><br>近似函数不一定（曲线或曲面）通过所有的数据点</p><h3 id="插值与拟合的区别和联系"><a href="#插值与拟合的区别和联系" class="headerlink" title="插值与拟合的区别和联系"></a>插值与拟合的区别和联系</h3><p><strong>1、联系</strong></p><p>都是根据实际中一组已知的数据来构造一个能够反映数据变化规律的近似函数的方法</p><p><strong>2、区别</strong></p><p><strong>插值问题</strong>不一定得到近似函数的表达式，仅通过插值方法找到位置点对应的值。<strong>数据拟合</strong>要求得倒一个具体的近似函数的表达式。</p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><h3 id="插值的使用及求解"><a href="#插值的使用及求解" class="headerlink" title="插值的使用及求解"></a>插值的使用及求解</h3><p>当数据量不够，需要补充，且认定已有数据可信时，通常利用函数插值方法。</p><h3 id="插值方法"><a href="#插值方法" class="headerlink" title="插值方法"></a>插值方法</h3><p><strong>1.最近邻算法插值（一维插值）</strong><br><strong>2.拉格朗日插值算法（一维插值）</strong><br><strong>3.双线性内插算法（二维插值）</strong><br><strong>4.分段线性插值（二维插值）</strong><br><strong>5.三次样条插值（二维插值）</strong><br><strong>6.克里金插值（地理学）</strong><br><strong>7.反距离权重插值算法（地理学）</strong></p><h2 id="插值的MATLAB实现"><a href="#插值的MATLAB实现" class="headerlink" title="插值的MATLAB实现"></a>插值的MATLAB实现</h2><p>实现分段线性插值不需要编写函数程序，matlab提供了内部的功能函数</p><p><strong>interp1(一维插值)</strong><br><strong>interp2(二维插值)</strong><br><strong>interp3(三维插值)</strong><br><strong>intern(n维插值)</strong></p><h3 id="一维插值"><a href="#一维插值" class="headerlink" title="一维插值"></a>一维插值</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">yi = interp1(x,y,xi,<span class="string">&#x27;method&#x27;</span>) <span class="comment">% x,y为插值节点；xi是被插值点；method是插值方法；yi是xi出的插值点的函数值</span></span><br><span class="line"><span class="comment">% &#x27;nearest&#x27;：最佳邻近插值</span></span><br><span class="line"><span class="comment">% &#x27;linear&#x27;：线性插值</span></span><br><span class="line"><span class="comment">% &#x27;spline&#x27;：三次样条插值</span></span><br><span class="line"><span class="comment">% &#x27;cubic&#x27;：立方插值</span></span><br><span class="line"><span class="comment">% 缺省时：分段线性插值</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>注：所有的插值方法都要求x是单调的，并别xi不能够超过x的范围。</strong></p><p>例：从1点到12点的11小时内，每隔1小时测量一次温度，测得的温度的数值依次为：5，8，9，15，25，39，31，30，22，25，17，24，试估计每隔1/10小时的温度值。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">hours = <span class="number">1</span>:<span class="number">12</span>;</span><br><span class="line">temps = [<span class="number">5</span> <span class="number">8</span> <span class="number">9</span> <span class="number">15</span> <span class="number">25</span> <span class="number">29</span> <span class="number">31</span> <span class="number">30</span> <span class="number">22</span> <span class="number">25</span> <span class="number">27</span> <span class="number">24</span>];</span><br><span class="line">h = <span class="number">1</span>:<span class="number">0.1</span>:<span class="number">12</span>; <span class="comment">% 插值区间</span></span><br><span class="line">t = interp1(hours,temps,h,<span class="string">&#x27;spline&#x27;</span>); <span class="comment">% 使用三次样条插值方法，得到插值后的矩阵t</span></span><br><span class="line"><span class="built_in">plot</span>(hours,temps,<span class="string">&#x27;+&#x27;</span>,h,t,hours,temps,<span class="string">&#x27;r:&#x27;</span>); <span class="comment">% 将插值前与插值后的函数图像画出</span></span><br><span class="line">xlabel(<span class="string">&#x27;Hour&#x27;</span>),ylabel(<span class="string">&#x27;Degrees Celsius&#x27;</span>) <span class="comment">% 横纵坐标名</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>输出</strong><br><img src="https://i.loli.net/2020/07/24/zImTwMXi4NpbuA9.png" alt="7_24_01.png"></p><h3 id="二维插值函数"><a href="#二维插值函数" class="headerlink" title="二维插值函数"></a>二维插值函数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">z = interp2(x0,y0,z0,x,y,<span class="string">&#x27;method&#x27;</span>) <span class="comment">% x0,y0为插值节点；x,y是被插值点；method是插值方法；z是被插值点的函数值</span></span><br><span class="line"><span class="comment">% &#x27;nearest&#x27;：最佳邻近插值</span></span><br><span class="line"><span class="comment">% &#x27;linear&#x27;：线性插值</span></span><br><span class="line"><span class="comment">% &#x27;cubic&#x27;：立方插值</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>注：要求x0，y0电调；x，y可取为矩阵，或x取行向量，y取为列向量x，y的值分别不能超出x0，y0的范围</strong></p><p>例：测得平板表面3×5网格点出的温度分别为：</p><blockquote><p>82 81 80 82 84<br>79 63 61 65 81<br>84 84 82 85 86<br>试作出平板标目暗的温度分布曲线z=f(x,y)的图形</p></blockquote><p><strong>1.先在三位坐标画出原始数据，画出粗糙的温度分布曲线图</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">x = <span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">y = <span class="number">1</span>:<span class="number">3</span>;</span><br><span class="line">temps = [<span class="number">82</span> <span class="number">81</span> <span class="number">80</span> <span class="number">82</span> <span class="number">84</span> ;<span class="number">79</span> <span class="number">63</span> <span class="number">61</span> <span class="number">65</span> <span class="number">81</span>;<span class="number">84</span> <span class="number">84</span> <span class="number">82</span> <span class="number">85</span> <span class="number">86</span>];</span><br><span class="line">mesh(x,y,temps) <span class="comment">%未插值前三维图像</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>2.以平滑数据在x,y方向是每隔0.02个单位进行插值</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">xi = <span class="number">1</span>:<span class="number">0.02</span>:<span class="number">5</span>;</span><br><span class="line">yi = <span class="number">1</span>:<span class="number">0.02</span>:<span class="number">3</span>;</span><br><span class="line">zi = interp2(x,y,temps,xi&#x27;,yi,<span class="string">&#x27;cubic&#x27;</span>) <span class="comment">%空间二维插值</span></span><br><span class="line">mesh(xi,yi,zi)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>输出：</strong><br><img src="https://i.loli.net/2020/07/24/BgI5SYqAt8rNmac.png" alt="7_24_02.png"></p><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><h3 id="拟合的使用及求解"><a href="#拟合的使用及求解" class="headerlink" title="拟合的使用及求解"></a>拟合的使用及求解</h3><p>对于情况复杂的实际问题（因素不易化简，作用机理不详）可直接使用数据组建模，寻找简单的因果变量之间的数量关系，从而对未知的情形作预报。这样组建的模型为拟合模型。<br>拟合模型的组件主要是处理好观测数据的误差，使用数学表达式从数量上近似因果变量之间爱你的关系。拟合模型的组件是通过对有关变量的观测数据的观察、分析和<strong>选择恰当的数学表达式</strong>得到的。</p><h3 id="直线拟合和曲线拟合"><a href="#直线拟合和曲线拟合" class="headerlink" title="直线拟合和曲线拟合"></a>直线拟合和曲线拟合</h3><p><strong>直线拟合</strong></p><p><strong>曲线拟合</strong></p><p><strong>问题提出：</strong></p><p>已知一组（二维）数据，即平台上n个点(xi,yi)i=1,…,n，寻求一个函数（曲线）y=f(x)，使f(x)在某种准则下与所有数据点最为接近，即曲线拟合得最好</p><p><img src="https://i.loli.net/2020/07/24/1QiLjCkgnIMPGw7.jpg" alt="7_24_03.PNG"></p><p><strong>曲线拟合最常用解法——线性最小二乘法基本思路</strong></p><p><img src="https://i.loli.net/2020/07/24/Qn58qNLdmolsaVe.png" alt="7_24_04.PNG"></p><p><strong>用MATLAB作线性最小二乘拟合</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">a = polyfit(x,y,m) <span class="comment">%输入相同长度的数组x,y; m为拟合多项式次数</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>多项式在x处的值y可以用以下命令计算：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">y = polyval(a,x)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>实例代码：</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">1</span>;</span><br><span class="line">y = [<span class="number">-0.447</span> <span class="number">1.978</span> <span class="number">3.28</span> <span class="number">6.16</span> <span class="number">7.08</span> <span class="number">7.34</span> <span class="number">7.66</span> <span class="number">9.56</span> <span class="number">9.48</span> <span class="number">9.30</span> <span class="number">11.2</span>];</span><br><span class="line">A = polyfit(x,y,<span class="number">2</span>)</span><br><span class="line">z = polyval(A,x)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;k+&#x27;</span>,x,z,<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><blockquote><p>A =<br>  -9.8108   20.1293   -0.0317</p></blockquote><p><img src="https://i.loli.net/2020/07/24/nmBcV8sQWk3I6ri.png" alt="7_24_05.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 插值与拟合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建模学习(二)</title>
      <link href="/2020/07/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo02/"/>
      <url>/2020/07/21/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo02/</url>
      
        <content type="html"><![CDATA[<h1 id="TOPSIS算法（优劣解距离法）"><a href="#TOPSIS算法（优劣解距离法）" class="headerlink" title="TOPSIS算法（优劣解距离法）"></a>TOPSIS算法（优劣解距离法）</h1><p>TOPSIS法是一种常用的综合评价方法，能充分利用原始数据的信息，所得出结果能精确地反映各评价方案之间的差距。</p><h2 id="基本过程"><a href="#基本过程" class="headerlink" title="基本过程"></a>基本过程</h2><blockquote><p>先将原始数据矩阵统一指标类型<strong>（一般正向化处理）</strong>得倒正向化矩阵，在对正向化的矩阵进行标准化处理以消除个别指标量纲的影响，并找到有限方案中的<strong>最优方案</strong>和<strong>最劣方案</strong>，然后分别计算各评价对象与的最优方案和最劣方案间的距离，获得各评价对象与最优方案的相对接近程度，以此作为评价优劣的依据。该方法对数据分布及样本含量没有严格的限制，数据计算简单易行。</p></blockquote><h2 id="常见的四种指标"><a href="#常见的四种指标" class="headerlink" title="常见的四种指标"></a>常见的四种指标</h2><table><thead><tr><th align="center">指标名称</th><th align="center">指标特点</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">极大型（效益型）指标</td><td align="center">越大（多）越好</td><td align="center">成绩、CDP增速、企业利润</td></tr><tr><td align="center">极小型（成本型）指标</td><td align="center">越小（少）越好</td><td align="center">费用、坏品率、污染程度</td></tr><tr><td align="center">中间型指标</td><td align="center">越接近某个值越好</td><td align="center">水质量评估时的PH值</td></tr><tr><td align="center">区间型指标</td><td align="center">落在某个区间最好</td><td align="center">体温、水中植物性营养物量</td></tr></tbody></table><hr><h2 id="第一步：将原始矩阵正向化"><a href="#第一步：将原始矩阵正向化" class="headerlink" title="第一步：将原始矩阵正向化"></a>第一步：将原始矩阵正向化</h2><p><strong>所谓将原式矩阵正向化，就是要将所有的指标类型统一转化为极大型指标。（转换的函数形式可以不唯一）</strong></p><h3 id="1、极小型-→-极大型"><a href="#1、极小型-→-极大型" class="headerlink" title="1、极小型 → 极大型"></a>1、极小型 <strong>→</strong> 极大型</h3><p><strong>公式</strong><br><img src="https://i.loli.net/2020/07/22/IdxEJBaSpQ6Ofe2.png" alt="极小型转为极大型公式.png"></p><p>如果所有元素均为正数，也可以使用1/x</p><h3 id="1、中间型指标-→-极大型指标"><a href="#1、中间型指标-→-极大型指标" class="headerlink" title="1、中间型指标 → 极大型指标"></a>1、中间型指标 <strong>→</strong> 极大型指标</h3><p><strong>中间型指标：</strong>总体既不要太大也不要太小，取某特定值最好（如水质量评估PH值）</p><p><img src="https://i.loli.net/2020/07/22/QpOEuZ8FNA9ex5X.png"><br><img src="https://i.loli.net/2020/07/22/1C8kzrfJqWAmR52.png" alt="正向化公式.png"></p><h3 id="2、区间型指标-→-极大型指标"><a href="#2、区间型指标-→-极大型指标" class="headerlink" title="2、区间型指标 → 极大型指标"></a>2、区间型指标 <strong>→</strong> 极大型指标</h3><p><strong>区间型指标：</strong>指标值落在某个区间内最好（例如人的体温在36℃~37℃区间比较安全）</p><p><img src="https://i.loli.net/2020/07/22/3bsnEi4kTKuM8Z5.png" alt="7-22-02.png"></p><h2 id="第二步：正向化矩阵标准化"><a href="#第二步：正向化矩阵标准化" class="headerlink" title="第二步：正向化矩阵标准化"></a>第二步：正向化矩阵标准化</h2><p><strong>标准化的目的是消除不同指标量纲的影响</strong></p><p><img src="https://i.loli.net/2020/07/22/bj1X32tJ8xwYkBr.png" alt="03.png"></p><h2 id="第三步：计算得分"><a href="#第三步：计算得分" class="headerlink" title="第三步：计算得分"></a>第三步：计算得分</h2><p><img src="https://i.loli.net/2020/07/22/iCY5KwA6Oth7oaE.png" alt="04.png"></p><hr><h2 id="模型拓展"><a href="#模型拓展" class="headerlink" title="模型拓展"></a>模型拓展</h2><h3 id="带权重的TOPSIS"><a href="#带权重的TOPSIS" class="headerlink" title="带权重的TOPSIS"></a>带权重的TOPSIS</h3><p><img src="https://i.loli.net/2020/07/22/PTXOwjkfKQs6Bud.png" alt="05.png"></p><hr><h1 id="TOPSIS算法matlab实现"><a href="#TOPSIS算法matlab实现" class="headerlink" title="TOPSIS算法matlab实现"></a>TOPSIS算法matlab实现</h1><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><h2 id="第一步：载入数据"><a href="#第一步：载入数据" class="headerlink" title="第一步：载入数据"></a>第一步：载入数据</h2><p><strong>数据处理方法</strong></p><ol><li><p>在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</p></li><li><p>在Excel中复制数据，再回到Excel中右键，点击粘贴Excel数据（Ctrl+Shift+V）</p></li><li><p>关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</p></li><li><p>注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。</p></li></ol><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat <span class="comment">%加载保存的数据</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="第二步：判断数据是否需要正向化"><a href="#第二步：判断数据是否需要正向化" class="headerlink" title="第二步：判断数据是否需要正向化"></a>第二步：判断数据是否需要正向化</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">[n,m] = <span class="built_in">size</span>(X); <span class="comment">% 保存矩阵行数和列数</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) <span class="comment">% 统计矩阵行列数并输出 </span></span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]); <span class="comment">%字符串合并，使用空格或“,”连接两串字符</span></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列： &#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>) <span class="comment">% 确定对应列指标类型</span></span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>);</span><br><span class="line">    <span class="comment">% Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TOPSIS算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次分析法代码实现</title>
      <link href="/2020/07/20/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/ccfx/"/>
      <url>/2020/07/20/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/ccfx/</url>
      
        <content type="html"><![CDATA[<h1 id="输入判断矩阵"><a href="#输入判断矩阵" class="headerlink" title="输入判断矩阵"></a>输入判断矩阵</h1><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clear;clc %清除变量和命令窗口</span><br><span class="line">disp(&#x27;请输入判断矩阵A： &#x27;) %输入函数 自定义矩阵输入</span><br></pre></td></tr></table></figure></code></pre><h1 id="计算权重"><a href="#计算权重" class="headerlink" title="计算权重"></a>计算权重</h1><h2 id="方法1：算数平均法求权重"><a href="#方法1：算数平均法求权重" class="headerlink" title="方法1：算数平均法求权重"></a>方法1：算数平均法求权重</h2><p><strong>1、将判断矩阵按照列进行归一化处理（每一个元素初一其所在列的和）</strong></p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Sum_A = sum(A) %矩阵按列相加</span><br><span class="line">[m,n] = size(A) %取矩阵的行数m，列数n</span><br><span class="line">SUM_A=repmat(Sum_A,n,1); %按行重复n次sum_A函数</span><br><span class="line">Stand_A = A ./ SUM_A; %A和SUM_A矩阵对应行相除；即将判断矩阵按照列归一化</span><br><span class="line">disp(&#x27;算术平均法求权重的结果为：&#x27;); %输出函数</span><br></pre></td></tr></table></figure></code></pre><p><strong>2、将归一化的各列相加(按行求和)</strong><br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(Stand_A,2);</span><br></pre></td></tr></table></figure></p><p><strong>3、将相加后得到的向量中每个元素除以n即可得到权重向量</strong><br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;算术平均法求权重的结果为：&#x27;); %输出函数</span><br><span class="line">disp(sum(Stand_A,2) / n)</span><br></pre></td></tr></table></figure></p><h2 id="方法2：几何平均法求权重"><a href="#方法2：几何平均法求权重" class="headerlink" title="方法2：几何平均法求权重"></a>方法2：几何平均法求权重</h2><p><strong>1、将A的元素按照行相乘得到一个新的列向量</strong></p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clc;A</span><br><span class="line">Prduct_A = prod(A,2) % prod函数和sum函数类似，用于矩阵元素相乘  dim = 2 维度是行，意思是每一行上元素相加</span><br></pre></td></tr></table></figure></code></pre><p><strong>2、将新的向量的每个分量开n次方</strong></p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Prduct_n_A = Prduct_A .^ (1/n)</span><br><span class="line">% “.”是对每个元素进行乘方操作，^符号表示乘方，这里是开n次方，所以我们等价求1/n次方</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><p><strong>3、对该列向量进行归一化即可得到权重向量</strong></p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;几何平均法求权重的结果为：&#x27;);</span><br><span class="line">disp(Prduct_n_A ./ sum(Prduct_n_A))</span><br><span class="line">% 将“Prduct_n_A”列向量中的每一个元素除以“Prduct_n_A”向量的和即可</span><br></pre></td></tr></table></figure></code></pre><h2 id="方法3：特征值法求权重"><a href="#方法3：特征值法求权重" class="headerlink" title="方法3：特征值法求权重"></a>方法3：特征值法求权重</h2><p><strong>1、求出矩阵A的最大特征值以及其对应的特征向量</strong></p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[r,c] = find(D == Max_eig , 1);% 找到D中第一个与最大特征值相等的元素的位置，记录它的行和列。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><p><strong>2、对求出的特征向量进行归一化即可得到我们的权重</strong></p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;特征值法求权重的结果为：&#x27;); %输出函数</span><br><span class="line">disp( V(:,c) ./ sum(V(:,c))) %对求出的特征向量进行归一化即可得到权重</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><h2 id="计算一致性比例CR"><a href="#计算一致性比例CR" class="headerlink" title="计算一致性比例CR"></a>计算一致性比例CR</h2><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clc</span><br><span class="line">CI = (Max_eig - n) / (n-1); %计算一致性指标CI</span><br><span class="line">RI=[0 0 0.52 0.89 1.12 1.26 1.36 1.41 1.46 1.49 1.52 1.54 1.56 1.58 1.59];  %查找对应的平均随机一致性指标RI，这里的RI最多支持 n = 15</span><br><span class="line">CR=CI/RI(n); %计算一致性比例CR</span><br><span class="line">% 输出函数</span><br><span class="line">disp(&#x27;一致性指标CI=&#x27;);disp(CI);</span><br><span class="line">disp(&#x27;一致性比例CR=&#x27;);disp(CR);</span><br><span class="line">% if循环，判断矩阵A的一致性是否可以接受</span><br><span class="line">if CR&lt;0.10</span><br><span class="line">    disp(&#x27;因为CR &lt; 0.10，所以该判断矩阵A的一致性可以接受!&#x27;);</span><br><span class="line">else</span><br><span class="line">    disp(&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改!&#x27;);</span><br><span class="line">end</span><br></pre></td></tr></table></figure></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 层次分析 </tag>
            
            <tag> 数学建模 </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab代码自救手册</title>
      <link href="/2020/07/20/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/matlab/"/>
      <url>/2020/07/20/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/matlab/</url>
      
        <content type="html"><![CDATA[<h1 id="Matlab基本的小常识"><a href="#Matlab基本的小常识" class="headerlink" title="Matlab基本的小常识"></a>Matlab基本的小常识</h1><p><strong>在每一行的语句后面加上分号表示不显示运行结果</strong><br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = 3;  (不显示运行结果)</span><br><span class="line">a = 5  (直接显示运行结果)</span><br></pre></td></tr></table></figure><br><strong>多行注释:选中要注释的若干语句,快捷键Ctrl+R</strong><br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% a = 3;</span><br><span class="line">% a = 5</span><br></pre></td></tr></table></figure></p><p><strong>取消注释:选中要取消注释的语句,快捷键Ctrl+T</strong><br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% 我想要取消注释下面这行</span><br><span class="line">% 还有这一行</span><br></pre></td></tr></table></figure></p><p><strong>清除命令</strong><br>这两条一起使用，起到“初始化”的作用，防止之前的结果对新脚本文件（后缀名 .m）产生干扰<br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear;clc   % 分号也用于区分行</span><br></pre></td></tr></table></figure></p><h1 id="matlab常用函数"><a href="#matlab常用函数" class="headerlink" title="matlab常用函数"></a>matlab常用函数</h1><h2 id="输出和输入函数-disp-和-input"><a href="#输出和输入函数-disp-和-input" class="headerlink" title="输出和输入函数(disp 和 input)"></a>输出和输入函数(disp 和 input)</h2><p><strong>disp函数</strong></p><blockquote><p>matlab中disp()就是屏幕输出函数，类似于c语言中的printf（）函数</p></blockquote><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">disp(&#x27;数学建模&#x27;)</span><br><span class="line">a = [1,2,3]  %同一行中间用逗号分隔，也可以不用逗号，直接用空格</span><br><span class="line">a = [1 2 3]</span><br><span class="line">a = [1;2;3]  %分号可以用来分割每一行的元素</span><br><span class="line">disp(a)  % 注意，disp函数比较特殊，这里可要分号，可不要分号哦</span><br><span class="line">disp(a);</span><br></pre></td></tr></table></figure></code></pre><p><strong>input函数</strong><br>    一般我们会将输入的数、向量、矩阵、字符串等赋给一个变量，这里我们赋给A</p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = input(请输入A：);</span><br><span class="line">B = input(请输入B：)</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>通过input函数我们可以给变量赋值任意的数，有分号不显示输出，没加分号会显示输入的数字。</p></blockquote><h2 id="两个字符串的合并"><a href="#两个字符串的合并" class="headerlink" title="两个字符串的合并"></a>两个字符串的合并</h2><p><strong>strcat(str1,str2…,strn)</strong></p><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcat(&#x27;字符串1&#x27;,&#x27;字符串2&#x27;)</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>输出：’字符串1字符串2’</p></blockquote><p><strong>strcat(‘字符串1’,’字符串2’)</strong><br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;字符串1&#x27;,&#x27;字符串2&#x27;]</span><br><span class="line">[&#x27;字符串1&#x27; &#x27;字符串2&#x27;]</span><br></pre></td></tr></table></figure></p><blockquote><p>输出：<br>    ‘字符串1字符串2’</p></blockquote><h2 id="num2str函数"><a href="#num2str函数" class="headerlink" title="num2str函数"></a>num2str函数</h2><p><strong>num2str函数可将数字转换为字符串</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">c = <span class="number">100</span></span><br><span class="line">num2str(c)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;c的取值为&#x27;</span> num2str(c)])</span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;c的取值为&#x27;</span>, num2str(c)))</span><br><span class="line">```</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>    c的取值为100<br>    c的取值为100</p></blockquote><h2 id="sum函数"><a href="#sum函数" class="headerlink" title="sum函数"></a>sum函数</h2><p> <strong>1、如果是向量（无论是行向量还是列向量），使用sum函数都是直接求和</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line">E = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><blockquote><p>输出：<br>E = 6<br>E = 6</p></blockquote><p><strong>2、如果是矩阵，则需要根据行和列的方向作区分</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">clc</span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">% a=sum(x); %按列求和(得到一个行向量）,默认按列求和</span></span><br><span class="line">a = sum(E)</span><br><span class="line">a = sum(E,<span class="number">1</span>)<span class="comment">%“1”表示维度dim=1按照列求和，dim=2表示按行求和（默认dim=1）</span></span><br><span class="line"><span class="comment">% a=sum(x,2); %按行求和(得到一个列向量）</span></span><br><span class="line">a = sum(E,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% a=sum(x(:));%对整个矩阵求和</span></span><br><span class="line">a = sum(sum(E))</span><br><span class="line">a = sum(E(:))</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="提取矩阵中指定位置的元素"><a href="#提取矩阵中指定位置的元素" class="headerlink" title="提取矩阵中指定位置的元素"></a>提取矩阵中指定位置的元素</h2><p> <strong>1、取指定行和列的一个元素（输出的是一个值）</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)  <span class="comment">%取第2行第1列的元素</span></span><br><span class="line">A(<span class="number">3</span>,<span class="number">2</span>)  <span class="comment">%取第3行第2列的元素</span></span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p> <strong>2、取指定的某一行的全部元素（输出的是一个行向量）</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>];s</span><br><span class="line">A(<span class="number">2</span>,:)  <span class="comment">%取第2行的所有元素</span></span><br><span class="line">A(<span class="number">5</span>,:)  <span class="comment">%取第5行的所有元素</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p> <strong>3、取指定的某一列的全部元素（输出的是一个列向量）</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">A([<span class="number">2</span>,<span class="number">5</span>],:)      <span class="comment">% 只取第二行和第五行（一共2行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">5</span>,:)        <span class="comment">% 取第二行到第五行（一共4行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">5</span>,:)     <span class="comment">% 取第二行和第四行（从2开始，每次递增2个单位，到5结束）</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p> <strong>4、取指定的某些行的全部元素（输出的是一个矩阵）</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span>,:)      <span class="comment">% 取第二行到最后一行</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>,:)    <span class="comment">% 取第二行到倒数第二行</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p> <strong>5、取全部元素(按列拼接的，最终输出的是一个列向量)</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A=[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">A(:)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="size函数"><a href="#size函数" class="headerlink" title="size函数"></a>size函数</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">size</span>(A)</span><br><span class="line"><span class="built_in">size</span>(B)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><blockquote><p>size(A)函数是用来求矩阵A的大小的,它返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">[r,c] = <span class="built_in">size</span>(A)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><blockquote><p>将矩阵A的行数返回到第一个变量r，将矩阵的列数返回到第二个变量c</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">r = <span class="built_in">size</span>(A,<span class="number">1</span>)  <span class="comment">%返回行数</span></span><br><span class="line">c = <span class="built_in">size</span>(A,<span class="number">2</span>) <span class="comment">%返回列数</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="repmat函数"><a href="#repmat函数" class="headerlink" title="repmat函数"></a>repmat函数</h2><p><strong>“B = repmat(A,m,n)”：将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><blockquote><p>B = repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成</p></blockquote><h2 id="Matlab中矩阵的运算"><a href="#Matlab中矩阵的运算" class="headerlink" title="Matlab中矩阵的运算"></a>Matlab中矩阵的运算</h2><p><strong>1、MATLAB在矩阵的运算中，“<em>”号和“/”号代表矩阵之间的乘法与除法(A/B = A</em>inv(B))</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A * B</span><br><span class="line">inv(B)  <span class="comment">% 求B的逆矩阵</span></span><br><span class="line">B * inv(B)  <span class="comment">%求出结果为单位矩阵</span></span><br><span class="line">A * inv(B)</span><br><span class="line">A / B</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>*<em>2、两个形状相同的矩阵对应元素之间的乘除法需要使用“.<em>”和“./”</em></em></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A .* B</span><br><span class="line">A ./ B</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>*<em>3、每个元素同时和常数相乘或相除操作都可以使用“.<em>”和“./”</em></em></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A * <span class="number">2</span></span><br><span class="line">A .* <span class="number">2</span></span><br><span class="line">A / <span class="number">2</span> </span><br><span class="line">A ./ <span class="number">2</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>4、每个元素同时乘方时只能用 “.^”进行计算</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A .^ <span class="number">2</span> <span class="comment">% 等于A.*A</span></span><br><span class="line">A ^ <span class="number">2</span> </span><br><span class="line">A * A</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="Matlab中求特征值和特征向量"><a href="#Matlab中求特征值和特征向量" class="headerlink" title="Matlab中求特征值和特征向量"></a>Matlab中求特征值和特征向量</h2><p><strong>1、在Matlab中，计算矩阵A的特征值和特征向量的函数是eig(A)</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ;<span class="number">2</span> <span class="number">2</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment">%（1）E=eig(A)：求矩阵A的全部特征值，构成向量E</span></span><br><span class="line">E=eig(A)</span><br><span class="line"><span class="comment">%（2）[V,D]=eig(A)：求矩阵A的全部特征值，构成对角阵D，并求A的特征向量构成V的列向量。（V中每一列的特征值对应D中相同列的特征向量）</span></span><br><span class="line">[V,D]=eig(A)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="find函数的基本用法"><a href="#find函数的基本用法" class="headerlink" title="find函数的基本用法"></a>find函数的基本用法</h2><p><strong>find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引；<a href="https://www.cnblogs.com/anzhiwu815/p/5907033.html">详细内容</a></strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">clc;X = [<span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">-3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"><span class="comment">% 其有多种用法，比如返回前2个不为0的元素的位置：</span></span><br><span class="line">ind = <span class="built_in">find</span>(X,<span class="number">2</span>)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p><strong>若X是一个矩阵（二维，有行和列），索引如下所示</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">clc;X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"><span class="comment">% 因为在Matlab在存储矩阵时，是一列一列存储的</span></span><br><span class="line"><span class="comment">% 按照行列的信息输出</span></span><br><span class="line">[r,c] = <span class="built_in">find</span>(X)</span><br><span class="line">[r,c] = <span class="built_in">find</span>(X,<span class="number">1</span>) <span class="comment">%只找第一个非0元素</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="矩阵与常数的大小判断运算"><a href="#矩阵与常数的大小判断运算" class="headerlink" title="矩阵与常数的大小判断运算"></a>矩阵与常数的大小判断运算</h2><blockquote><p>共有三种运算符：大于&gt; ;小于&lt; ;等于 ==（一个等号表示赋值；两个等号表示判断）</p></blockquote><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">X &gt; <span class="number">0</span></span><br><span class="line">X == <span class="number">4</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><p><strong>Matlab的判断语句，if所在的行不需要冒号，语句的最后一定要以end结尾 ；中间的语句要注意缩进</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">a = input(<span class="string">&#x27;请输入考试分数:&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">85</span>  </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &gt;= <span class="number">60</span> </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩合格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩挂科&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="幻方矩阵"><a href="#幻方矩阵" class="headerlink" title="幻方矩阵"></a>幻方矩阵</h2><p><strong>矩阵函数，用作生成一个每一列和都相等的n×n矩阵</strong><br>    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A = magic(2)</span><br><span class="line">B = mafic(4)</span><br></pre></td></tr></table></figure><br><strong>输出：</strong><br><img src="https://i.loli.net/2020/07/23/JKjrtzbQ7vhP4VE.png" alt="7_23_01.png"></p><h2 id="矩阵排序"><a href="#矩阵排序" class="headerlink" title="矩阵排序"></a>矩阵排序</h2><p><strong>MATLAB中排序函数sort()可以对参数的元素进行升序排序或降序排序，具体用法如下：</strong></p><p><img src="https://i.loli.net/2020/07/23/LrinDm3J2Kd7aFp.png" alt="7_23_02png.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学建模 </tag>
            
            <tag> matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建模学习(一)</title>
      <link href="/2020/07/19/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo/"/>
      <url>/2020/07/19/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/jianmo/</url>
      
        <content type="html"><![CDATA[<h1 id="十大模型和其涉及算法"><a href="#十大模型和其涉及算法" class="headerlink" title="十大模型和其涉及算法"></a>十大模型和其涉及算法</h1><table><thead><tr><th align="center">十大模型</th><th align="center">对应的最常用的算法</th></tr></thead><tbody><tr><td align="center">评价类模型</td><td align="center">层次分析法、TOPSIS法（优劣解距离法）</td></tr><tr><td align="center">插值与拟合模型</td><td align="center">多项式值、分段插值、Hermite插值、样条插值（一维）、n维数据的插值、cftool工具箱</td></tr><tr><td align="center">相关性模型</td><td align="center">相关系数、皮尔逊person和斯皮尔曼spearman、典型型相关分析</td></tr><tr><td align="center">回归模型</td><td align="center">多元回归分析、逐步回归分析、岭回归和Lasso回归</td></tr><tr><td align="center">图论模型</td><td align="center">Dijkstra迪杰斯特拉算法、Floyd算法</td></tr><tr><td align="center">分类问题</td><td align="center">二分类：logisyic回归、Fisher判别分析、SVM支持向量机;多分类：多分类Logisic回归模型</td></tr><tr><td align="center">聚类模型</td><td align="center">K-Means++算法、DBSCAN聚类算法</td></tr><tr><td align="center">时间序列模型</td><td align="center">AR、MA、ARMA模型；ARCH模型和GARCH模型；单位根时间序列</td></tr><tr><td align="center">预测模型</td><td align="center">插值预测、时间序列预测、灰色预测模型、BP神经网络</td></tr><tr><td align="center">降维模型</td><td align="center">SVD奇异值分解（图像处理）、主成分分析、因子分析</td></tr></tbody></table><hr><h1 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h1><p>（The analytic hierarchy process，简称AHP）<br> 主要用于解决评价类问题，例如：方案选择、哪位运动员给或者员工表现更优秀</p><p>##评价类问题</p><h3 id="1、评价类问题可用打分解决"><a href="#1、评价类问题可用打分解决" class="headerlink" title="1、评价类问题可用打分解决"></a>1、评价类问题可用打分解决</h3><p>使用打分法解决评价问题，只需要补充下表</p><table><thead><tr><th align="center"></th><th align="center">指标权重</th><th align="center">方案1</th><th align="center">方案2</th><th align="center">…</th></tr></thead><tbody><tr><td align="center">指标1</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">指标2</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">指标3</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">…</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><p><strong>表中各指标的指标权重和为1，各指标方案和也为1，它们表示针对某一因素所占的权重。</strong></p><h3 id="2、解决评价类问题，要思考以下问题："><a href="#2、解决评价类问题，要思考以下问题：" class="headerlink" title="2、解决评价类问题，要思考以下问题："></a>2、解决评价类问题，要思考以下问题：</h3><p>1.<strong>我们评价的目标或目的是什么？</strong>（如：旅游最佳目的地的选择、最佳员工的选择，其中目的地与最佳员工就是我们评价的目标）</p><p>2.<strong>我们为了达到这个目标可选的方案有哪些？</strong>（如：旅游问题的目的地，员工问题的候选人）</p><p>3.<strong>评价的准则（指标）是什么？</strong>（是根据什么标准或划分哪些因素，做出评价。如：旅游问题的食住行）</p><p>前两个问题的答案一般可以分析题目得出，第三个问题需要结合题中的<strong>背景材料、常识以及网上搜集到的参考资料</strong>（知网等平台搜索）进行分析，从而选出最合适的指标。也可以小组进行讨论、搜索专家看法或调查问卷来获取需要的指标。 推荐网站：<a href="https://www.chongbuluo.com/">虫部落</a></p><p><strong>我们对指标权重的确定，一次性考虑三个或三个以上指标之间的关系时，往往会考虑不周。</strong></p><p><strong>所以我们用对指标进行两两比较，根据两两比较的结果来推算权重。</strong></p><p>层次分析法可以通过重要程度表给出的规定来进行两个因素之间的比较。</p><table><thead><tr><th>标度</th><th>含义</th></tr></thead><tbody><tr><td>1</td><td>表示两个因素相比，同样重要</td></tr><tr><td>3</td><td>表示两个因素相比，一个因素比另一个因素稍微重要</td></tr><tr><td>5</td><td>表示两个因素相比，一个因素比另一个因素明显重要</td></tr><tr><td>7</td><td>表示两个因素相比，一个因素比另一个因素强烈重要</td></tr><tr><td>9</td><td>表示两个因素相比，一个因素比另一个因素极端重要</td></tr><tr><td>2，4，6，8</td><td>上述两相邻判断的中值</td></tr><tr><td>倒数</td><td>A和B相比如果标度为3，那么B和A想必就是1/3</td></tr></tbody></table><h2 id="层次分析法解题步骤"><a href="#层次分析法解题步骤" class="headerlink" title="层次分析法解题步骤"></a>层次分析法解题步骤</h2><h3 id="1、分析系统中各因素的关系，建立系统的递阶层次结构"><a href="#1、分析系统中各因素的关系，建立系统的递阶层次结构" class="headerlink" title="1、分析系统中各因素的关系，建立系统的递阶层次结构"></a>1、分析系统中各因素的关系，建立系统的<strong>递阶层次结构</strong></h3><p><img src="https://i.loli.net/2020/07/20/84Wyn7TYasQqefg.png" alt="层次结构图"></p><h3 id="2、构造判断矩阵"><a href="#2、构造判断矩阵" class="headerlink" title="2、构造判断矩阵"></a>2、构造判断矩阵</h3><table><thead><tr><th align="center">Cn</th><th align="center">P1</th><th align="center">P2</th><th align="center">P3</th></tr></thead><tbody><tr><td align="center">P1</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">P2</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">P3</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><blockquote><p>在构造判断矩阵时，矩阵中的数需要自己填写。在论文表达上可不做体现，直接给出相应判断矩阵即可。<br>准则层——方案层的判断矩阵要结合实际来填写，如果题目中有其他数据，可以考虑利用这些数据进行计算。</p></blockquote><h3 id="3、计算权重"><a href="#3、计算权重" class="headerlink" title="3、计算权重"></a>3、计算权重</h3><p><em><strong>由判断矩阵计算被比较元素对于该准则的相对权重，并进行一致性检验。</strong></em></p><p><strong>计算权重的方法</strong></p><blockquote><p>（1）算术平均法  （2）几何平均法  （3）特征值法</p></blockquote><p>进行比赛时三种方法都使用，这样可以保证结果的稳健性，得出的结论更全面、有效，让人信服。</p><p><strong>写作示例</strong></p><blockquote><p>为了保证结果的稳健性（稳定性），本文分别采用算术平均法、几何平均法、特征值法三种方法分别得出权重，再根据得到的权重矩阵计算各方案的得分，并进行排序和综合分析，这样避免了采用单一方法所产生的偏差，所得出的结论（结果）将更全面、更有效。</p></blockquote><h3 id="4、进行一致性检验"><a href="#4、进行一致性检验" class="headerlink" title="4、进行一致性检验"></a>4、进行一致性检验</h3><p><strong>一致性检验的步骤</strong></p><p><strong>1、计算一致性指标CI</strong><br><img src="https://i.loli.net/2020/07/20/z1uUA5efgbYXPHo.png" alt="一致性指标"></p><p><strong>2、查找对应的平均随机一致性指标RI</strong></p><table><thead><tr><th align="center">n</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th><th align="center">5</th><th align="center">6</th><th align="center">7</th><th align="center">8</th><th align="center">9</th><th align="center">10</th><th align="center">11</th><th align="center">12</th><th align="center">13</th><th align="center">14</th><th align="center">15</th></tr></thead><tbody><tr><td align="center">RI</td><td align="center">0</td><td align="center">0</td><td align="center">0.52</td><td align="center">0.89</td><td align="center">1.12</td><td align="center">1.26</td><td align="center">1.36</td><td align="center">1.41</td><td align="center">1.46</td><td align="center">1.49</td><td align="center">1.52</td><td align="center">1.54</td><td align="center">1.56</td><td align="center">1.58</td><td align="center">1.59</td></tr></tbody></table><p><em>注：在实际运用中，n很少超过10，如果指标的个数大于10，则可考虑建立二级指标体系</em></p><p><strong>3、计算一致性比例CR</strong><br><img src="https://i.loli.net/2020/07/20/OpwA1Wnurt38QLF.png" alt="一致性比例"></p><blockquote><p>如果CR &gt; 0.1，则可以认为判断矩阵的一致性可以接受；否则需要对判断矩阵进行修正。</p></blockquote><p><em>因为一致矩阵性矩各行成倍数关系，需要调整的判断矩阵可通过此性质进行调整</em></p><p><strong>4、计算个层元素对系统目标层的合成权重，并进行排序</strong></p><blockquote><p>合成权重=不同方案对应指标的权重 × 指标权重</p></blockquote><h3 id="层次分析法的一些局限性"><a href="#层次分析法的一些局限性" class="headerlink" title="层次分析法的一些局限性"></a>层次分析法的一些局限性</h3><blockquote><p> 1、评价的决策层不能太多，太多n会很大，判断矩阵和一致性矩阵差异可能会很大。（n&lt;=15）<br> 2、如果决策层中指标数据已知，不适合用层次分析。</p></blockquote><p><strong>如果决策层中指标数据已知,我们可以采用TOPSIS法解决此类问题。<a href="https://dpool110.github.io/2020/07/21/jianmo02/">TOPSIS</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 层次分析 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
